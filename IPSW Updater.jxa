//
// Created by Pico Mitchell (of Free Geek)
//
// https://ipsw.app
// https://github.com/freegeek-pdx/IPSW-Updater
//
// Uses: IPSW Downloads API (https://ipsw.me) by Callum Jones (https://ipsw.me/about)
// Icon: â€œPhone with Arrowâ€ from Fluent Emoji (https://github.com/microsoft/fluentui-emoji) by Microsoft (https://opensource.microsoft.com) licensed under the MIT License (https://github.com/microsoft/fluentui-emoji/blob/main/LICENSE)
//
// MIT License
//
// Copyright (c) 2022 Free Geek
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

// NOTES:
// "use strict" is set and "AppKit" is imported in "main.scpt".
// "LSMinimumSystemVersion" is set to 10.13 in "Build IPSW Updater" (make sure to only use ECMAScript 2018 features, which is what macOS 10.13 High Sierra supports).
// 10.12.2+ Compatible Emoji List: https://emojipedia.org/apple/ios-10.2/ (To make sure that only emoji that are available on at least macOS 10.13 High Sierra are used.)
// Emoji Used: ðŸ›‘âš™ï¸ðŸš«ðŸ—‘â°ðŸ”ŒðŸ‘¤âœ…ðŸ”„âš–ï¸ðŸ”ðŸ“²â³âŒ›ï¸â­ï¸ðŸâ†©ï¸â†ªï¸ðŸ—“ðŸ’¤âš ï¸âŒðŸ‘‰ðŸ“â¤´ï¸ðŸ‘â±ï¸ðŸ“ŒðŸ“

const appVersion = '2022.12.14-1'

// @ts-ignore: JXA-ObjC
ObjC.import('unistd') // For "getuid" function.
// @ts-ignore: JXA-ObjC
ObjC.import('Security') // For "SecStaticCodeCheckValidity" and other functions for code signature validation.

// @ts-ignore: JXA-ObjC
ObjC.bindFunction('CFMakeCollectable', ['id', ['void *']]) // See https://github.com/JXA-Cookbook/JXA-Cookbook/issues/13#issuecomment-174820487 for info about "CFMakeCollectable" (and also the "cfRefToNSObjectIfNeeded" function below).

// @ts-ignore: "Application.currentApplication()" is set to "a" and "a.includeStandardAdditions" is set to "true" in "main.scpt" which runs this script via "exec()".
const app = a
// @ts-ignore: "$.NSBundle.mainBundle" is set to "ab" in "main.scpt" which runs this script via "exec()".
const appBundle = ab
// @ts-ignore: "ab.bundlePath.js" is set to "ap" in "main.scpt" which runs this script via "exec()".
let appPath = ap

wakeMacUp()

const appName = appBundle.objectForInfoDictionaryKey('CFBundleName').js
const bundleExecutableName = appBundle.objectForInfoDictionaryKey('CFBundleExecutable').js

// @ts-ignore: JXA-ObjC
const fileManager = $.NSFileManager.defaultManager

if (!fileManager.fileExistsAtPath(`${appPath}/Contents/MacOS/${bundleExecutableName}`) || !fileManager.fileExistsAtPath(`${appPath}/Contents/Resources/Scripts/main.scpt`) || !fileManager.fileExistsAtPath(`${appPath}/Contents/Resources/Launch ${bundleExecutableName}`)) {
	debugLog('App Check Error', appPath)

	if (macIsAwakeAndUnlocked()) { // Just quit if Mac IS NOT awake and unlocked since AppleScript dialogs will timeout early if Mac is asleep when it's displayed.
		try {
			app.activate()
			app.displayAlert(`${appName}: App Check Error`,
				{
					message: `${appName} must be run as an application.`,
					as: 'critical',
					buttons: ['Quit', `Re-Download â€œ${appName}â€`],
					cancelButton: 1,
					defaultButton: 2
				}
			)

			app.doShellScript('/usr/bin/open https://ipsw.app/download/')
		} catch (ignoredError) { /* Ignore */ }
	}

	app.quit()
}

const bundleIdentifier = appBundle.bundleIdentifier.js
const intendedBundleIdentifier = `org.freegeek.${bundleExecutableName.replace(/ /g, '-')}`
if (bundleIdentifier != intendedBundleIdentifier) {
	debugLog('Incorrect Bundle Identifier Error', bundleIdentifier)

	if (macIsAwakeAndUnlocked()) { // Just quit if Mac IS NOT awake and unlocked since AppleScript dialogs will timeout early if Mac is asleep when it's displayed.
		try {
			app.activate()
			app.displayAlert(`${appName}: Bundle Identifier Error`,
				{
					message: `Intended Bundle Identifier:
${intendedBundleIdentifier}

Actual Bundle Identifier:
${bundleIdentifier}`,
					as: 'critical',
					buttons: ['Quit', `Re-Download â€œ${appName}â€`],
					cancelButton: 1,
					defaultButton: 2
				}
			)

			app.doShellScript('/usr/bin/open https://ipsw.app/download/')
		} catch (ignoredError) { /* Ignore */ }
	}

	app.quit()
}

const infoDictVersion = appBundle.objectForInfoDictionaryKey('CFBundleShortVersionString').js
if (infoDictVersion != appVersion) {
	debugLog(`Incorrect App Version Error: ${infoDictVersion} != ${appVersion}`)

	if (macIsAwakeAndUnlocked()) { // Just quit if Mac IS NOT awake and unlocked since AppleScript dialogs will timeout early if Mac is asleep when it's displayed.
		try {
			app.activate()
			app.displayAlert(`${appName}: App Version Error`,
				{
					message: `Intended App Version:
${appVersion}

Actual App Version:
${infoDictVersion}`,
					as: 'critical',
					buttons: ['Quit', `Re-Download â€œ${appName}â€`],
					cancelButton: 1,
					defaultButton: 2
				}
			)

			app.doShellScript('/usr/bin/open https://ipsw.app/download/')
		} catch (ignoredError) { /* Ignore */ }
	}

	app.quit()
}

// @ts-ignore: JXA-ObjC
const processInfo = $.NSProcessInfo.processInfo
const isMojaveOrNewer = processInfo.isOperatingSystemAtLeastVersion({majorVersion: 10, minorVersion: 14, patchVersion: 0})
const isCatalinaOrNewer = processInfo.isOperatingSystemAtLeastVersion({majorVersion: 10, minorVersion: 15, patchVersion: 0})
const isBigSurOrNewer = processInfo.isOperatingSystemAtLeastVersion({majorVersion: 11, minorVersion: 0, patchVersion: 0})
const isMontereyOrNewer = processInfo.isOperatingSystemAtLeastVersion({majorVersion: 12, minorVersion: 0, patchVersion: 0})
const isVenturaOrNewer = processInfo.isOperatingSystemAtLeastVersion({majorVersion: 13, minorVersion: 0, patchVersion: 0})

try {
	// IMPORTANT: On each launch, confirm the running app is properly signed (and notarized, when possible on macOS 10.14 Mojave and newer).
	// See comments in the "validateCodeSignatureForAppAtPath" function for more information.
	validateCodeSignatureForAppAtPath(appPath) // NOTE: This function with "throw" an error if validation fails which will be caught and displayed below.
} catch (codeSignatureValidationError) {
	debugLog('Code Signature Error', codeSignatureValidationError)

	if (macIsAwakeAndUnlocked()) { // Just quit if Mac IS NOT awake and unlocked since AppleScript dialogs will timeout early if Mac is asleep when it's displayed.
		try {
			app.activate()
			app.displayAlert(`${appName}: Code Signature Error`,
				{
					message: codeSignatureValidationError.message,
					as: 'critical',
					buttons: ['Quit', `Re-Download â€œ${appName}â€`],
					cancelButton: 1,
					defaultButton: 2
				}
			)

			app.doShellScript('/usr/bin/open https://ipsw.app/download/')
		} catch (ignoredError) { /* Ignore */ }
	}

	app.quit()
}

if (isVenturaOrNewer) {
	// @ts-ignore: JXA-ObjC
	ObjC.import('ServiceManagement') // For "SMAppService" to check if the LaunchAgent is enabled on macOS 13 Ventura (see comments in "launchAgentIsDisabledOnVenturaOrNewer()" function for more information).
}

// @ts-ignore: JXA-ObjC
const mainMenu = $.NSApp.mainMenu
try { mainMenu.removeItem(mainMenu.itemWithTitle('File')) } catch (ignoredError) { /* Ignore */ }

try {
	const appMenu = mainMenu.itemWithTitle('applet').submenu
	try {
		const preferencesMenuItem = appMenu.itemWithTitle('Preferencesâ€¦')
		if (!preferencesMenuItem.isNil()) appMenu.removeItem(preferencesMenuItem)
		else if (isVenturaOrNewer) appMenu.removeItem(appMenu.itemWithTitle('Settingsâ€¦')) // This menu item will be "Settingsâ€¦" instead of "Preferencesâ€¦" when built with and running on macOS 13 Ventura.
	} catch (ignoredError) { /* Ignore */ }
	try { appMenu.removeItem(appMenu.itemWithTitle(`Quit ${appName}`)) } catch (ignoredError) { /* Ignore */ }
	try {
		// NOTE: This "Quit and Keep Windows" menu item (which is the alternate menu item for the "Quit" menu item, accessed by holding the Option key)
		// will only be created and therefore only need to be remove IF the app menu was opened BEFORE this code had a chance to run,
		// which isn't super likely but can still happen so it should still always be checked and removed if it exists.
		const quitAndKeepWindowsMenuItem = appMenu.itemWithTitle('Quit and Keep Windows')
		if (!quitAndKeepWindowsMenuItem.isNil()) appMenu.removeItem(quitAndKeepWindowsMenuItem) // Check if isn't nil before removing since it might not exist and "removeItem" will log an error if nil is passed to it.
	} catch (ignoredError) { /* Ignore */ }
} catch (ignoredError) { /* Ignore */ }

try {
	const editMenu = mainMenu.itemWithTitle('Edit').submenu
	try { editMenu.removeItem(editMenu.itemWithTitle('Edit Script')) } catch (ignoredError) { /* Ignore */ }
} catch (ignoredError) { /* Ignore */ }

// @ts-ignore: JXA-ObjC
const currentUserName = $.NSUserName().js
// @ts-ignore: JXA-ObjC
const currentUserID = $.getuid()

// @ts-ignore: JXA-ObjC
const standardUserDefaults = $.NSUserDefaults.standardUserDefaults
standardUserDefaults.registerDefaults({
	RefusedMoveToApplications: false,
	FirstRun: true,
	AppJustAutoUpdated: false,
	AppUpdateAvailable: false,
	ExcludeProducts: [],
	IncludeVersions: 7,
	ManagedFirmwares: {},
	FirmwareUpdatesAvailable: 0,
	AcknowledgedSignificantResults: true,
	ImmediatelyDeleteOutdatedFirmwares: false,
	ForceDialogWindowStyle: false,
})

let uuid = getPreference('UUID', 'string')
if (!uuid) {
	// @ts-ignore: JXA-ObjC
	uuid = $.NSUUID.UUID.UUIDString.js
	setPreference('UUID', uuid, 'string')
}

// @ts-ignore: JXA-ObjC
const sharedWorkspace = $.NSWorkspace.sharedWorkspace

const settingsOrPreferencesName = (isVenturaOrNewer ? 'Settings' : 'Preferences')
const systemPreferencesOrSettingsName = `System ${settingsOrPreferencesName}`

const curlPIDs = [] // Save all CURL PIDs to kill them all before quitting just in case.

// @ts-ignore: JXA-ObjC
const applicationSupportFolder = `${fileManager.URLsForDirectoryInDomains($.NSApplicationSupportDirectory, $.NSUserDomainMask).firstObject.path.js}/${appName}`
if (!fileManager.fileExistsAtPath(applicationSupportFolder))
	// @ts-ignore: JXA-ObjC
	fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(applicationSupportFolder, true, {}, $())

const temporaryFilesFolder = `${applicationSupportFolder}/Temporary Files`

// @ts-ignore: JXA-ObjC
const userTrashPath = fileManager.URLsForDirectoryInDomains($.NSTrashDirectory, $.NSUserDomainMask).firstObject.path.js

const appIsQuarantined = (appPath.includes('/AppTranslocation/') || app.doShellScript(`/usr/bin/xattr ${quoteForShell(appPath)}`).includes('com.apple.quarantine'))

let appPaths = []
try { appPaths = app.doShellScript(`/usr/bin/mdfind kMDItemCFBundleIdentifier = ${bundleIdentifier}`).split(/\n|\r/) } catch (ignoredError) { /* Ignore */ }

// @ts-ignore: JXA-ObjC
let parentDirectoryToMe = $(appPath).stringByDeletingLastPathComponent.js
if (appPath.includes('/AppTranslocation/')) {
	let mostRecentlyOpenedAppPath = appPath
	let mostRecentlyOpenedAppDate = new Date('1984-01-24')
	for (const thisAppPath of appPaths)
		try {
			if (!thisAppPath.includes('/AppTranslocation/')) {
				let appLastUsedDateString = app.doShellScript(`/usr/bin/mdls -raw -name kMDItemLastUsedDate ${quoteForShell(thisAppPath)}`)

				// kMDItemLastUsedDate will be "(null)" if it was never launched (which would happen when launching a quarantined app), so lets check the date added.
				if (!appLastUsedDateString || (appLastUsedDateString == "(null)"))
					appLastUsedDateString = app.doShellScript(`/usr/bin/mdls -raw -name kMDItemDateAdded ${quoteForShell(thisAppPath)}`)

				const appLastUsedDate = new Date(appLastUsedDateString.slice(0, -6).replace(' ', 'T'))

				if (appLastUsedDate > mostRecentlyOpenedAppDate) {
					mostRecentlyOpenedAppDate = appLastUsedDate
					mostRecentlyOpenedAppPath = thisAppPath
				}
			}
		} catch (ignoredError) { /* Ignore */ }

	if (appPath != mostRecentlyOpenedAppPath) {
		appPath = mostRecentlyOpenedAppPath
		// @ts-ignore: JXA-ObjC
		parentDirectoryToMe = $(appPath).stringByDeletingLastPathComponent.js
	}
}

try {
	// Set Touch Bar settings to NOT be "App Controls" for this Bundle ID because AppleScript alert and dialog buttons don't update properly on the Touch Bar.
	// @ts-ignore: JXA-ObjC
	const touchBarPrefs = $.NSUserDefaults.alloc.initWithSuiteName('com.apple.touchbar.agent')
	// @ts-ignore: JXA-ObjC
	const touchBarPrefsPresentationModePerAppDict = $.NSMutableDictionary.dictionaryWithDictionary(touchBarPrefs.dictionaryForKey('PresentationModePerApp'))
	if (touchBarPrefsPresentationModePerAppDict.objectForKey(bundleIdentifier).js != 'fullControlStrip') {
		touchBarPrefsPresentationModePerAppDict.setObjectForKey('fullControlStrip', bundleIdentifier)
		touchBarPrefs.setObjectForKey(touchBarPrefsPresentationModePerAppDict, 'PresentationModePerApp')
	}
} catch (ignoredError) { /* Ignore */ }

// Always "killall ControlStrip" even if PresentationModePerApp was set on a previous launch
// because for some reason the setting won't take effect until the app loses and regains focus,
// or if I just go ahead and "killall ControlStrip" right away.
try { app.doShellScript('/usr/bin/killall ControlStrip') } catch (ignoredError) { /* Ignore */ }

if (!getPreference('RefusedMoveToApplications', 'bool') && !appPath.startsWith('/Applications/')) {
	while (!macIsAwakeAndUnlocked()) // AppleScript dialogs will timeout early if Mac is asleep when it's displayed. So, wait until Mac is awake to display the dialog.
		// @ts-ignore: JXA
		delay(15)

	// @ts-ignore: JXA
	delay(0.5)

	app.activate()

	try {
		let parentDirectoryName = fileManager.displayNameAtPath(parentDirectoryToMe).js

		if (parentDirectoryToMe.endsWith('/Applications')) parentDirectoryName = 'User Applications'

		const moveToApplicationsDialogButtons = [
			((appPath.includes('/AppTranslocation/') || (parentDirectoryName == 'UNKNOWN')) ? 'No, Run from Current Folder' : `No, Run from â€œ${parentDirectoryName}â€ Folder`),
			'Reveal in Finder & Quit',
			'Yes, Move to â€œApplicationsâ€ Folder'
		]

		const moveToApplicationsDialogReply = displayAlertOrDialogDependingOnOS(`${appName} is not properly installed in the â€œApplicationsâ€ folder.

Would you like ${appName} to move itself to the â€œApplicationsâ€ folder?`,
			`${((appPath.includes('/AppTranslocation/') || (parentDirectoryName == 'UNKNOWN')) ? '' : `${appName} is currently running from within the â€œ${parentDirectoryName}â€ folder: ${parentDirectoryToMe}/

`)}Like all applications, ${appName} should be run from within the â€œApplicationsâ€ folder.`,
			`${appName}  â€”  Install Application`,
			'caution',
			moveToApplicationsDialogButtons,
			2,
			3
		)

		if (moveToApplicationsDialogReply.buttonReturned == moveToApplicationsDialogButtons[2]) {
			if (!fileManager.fileExistsAtPath(temporaryFilesFolder))
				// @ts-ignore: JXA-ObjC
				fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(temporaryFilesFolder, true, {}, $())

			// @ts-ignore: JXA-ObjC
			const appFileName = $(appPath).lastPathComponent.js

			const moveToApplicationsFolderScript = `/usr/bin/osascript -e ${quoteForShell(`
use AppleScript version "2.7"
use scripting additions
use framework "Foundation"

set currentAppFilePath to ${quoteForAppleScript(appPath)}

delay 0.5
repeat while (application currentAppFilePath is running)
	delay 0.5
end repeat
${((appIsQuarantined && (appPaths.length > 0)) ? `
try
	do shell script "/usr/bin/xattr -drs com.apple.quarantine " & ${appPaths.map(thisAppPath => `(quoted form of ${quoteForAppleScript(thisAppPath)})`).join(' & " " & ')}
end try
` : '')}
set appInTempFolder to ${quoteForAppleScript(`${temporaryFilesFolder}/${appFileName}`)}

set systemApplicationsFolder to (POSIX path of (path to applications folder from system domain))
set appInSystemApplicationsFolder to (systemApplicationsFolder & ${quoteForAppleScript(appFileName)})
set actualInstallFilePath to appInSystemApplicationsFolder

set userApplicationsFolder to (POSIX path of (path to applications folder from user domain))
set appInUserApplicationsFolder to (userApplicationsFolder & ${quoteForAppleScript(appFileName)})

set userDownloadsFolder to (POSIX path of (path to downloads folder from user domain))
set appInUserDownloadsFolder to (userDownloadsFolder & ${quoteForAppleScript(appFileName)})

set adminPermissionPrompt to "â€œ${quoteForAppleScript(appName, true)}â€ requires Admin Permission to move itself to the â€œApplicationsâ€ folder."

try
	set appOriginalFileStructure to ""
	try
		set appOriginalFileStructure to (do shell script ("cd " & (quoted form of currentAppFilePath) & " && /bin/ls -Rsk"))
	end try

	set fileManager to (defaultManager of NSFileManager of current application)

	try
		if (fileExistsAtPath_(appInTempFolder) of fileManager) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInTempFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInTempFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInTempFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((fileExistsAtPath_(currentAppFilePath) of fileManager) and (not (fileExistsAtPath_(appInTempFolder) of fileManager))) then moveItemAtPath_toPath_error_(currentAppFilePath, appInTempFolder, missing value) of fileManager -- This fails when currentAppFilePath is in /AppTranslocation/
	end try
	try
		if ((fileExistsAtPath_(appInUserDownloadsFolder) of fileManager) and (not (fileExistsAtPath_(appInTempFolder) of fileManager))) then moveItemAtPath_toPath_error_(appInUserDownloadsFolder, appInTempFolder, missing value) of fileManager -- Fall back on this even though its not the best assumption.
	end try
	try
		if ((fileExistsAtPath_(currentAppFilePath) of fileManager) and (not (fileExistsAtPath_(appInTempFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of currentAppFilePath) & " " & (quoted form of appInTempFolder) with prompt adminPermissionPrompt with administrator privileges -- This fails when currentAppFilePath is in /AppTranslocation/
	end try
	if ((fileExistsAtPath_(appInUserDownloadsFolder) of fileManager) and (not (fileExistsAtPath_(appInTempFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appInUserDownloadsFolder) & " " & (quoted form of appInTempFolder) with prompt adminPermissionPrompt with administrator privileges -- Fall back on this even though its not the best assumption.
${(appIsQuarantined ? `
	try
		if (fileExistsAtPath_(appInTempFolder) of fileManager) then do shell script "/usr/bin/xattr -drs com.apple.quarantine " & (quoted form of appInTempFolder)
	end try
` : '')}
	try
		if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInSystemApplicationsFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInSystemApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInUserApplicationsFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInUserApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInUserDownloadsFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInUserDownloadsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (not (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager))) then
			moveItemAtPath_toPath_error_(appInTempFolder, appInSystemApplicationsFolder, missing value) of fileManager
			if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (not (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appInTempFolder) & " " & (quoted form of appInSystemApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (not (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager))) then
			moveItemAtPath_toPath_error_(appInTempFolder, appInUserApplicationsFolder, missing value) of fileManager
			if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (not (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appInTempFolder) & " " & (quoted form of appInUserApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
			set actualInstallFilePath to appInUserApplicationsFolder
		end if
	end try

	if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (not (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager))) then
		moveItemAtPath_toPath_error_(appInTempFolder, appInUserDownloadsFolder, missing value) of fileManager
		if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (not (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appInTempFolder) & " " & (quoted form of appInUserDownloadsFolder) with prompt adminPermissionPrompt with administrator privileges
		set actualInstallFilePath to appInUserDownloadsFolder
	end if

	if (fileExistsAtPath_(actualInstallFilePath) of fileManager) then
		-- When working auto-updating for MacLand Scripts, Catalina seems to fail to launch if done too quickly after a move (with an "executable not found" error).
		-- Generating the install path file structure alone seems to delay enough to avoid the issue, but this loop makes it extra safe.

		repeat 30 times
			try
				set installAppFileStructure to ""
				try
					set installAppFileStructure to (do shell script ("cd " & (quoted form of actualInstallFilePath) & " && /bin/ls -Rsk"))
				on error
					try
						set installAppFileStructure to (do shell script ("cd " & (quoted form of actualInstallFilePath) & " && /bin/ls -Rsk") with prompt adminPermissionPrompt with administrator privileges)
					on error
						exit repeat
					end try
				end try
				if (appOriginalFileStructure is equal to installAppFileStructure) then exit repeat
			end try
			delay 0.5
		end repeat
	end if
on error moveError
	activate
	beep
	display alert "Error Moving â€œ${quoteForAppleScript(appName, true)}â€ to â€œApplicationsâ€ Folder" message moveError as critical
end try
do shell script "/bin/rm -rf " & (quoted form of ${quoteForAppleScript(temporaryFilesFolder)})
try
	do shell script "/usr/bin/open -na " & (quoted form of actualInstallFilePath)
on error
	try
		do shell script "/usr/bin/open -na " & (quoted form of currentAppFilePath)
	on error
		try
			do shell script "/usr/bin/open -nb ${bundleIdentifier}"
		on error launchError
			activate
			beep
			display alert "Error Re-Launching â€œ${quoteForAppleScript(appName, true)}â€\nAfter Moving to â€œApplicationsâ€ Folder" message launchError buttons {"Quit", "Re-Download â€œ${quoteForAppleScript(appName, true)}â€"} cancel button 1 default button 2 as critical
			do shell script "/usr/bin/open 'https://ipsw.app/download/'"
		end try
	end try
end try
`)} > /dev/null 2>&1 &`

			//debugDialog(moveToApplicationsFolderScript.replace(/\/usr\/bin\/osascript -e '|' > \/dev\/null 2>&1 &/g, '').replace(/'\\''/g, "'").trim())
			//debugDialog(app.doShellScript(moveToApplicationsFolderScript.replace('/usr/bin/osascript -e ', "printf '%s' ").replace(' > /dev/null 2>&1 &', '')).trim())

			app.doShellScript(moveToApplicationsFolderScript)

			app.quit()
		} else if (moveToApplicationsDialogReply.buttonReturned == moveToApplicationsDialogButtons[0]) {
			setPreference('RefusedMoveToApplications', true, 'bool')

			if (appIsQuarantined && (appPaths.length > 0)) {
				app.doShellScript(`/usr/bin/osascript -e ${quoteForShell(`
delay 0.5
repeat while (application ${quoteForAppleScript(appPath)} is running)
	delay 0.5
end repeat
try
	do shell script "/usr/bin/xattr -drs com.apple.quarantine " & ${appPaths.map(thisAppPath => `(quoted form of ${quoteForAppleScript(thisAppPath)})`).join(' & " " & ')}
end try
try
	do shell script "/usr/bin/open -na " & (quoted form of ${quoteForAppleScript(appPath)})
on error
	try
		do shell script "/usr/bin/open -nb ${bundleIdentifier}"
	end try
end try
`)} > /dev/null 2>&1 &`)

				app.quit()
			}
		}
	} catch (moveToApplicationsError) {
		if (moveToApplicationsError.errorNumber !== -128)
			debugLog('Move to Applications Folder Error', moveToApplicationsError)

		if (appPath.includes('/AppTranslocation/'))
			app.beep()
		else
			// @ts-ignore: JXA-ObjC
			try { sharedWorkspace.activateFileViewerSelectingURLs($.NSArray.arrayWithObject($.NSURL.fileURLWithPath(appPath))) } catch (ignoredError) { app.beep() }

		if (appIsQuarantined && (appPaths.length > 0))
			app.doShellScript(`/usr/bin/osascript -e ${quoteForShell(`
delay 0.5
repeat while (application ${quoteForAppleScript(appPath)} is running)
	delay 0.5
end repeat
try
	do shell script "/usr/bin/xattr -drs com.apple.quarantine " & ${appPaths.map(thisAppPath => `(quoted form of ${quoteForAppleScript(thisAppPath)})`).join(' & " " & ')}
end try
`)} > /dev/null 2>&1 &`)

		if (moveToApplicationsError.errorNumber !== -128)
			throw moveToApplicationsError
		else
			app.quit()
	}
}

let justInstalledUpdate = getPreference('AppJustAutoUpdated', 'bool')
if (justInstalledUpdate) setPreference('AppJustAutoUpdated', false, 'bool')

let lastInstall = getPreference('LastAppInstall', 'dict')
const versionLastRun = ((lastInstall && lastInstall.NewVersion) ? lastInstall.NewVersion : undefined)
if (versionLastRun != appVersion) {
	const lastInstallInfo = {NewVersion: appVersion, LaunchDate: new Date()}

	if (versionLastRun) {
		lastInstallInfo.OldVersion = versionLastRun
		justInstalledUpdate = true
	}

	setPreference('LastAppInstall', lastInstallInfo, 'dict')
}

const everyProductType = ['iPhone', 'iPad', 'iPod touch', 'Apple TV', 'HomePod mini', 'T2 Mac (iBridge Firmware)', 'Apple Silicon Mac']
const everyDayOfTheWeek = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
const defaultAutoLaunchHour = 18
const defaultAutoLaunchMinute = 30 // NOTE: DO NOT change this to less that 15 since the auto-wake time will always be 15 minutes before and that math only does a basic subtraction of these minutes without worrying about moving to a previous hour.
const daysAsLettersForPMSet = ['M', 'T', 'W', 'R', 'F', 'S', 'U']
const autoWakeTypeTranslation = {wakepoweron: 'Start Up'/* or Wake*/, wake: 'Wake', poweron: 'Start Up', sleep: 'Sleep', restart: 'Restart', shutdown: 'Shut Down'}

/** @type Intl.DateTimeFormatOptions */
const dateFormatOptions = {weekday: 'short', month: 'long', day: 'numeric', year: 'numeric'}

let shouldImmediatelyDeleteOutdatedFirmwares = getPreference('ImmediatelyDeleteOutdatedFirmwares', 'bool')

const isFirstRun = getPreference('FirstRun', 'bool')
let userDidCancel = false

// @ts-ignore: JXA-ObjC
const userLibraryFolder = fileManager.URLsForDirectoryInDomains($.NSLibraryDirectory, $.NSUserDomainMask).firstObject.path.js

const launchAgentsPath = `${userLibraryFolder}/LaunchAgents`
const launchAgentPlistPath = `${launchAgentsPath}/${bundleIdentifier}.plist`

if (fileManager.fileExistsAtPath(launchAgentPlistPath)) { // Check if a LaunchAgent exists and update it if needed. See comments below for more info.
	const currentAutoLaunchSchedule = parseLaunchAgentSchedule()
	createLaunchAgentWithDaysAndHour(currentAutoLaunchSchedule.days, currentAutoLaunchSchedule.hour)

	// NOTES ABOUT CHECKING AND UPDATING LAUNCHAGENT (IF NEEDED) ON EVERY LAUNCH:

	// The "createLaunchAgentWithDaysAndHour" function with the same schedule that is already set will check the existing LaunchAgent and make sure it matches the current structure and
	// expected values and update it if needed, which is very important for the "Program" path in case the app is moved since the launcher path must point to the current app location to work.

	// If the existing LaunchAgent matches the exact expected LaunchAgent structure and values, it WILL NOT be updated or re-bootstrapped.

	// Calling the "createLaunchAgentWithDaysAndHour" function will also update any LaunchAgents made by previous versions to the currently used structure
	// which would be used when creating a new LaunchAgent, such as the following changes (and fixes):

	// LaunchAgents created prior to version 2022.10.21-1 specified "ProgramArguments" instead of a single "Program" path to the signed launcher script
	// and also didn't have "AssociatedBundleIdentifiers" specified for compatibility with macOS 13 Ventura.

	// LaunchAgents updated on launch by version 2022.11.17-1 and 2022.11.23-1 would accidentally/incorrectly have their "integer" values converted to "real" values
	// (because of running "deepUnwrap" on the NSDictionary of the plist, see comments in "createLaunchAgentWithDaysAndHour" function for more info about this JS int conversion issue)
	// which would not get parsed correctly by "launchd" and cause the app to incorrectly be automatically launched every minute or every hour.
}

const libraryITunesFolder = `${userLibraryFolder}/iTunes`
if (!fileManager.fileExistsAtPath(libraryITunesFolder))
	// @ts-ignore: JXA-ObjC
	fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(libraryITunesFolder, true, {}, $())

const appleConfiguratorFirmwareFolder = `${userLibraryFolder}/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Firmware`
if (!fileManager.fileExistsAtPath(appleConfiguratorFirmwareFolder))
	// @ts-ignore: JXA-ObjC
	fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(appleConfiguratorFirmwareFolder, true, {}, $())

// @ts-ignore: JXA-ObjC
try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }

if (isFirstRun) {
	for ( ; ; ) {
		while (!macIsAwakeAndUnlocked()) // AppleScript dialogs will timeout early if Mac is asleep when it's displayed. So, wait until Mac is awake to display the dialog.
			// @ts-ignore: JXA
			delay(15)

		app.activate()

		try {
			const welcomeDialogReply = displayAlertOrDialogDependingOnOS(`Welcome to ${appName}!
Made by Pico Mitchell of Free Geek (freegeek.org) using the IPSW Downloads API (ipsw.me) by Callum Jones.

${appName} can batch download all the latest IPSW Firmware files from Apple and place them in the correct iTunes Software Updates or Apple Configurator Firmware folders so that they are automatically found by ${isCatalinaOrNewer ? 'Finder' : 'iTunes'} and/or Apple Configurator.

You can set which IPSW Firmware files to download based on versions as well as product types, such as ${everyProductType.slice(0, -1).join(', ')}, and ${everyProductType.slice(-1)[0]}. You can also set ${appName} to run automatically at a scheduled time so that all of your IPSW Firmware files will always be kept up-to-date.`,
				`If you agree, ${appName} will take over management of your iTunes Software Updates and Apple Configurator Firmware folders. You can use the button below to view these folders in Finder.

iPhone, iPad, and iPod touch IPSW Firmware files will be stored within iTunes Software Updates folders at â€œ${libraryITunesFolder}â€ since they will be found by both ${isCatalinaOrNewer ? 'Finder' : 'iTunes'} and Apple Configurator at that location.

Apple TV, HomePod mini, and T2 and Apple Silicon Mac IPSW Firmware files will be stored within the Apple Configurator Firmware folder at â€œ${appleConfiguratorFirmwareFolder}â€. This is because unlike iPhone, iPad, and iPod touch IPSW Firmware files, Apple Configurator will not detect or use IPSW Firmware files for Apple TVs or HomePod minis from the iTunes Software Updates folders. Also, T2 and Apple Silicon Macs cannot be restored by ${isCatalinaOrNewer ? 'Finder' : 'iTunes'} and can only be restored by Apple Configurator when they are put into DFU mode.

Any IPSW Firmware files that are already in these folders will become managed by ${appName}. That means that IPSW Firmware files in these locations will be moved to the Trash (or deleted, based on your ${settingsOrPreferencesName.toLowerCase()}) when they become out-of-date after an update for them has been downloaded by ${appName}. Also, as described above, any iPhone, iPad, and iPod touch IPSW Firmware files that are currently in the Apple Configurator Firmware folder will be moved into their correct iTunes Software Updates folder and any Apple TV or HomePod IPSW Firmware files in the iTunes Software Updates folders will be moved into the Apple Configurator Firmware folder. Finally, any IPSW Firmware files currently in these folders that are out-of-date but are still signed by Apple will be left alone and any that are no longer signed by Apple will be moved to the Trash (or deleted). ${appName} will check for unsigned IPSW Firmware files each time it runs, so existing files may be trashed (or deleted) in the future if and when Apple no longer signs them.

To use ${appName}, you must agree to let it manage your iTunes Software Updates and Apple Configurator Firmware folders and to update itself (app updates are checked on each launch). Once you agree, you'll be prompted to choose your desired ${settingsOrPreferencesName.toLowerCase()}, such as Excluded Product Types, Included iOS / iPadOS / tvOS Versions, Trash or Delete Outdated Files, Auto-Launch Schedule, and Start Up Schedule.`,
				`${appName}  â€”  Welcome`,
				'note',
				['View iTunes Software Updates and Apple Configurator Firmware Folders', 'Quit', `Agree & Choose ${settingsOrPreferencesName}`],
				2,
				3
			)

			if (welcomeDialogReply.buttonReturned == `Agree & Choose ${settingsOrPreferencesName}`)
				break
			else if (welcomeDialogReply.buttonReturned == 'View iTunes Software Updates and Apple Configurator Firmware Folders') {
				// @ts-ignore: JXA-ObjC
				sharedWorkspace.openURL($.NSURL.fileURLWithPath(libraryITunesFolder))
				// @ts-ignore: JXA-ObjC
				sharedWorkspace.openURL($.NSURL.fileURLWithPath(appleConfiguratorFirmwareFolder))
			}
		} catch (welcomeDialogError) {
			if (welcomeDialogError.errorNumber === -128)
				cleanUpAndQuitEarly()
			else {
				debugLog('Welcome Dialog Error', welcomeDialogError)
				break // Just start if somehow times out or other error
			}
		}
	}

	promptForPreferences()

	setPreference('FirstRun', false, 'bool')
}

Progress.description = `
${(justInstalledUpdate ? `âœ…	Updated to Version ${appVersion}!` : (isFirstRun ? `ðŸ“²	Welcome to ${appName}!` : 'ðŸ”„	Checking for App Updates'))}`
Progress.additionalDescription = ''
Progress.completedUnitCount = 0
Progress.totalUnitCount = -1

let progressWindow = undefined
// @ts-ignore: JXA-ObjC
for (const thisWindow of $.NSApp.windows.js)
	if (thisWindow.title.js == appName) {
		for (const thisSubview of thisWindow.contentView.subviews.js)
			// @ts-ignore: JXA-ObjC
			if ($.NSStringFromClass(thisSubview.class).js == 'NSProgressIndicator') { // Check for NSProgressIndicator to not accidentally choose the "startup screen" window in case the app was launched when the Control key was being held.
				progressWindow = thisWindow
				// @ts-ignore: JXA-ObjC
				progressWindow.standardWindowButton($.NSWindowZoomButton).enabled = false
				break
			}

		if (progressWindow) break
	}

const releaseNotesURL = 'https://ipsw.app/download/updates.php'
const appUpdatesJsonURL = `${releaseNotesURL}?current_version=${appVersion}&os=${app.systemInfo().systemVersion}&uuid=${uuid}`

if (!justInstalledUpdate && !isFirstRun)
	checkAndInstallAppUpdates()
else {
	setProgressStopButtonEnabled(false)
	app.activate()

	if (justInstalledUpdate) {
		if (macIsAwakeAndUnlocked()) { // Skip update installed confirmation prompt if Mac IS NOT awake and unlocked.
			const appUpdatesJsonFilePath = `${temporaryFilesFolder}/app-updates.json`
			const appUpdatesJsonProgressOutputFile = `${temporaryFilesFolder}/app-updates.json-progress`

			// @ts-ignore: JXA-ObjC
			const readAppUpdatesFileError = $()

			try {
				if (!fileManager.fileExistsAtPath(temporaryFilesFolder))
					// @ts-ignore: JXA-ObjC
					fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(temporaryFilesFolder, true, {}, $())

				const downloadAppUpdatesJsonPID = app.doShellScript(`/usr/bin/curl -m 5 -L ${quoteForShell(`${appUpdatesJsonURL}&just_updated=1`)} -o ${quoteForShell(appUpdatesJsonFilePath)} > ${quoteForShell(appUpdatesJsonProgressOutputFile)} 2>&1 & echo $!`)
				curlPIDs.push(downloadAppUpdatesJsonPID)

				try {
					while (app.doShellScript(`/bin/ps -p ${downloadAppUpdatesJsonPID} > /dev/null 2>&1; echo $?`) == 0)
						// @ts-ignore: JXA
						delay(0.25)
				} catch (waitingForAppUpdatesJsonError) {
					debugLog('Waiting for App Updates JSON Error', waitingForAppUpdatesJsonError)

					try { app.doShellScript(`kill ${downloadAppUpdatesJsonPID}`) } catch (ignoredError) { /* Ignore */ }

					throw waitingForAppUpdatesJsonError
				}

				// @ts-ignore: JXA-ObjC
				const appUpdatesInfo = JSON.parse($.NSString.stringWithContentsOfFileEncodingError(appUpdatesJsonFilePath, $.NSUTF8StringEncoding, readAppUpdatesFileError).js)
				// NOTE: NOT using "ObjC.deepUnwrap($.NSJSONSerialization.JSONObjectWithDataOptionsError(...))" for consistency with other JSON parsing which don't use it for other reasons which aren't really important here (this JSON parse really would be fine with either technique).

				if (!Array.isArray(appUpdatesInfo)) throw new Error('App Updates JSON Is NOT an Array')

				// @ts-ignore: JXA-ObjC
				try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }

				let newVersionReleaseNotes = 'No Release Notes'

				if (appUpdatesInfo.length > 0)
					for (const thisAppUpdate of appUpdatesInfo)
						if (thisAppUpdate.version == appVersion) {
							if (thisAppUpdate.releasenotes)
								newVersionReleaseNotes = thisAppUpdate.releasenotes

							break
						}

				closeProgressWindow()

				if (macIsAwakeAndUnlocked()) {
					for ( ; ; ) {
						app.activate()
						try {
							displayAlertOrDialogDependingOnOS(`Welcome to ${appName} Version ${appVersion}!`,
								`Version ${appVersion} Release Notes:

${newVersionReleaseNotes}`,
								`${appName}  â€”  Updated to ${appVersion}`,
								'note',
								['View All Release Notes', 'Continue'],
								1,
								2,
								60
							)

							break
						} catch (appUpdatedDialogError) {
							if (appUpdatedDialogError.errorNumber === -128)
								// @ts-ignore: JXA-ObjC
								sharedWorkspace.openURL($.NSURL.URLWithString(releaseNotesURL))
							else
								break
						}
					}
				}
			} catch (appUpdateError) {
				closeProgressWindow()

				let appUpdateErrorMessage = appUpdateError.message
				if (!readAppUpdatesFileError.isNil()) appUpdateError = readAppUpdatesFileError.description.js

				try {
					// @ts-ignore: JXA-ObjC
					const progressOutputParts = $.NSString.stringWithContentsOfFileEncodingError(appUpdatesJsonProgressOutputFile, $.NSUTF8StringEncoding, $()).js.split('curl: ')
					if (progressOutputParts.length > 1)
						appUpdateErrorMessage = `CURL Error: ${progressOutputParts.slice(-1)[0].trim()}`
				} catch (ignoredError) { /* Ignore */ }

				// @ts-ignore: JXA-ObjC
				try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }

				debugLog(`Confirm App Update Error: ${appUpdateErrorMessage}`, appUpdateError)
			}
		} else
			try {
				// But, even if Mac IS NOT awake and unlocked still do the "curl" call to "appUpdatesJsonURL" with the new version parameters,
				// (but do not wait for it to finish or save the output) just so that the successful app update is still saved in the server log.

				app.doShellScript(`/usr/bin/curl -m 5 -sL ${quoteForShell(`${appUpdatesJsonURL}&just_updated=2`)} > /dev/null 2>&1 &`) // "just_updated=2" indicates an update when the Mac is asleep or locked (while "just_updated=1" indicates updated while awake an unlocked).
			} catch (ignoredError) { /* Ignore */ }
	} else {
		// @ts-ignore: JXA
		delay(0.5)
		closeProgressWindow()
	}
}

let lastAppUpdatedNote = ''
try {
	lastInstall = getPreference('LastAppInstall', 'dict')
	if (lastInstall && lastInstall.OldVersion && lastInstall.NewVersion && lastInstall.LaunchDate) {
		const oneWeekAgoDate = new Date()
		oneWeekAgoDate.setDate(oneWeekAgoDate.getDate() - 7)

		if (lastInstall.LaunchDate.getTime() >= oneWeekAgoDate.getTime())
			lastAppUpdatedNote = `
â¤´ï¸ App Last Updated:
	ðŸ—“ ${lastInstall.LaunchDate.toLocaleDateString('en-US', dateFormatOptions)} @ ${lastInstall.LaunchDate.toLocaleTimeString('en-US')}`
	}
} catch (ignoredError) { /* Ignore */ }

const updatesLogPath = `${applicationSupportFolder}/Updates Log.json`
let updatesLog = []
if (fileManager.fileExistsAtPath(updatesLogPath)) {
	// @ts-ignore: JXA-ObjC
	const readUpdateLogFileError = $()

	try {
		// @ts-ignore: JXA-ObjC
		updatesLog = JSON.parse($.NSString.stringWithContentsOfFileEncodingError(updatesLogPath, $.NSUTF8StringEncoding, readUpdateLogFileError).js)
		// NOTE: NOT using "ObjC.deepUnwrap($.NSJSONSerialization.JSONObjectWithDataOptionsError(...))" to read this JSON to the file since it alters the order of the keys within dicts when written later, which should be preserved since it's the desired dispay order of this human readable "Updates Log.json" file.
		if (!Array.isArray(updatesLog)) throw new Error('Parsed JSON Is NOT an Array')
	} catch (readUpdatesLogError) {
		let readUpdatesLogErrorMessage = readUpdatesLogError.message
		if (!readUpdateLogFileError.isNil()) readUpdatesLogError = readUpdateLogFileError.description.js

		// @ts-ignore: JXA-ObjC
		try { fileManager.removeItemAtPathError(updatesLogPath, $()) } catch (ignoredError) { /* Ignore */ } // Delete any invalid Updates Log since it would just get overwritten anyways.

		debugLog(`Read "Updates Log.json" Error: ${readUpdatesLogErrorMessage}`, readUpdatesLogError)
		updatesLog = []
	}
}
let lastFirmwareUpdateCheck = `

	ðŸ” Last Checked:`
const lastFirmwareUpdateCheckDate = getPreference('LastFirmwareUpdateCheck', 'date')
if (lastFirmwareUpdateCheckDate) {
	try {
		const firmwareUpdatesAvailable = getPreference('FirmwareUpdatesAvailable', 'int')
		lastFirmwareUpdateCheck += `
		ðŸ—“ ${lastFirmwareUpdateCheckDate.toLocaleDateString('en-US', dateFormatOptions)} @ ${lastFirmwareUpdateCheckDate.toLocaleTimeString('en-US')}${(
		(firmwareUpdatesAvailable && (firmwareUpdatesAvailable > 0)) ? `
		â¤´ï¸ ${firmwareUpdatesAvailable} Firmware Update${(firmwareUpdatesAvailable == 1) ? '' : 's'} Available` : '')}`
	} catch (ignoredError) {
		lastFirmwareUpdateCheck += `
		UNKNOWN`
	}
} else
	lastFirmwareUpdateCheck += `
		Never`

let lastUpdateSummary = ''
let lastErrorSummary = ''

for (const thisUpdate of updatesLog)
	if (thisUpdate.Status)
		if (thisUpdate.Status.includes('Updated') || thisUpdate.Status.includes('Initial')) {
			try {
				const lastDownloadedFilesCount = Object.keys(thisUpdate.Downloaded.Files).length
				if (lastDownloadedFilesCount > 0) {
					if (lastFirmwareUpdateCheck.includes(thisUpdate.Times.Start)) lastFirmwareUpdateCheck = ''

					const lastSkippedDownloadsCount = (thisUpdate.Downloaded.Skipped ? parseInt(thisUpdate.Downloaded.Skipped) : 0)
					const lastDownloadErrorsCount = Object.keys(thisUpdate.Errors).length
					lastUpdateSummary = `

â†©ï¸ ${(thisUpdate.Status.includes('Updated') ? `Last ${thisUpdate.Status}` : thisUpdate.Status)}:
	ðŸ—“ ${thisUpdate.Times.Start}
	ðŸ“² Updated ${lastDownloadedFilesCount} IPSW File${((lastDownloadedFilesCount == 1) ? '' : 's')} (${thisUpdate.Downloaded['Total Size']})${createVersionsDownloadedSummary(thisUpdate.Downloaded.Files, 1)}${((lastSkippedDownloadsCount > 0) ? `
	â­ï¸ Skipped ${lastSkippedDownloadsCount} Update${((lastSkippedDownloadsCount == 1) ? '' : 's')}` : '')}${((lastDownloadErrorsCount > 0) ? `
	âš ï¸ ${lastDownloadErrorsCount} Download Error${((lastDownloadErrorsCount == 1) ? '' : 's')} Occurred` : '')}`
				}
			} catch (ignoredError) { /* Ignore */ }

			break
		} else if (!lastErrorSummary && thisUpdate.Status.includes('Error')) {
			try {
				const lastDownloadErrorKeys = Object.keys(thisUpdate.Errors)
				const lastDownloadErrorsCount = lastDownloadErrorKeys.length
				if (lastDownloadErrorsCount > 0) {
					if (lastFirmwareUpdateCheck.includes(thisUpdate.Times.Start)) lastFirmwareUpdateCheck = ''
					const firstLastDownloadErrorObject = thisUpdate.Errors[lastDownloadErrorKeys[0]]
					lastErrorSummary = `

â†ªï¸ Last ${thisUpdate.Status}:
	ðŸ—“ ${thisUpdate.Times.Start}
	${((thisUpdate.Status == 'Load Error') ?
	`âš ï¸ ${(Array.isArray(firstLastDownloadErrorObject) ? firstLastDownloadErrorObject[0] : firstLastDownloadErrorObject).replace('CURL Error: (6) ', '').trim()}` :
	`âš ï¸ ${lastDownloadErrorsCount} Download Error${((lastDownloadErrorsCount == 1) ? '' : 's')} Occurred`)}`
				}
			} catch (ignoredError) { /* Ignore */ }
		}

if (macIsAwakeAndUnlocked()) { // Skip launch window if asleep or locked (just start checking for updates immediately).
	const autoStartSeconds = 45

	for ( ; ; ) {
		const currentExcludedProducts = getPreference('ExcludeProducts', 'string array') // This returned excluded product will always be sanitized to a valid value by "getPreference()".
		const currentIncludedVersions = getPreference('IncludeVersions', 'int') // This returned version will always be sanitized to a valid value by "getPreference()".

		let currentAutoLaunchScheduleDisplay = createDisplayScheduleFor(parseLaunchAgentSchedule())
		if ((currentAutoLaunchScheduleDisplay != 'Never') && launchAgentIsDisabledOnVenturaOrNewer())
			currentAutoLaunchScheduleDisplay += `
		âš ï¸\tManually Disabled in System Settings`

		const currentAutoWakeSchedules = parseAutoWakePowerEventPreferences()
		let currentAutoWakeOnScheduleDisplay = createDisplayScheduleFor(currentAutoWakeSchedules.On)
		// @ts-ignore: JXA-ObjC
		if ((currentAutoWakeOnScheduleDisplay != 'Never') && ($.NSUserDefaults.alloc.initWithSuiteName('/Library/Preferences/com.apple.loginwindow').stringForKey('autoLoginUser').js != currentUserName))
			currentAutoWakeOnScheduleDisplay += `
		âš ï¸\tAuto-Login Must Be Enabled\n\t\t\tto Auto-Launch on Start Up`

		let currentAutoWakeOffScheduleDisplay = createDisplayScheduleFor(currentAutoWakeSchedules.Off)
		if ((currentAutoWakeOffScheduleDisplay != 'Never') && hasConflictingPowerSchedules(currentAutoWakeSchedules))
			currentAutoWakeOffScheduleDisplay += `
		âš ï¸\tShut Down Schedule May Conflict\n\t\t\twith Start Up Schedule`

		app.activate()

		let includedVersionsDisplay = ''

		const iOSincludedVersions = []
		if (!currentExcludedProducts.includes('iPhone') || !currentExcludedProducts.includes('iPod touch'))
			iOSincludedVersions.push('iOS')
		if (!currentExcludedProducts.includes('iPad'))
			iOSincludedVersions.push('iPadOS')
		if (!currentExcludedProducts.includes('Apple TV'))
			iOSincludedVersions.push('tvOS')
		if (iOSincludedVersions.length > 0)
			includedVersionsDisplay += `${iOSincludedVersions.join(' / ')} ${currentIncludedVersions} and Newer`

		if (!currentExcludedProducts.includes('HomePod mini') || !currentExcludedProducts.includes('T2 Mac (iBridge Firmware)') || !currentExcludedProducts.includes('Apple Silicon Mac')) {
			const otherOSincludedVersions = []
			if (!currentExcludedProducts.includes('HomePod mini'))
				otherOSincludedVersions.push('audioOS')
			if (!currentExcludedProducts.includes('T2 Mac (iBridge Firmware)'))
				otherOSincludedVersions.push('bridgeOS')
			if (!currentExcludedProducts.includes('Apple Silicon Mac'))
				otherOSincludedVersions.push('macOS')

			if (includedVersionsDisplay) includedVersionsDisplay += '\n\t\t'
			includedVersionsDisplay += `Latest ${((otherOSincludedVersions.length <= 2) ? otherOSincludedVersions.join(' and ') : `${otherOSincludedVersions.slice(0, -1).join(', ')}, and ${otherOSincludedVersions.slice(-1)[0]}`)}`
		}

		try {
			const countDownDialogReply = displayAlertOrDialogDependingOnOS(`${appName} will start in ${autoStartSeconds} secondsâ€¦`,
				`Version ${appVersion}${lastAppUpdatedNote}


ðŸ“² Firmware Updates Overview:${lastFirmwareUpdateCheck}${lastErrorSummary.replace(/\n|\r/g, '\n\t')}${lastUpdateSummary.replace(/\n|\r/g, '\n\t')}


âš™ï¸ ${settingsOrPreferencesName} Overview:

	ðŸš« Excluded Product Types:
		${((currentExcludedProducts.length == 0) ? 'None' : currentExcludedProducts.join(', ').replace(', HomePod', ',\n\t\tHomePod').replace(', T2', ',\n\t\tT2').replace(', Apple Silicon', ',\n\t\tApple Silicon'))}

	ðŸ Included Versions:
		${includedVersionsDisplay}

	ðŸ—‘ Outdated IPSW Files:
		${shouldImmediatelyDeleteOutdatedFirmwares ? 'Immediately Deleted' : 'Trashed'}

	â° Auto-Launch Schedule:
		${currentAutoLaunchScheduleDisplay}

	ðŸ”Œ Power Schedule:
		${((currentAutoWakeOnScheduleDisplay == 'Never') ? 'No Start Up Schedule' : currentAutoWakeOnScheduleDisplay)}${
		((currentAutoWakeOffScheduleDisplay == 'Never') ? '' : `
		${currentAutoWakeOffScheduleDisplay}`)}`,
				appName,
				'note',
				[`Edit ${settingsOrPreferencesName}â€¦`, 'Quit', 'Start Now'],
				2,
				3,
				autoStartSeconds
			)

			if (countDownDialogReply.gaveUp || (countDownDialogReply.buttonReturned == 'Start Now'))
				break
			else if (countDownDialogReply.buttonReturned == `Edit ${settingsOrPreferencesName}â€¦`)
				promptForPreferences()
		} catch (countDownDialogError) {
			if (countDownDialogError.errorNumber === -128)
				cleanUpAndQuitEarly()
			else
				break // Just start if somehow times out or other error
		}
	}
}

wakeMacUp()

const startDate = new Date()

debugLog('Checking Existing IPSW Firmware Files Are in Correct Locations')

Progress.description = `
ðŸ”„	Checking Existing IPSW Firmware Files Are in Correct Locations`
Progress.additionalDescription = ''
Progress.completedUnitCount = 0
Progress.totalUnitCount = -1

try {
	if (fileManager.fileExistsAtPath(appleConfiguratorFirmwareFolder)) {
		const productTypesToMoveOutOfAppleConfiguratorFirmwareFolder = ['iPhone', 'iPad', 'iPod']
		// @ts-ignore: JXA-ObjC
		for (const thisFirmwareFileNameInSoftwareUpdatesFolder of ObjC.deepUnwrap(fileManager.contentsOfDirectoryAtPathError(appleConfiguratorFirmwareFolder, $())))
			for (const thisProductType of productTypesToMoveOutOfAppleConfiguratorFirmwareFolder)
				if (thisFirmwareFileNameInSoftwareUpdatesFolder.startsWith(thisProductType)) {
					const thisIntendedSoftwareUpdatesFolder = `${libraryITunesFolder}/${thisProductType} Software Updates`

					if (fileManager.fileExistsAtPath(`${thisIntendedSoftwareUpdatesFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`))
						// @ts-ignore: JXA-ObjC
						try { fileManager.removeItemAtPathError(`${thisIntendedSoftwareUpdatesFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`, $()) } catch (ignoredError) { /* Ignore */ }
					else if (!fileManager.fileExistsAtPath(thisIntendedSoftwareUpdatesFolder))
						// @ts-ignore: JXA-ObjC
						fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(thisIntendedSoftwareUpdatesFolder, true, {}, $())

					// @ts-ignore: JXA-ObjC
					try { fileManager.moveItemAtPathToPathError(`${appleConfiguratorFirmwareFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`, `${thisIntendedSoftwareUpdatesFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`, $()) } catch (ignoredError) { /* Ignore */ }
				}
	}
} catch (moveOutOfAppleConfiguratorFirmwareFolderError) {
	debugLog('Move iPhone, iPad, and iPod Firmware Out Of Apple Configurator Firmware Folder Error', moveOutOfAppleConfiguratorFirmwareFolderError)

	if (!userDidCancel) userDidCancel = (moveOutOfAppleConfiguratorFirmwareFolderError.errorNumber === -128)
}

try {
	if (fileManager.fileExistsAtPath(libraryITunesFolder)) {
		const productTypesToMoveOutOfLibraryITunesSoftwareUpdatesFolders = ['Apple TV', 'HomePod']

		for (const thisProductType of productTypesToMoveOutOfLibraryITunesSoftwareUpdatesFolders)
			if (fileManager.fileExistsAtPath(`${libraryITunesFolder}/${thisProductType} Software Updates`)) {
				// @ts-ignore: JXA-ObjC
				for (const thisFirmwareFileNameInSoftwareUpdatesFolder of ObjC.deepUnwrap(fileManager.contentsOfDirectoryAtPathError(`${libraryITunesFolder}/${thisProductType} Software Updates`, $()))) {
					if (fileManager.fileExistsAtPath(`${appleConfiguratorFirmwareFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`))
						// @ts-ignore: JXA-ObjC
						try { fileManager.removeItemAtPathError(`${appleConfiguratorFirmwareFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`, $()) } catch (ignoredError) { /* Ignore */ }

					// @ts-ignore: JXA-ObjC
					try { fileManager.moveItemAtPathToPathError(`${libraryITunesFolder}/${thisProductType} Software Updates/${thisFirmwareFileNameInSoftwareUpdatesFolder}`, `${appleConfiguratorFirmwareFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`, $()) } catch (ignoredError) { /* Ignore */ }
				}

				// @ts-ignore: JXA-ObjC
				try { fileManager.removeItemAtPathError(`${libraryITunesFolder}/${thisProductType} Software Updates`, $()) } catch (ignoredError) { /* Ignore */ }
			}
	}
} catch (moveOutOfLibraryITunesSoftwareUpdatesFoldersError) {
	debugLog('Move Apple TV and HomePod Firmware Out Of iTunes Software Updates Folders Error', moveOutOfLibraryITunesSoftwareUpdatesFoldersError)

	if (!userDidCancel) userDidCancel = (moveOutOfLibraryITunesSoftwareUpdatesFoldersError.errorNumber === -128)
}

debugLog('Starting to Check for IPSW Firmware Updates')

if (!fileManager.fileExistsAtPath(temporaryFilesFolder))
	// @ts-ignore: JXA-ObjC
	fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(temporaryFilesFolder, true, {}, $())

let globalGetFirmwaresErrorMessage = 'UNKNOWN ERROR'
const downloadErrors = {}
let allFirmwareInfo = {}
const allFirmwaresFilePath = `${temporaryFilesFolder}/firmwares.json`
let firmwareProgressOutputFile = `${temporaryFilesFolder}/firmwares.json-progress`
const cachedAllFirmwaresFilePath = `${applicationSupportFolder}/cached-firmwares.json`

// @ts-ignore: JXA-ObjC
const readFirmwaresFileError = $()

try {
	Progress.description = `
ðŸ”„	Loading Latest IPSW Firmware Information`
	Progress.additionalDescription = ''
	Progress.completedUnitCount = 0
	Progress.totalUnitCount = -1

	setProgressStopButtonEnabled(true)

	app.activate()

	openProgressWindow()

	// @ts-ignore: JXA
	delay(0.1)

	const firmwaresInfoURLs = ['https://api.ipsw.me/v3/firmwares.json/condensed', 'https://api.ipsw.me/v3/firmwares.json']
	// First try the smaller "condensed" JSON, but if that does not have a "device" array, try the un-condensed version since that seems to get updated faster when IPSW.me is updating firmwares when a new update is released by Apple.

	for (const thisFirmwaresInfoURL of firmwaresInfoURLs) {
		debugLog('Downloading Firmwares JSON', thisFirmwaresInfoURL)

		if (curlPIDs.length > 0) try { app.doShellScript(`kill ${curlPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }

		const downloadFirmwaresInfoPID = app.doShellScript(`/usr/bin/curl --connect-timeout 5 -L ${quoteForShell(thisFirmwaresInfoURL)} -o ${quoteForShell(allFirmwaresFilePath)} > ${quoteForShell(firmwareProgressOutputFile)} 2>&1 & echo $!`)
		curlPIDs.push(downloadFirmwaresInfoPID)

		try {
			while (app.doShellScript(`/bin/ps -p ${downloadFirmwaresInfoPID} > /dev/null 2>&1; echo $?`) == 0)
				// @ts-ignore: JXA
				delay(0.25)
		} catch (waitingForDownloadError) {
			debugLog('Waiting for Download Error', waitingForDownloadError)

			try { app.doShellScript(`kill ${downloadFirmwaresInfoPID}`) } catch (ignoredError) { /* Ignore */ }

			throw waitingForDownloadError
		}

		setProgressStopButtonEnabled(false)

		// @ts-ignore: JXA-ObjC
		allFirmwareInfo = JSON.parse($.NSString.stringWithContentsOfFileEncodingError(allFirmwaresFilePath, $.NSUTF8StringEncoding, readFirmwaresFileError).js)
		// NOTE: NOT using "ObjC.deepUnwrap($.NSJSONSerialization.JSONObjectWithDataOptionsError(...))" since it takes about 3x as long as "JSON.parse" to parse this large JSON file (because of the required "ObjC.deepUnwrap" to get it into the desired JS dict).

		if (allFirmwareInfo.devices) {
			debugLog('Caching Latest Downloaded Firmwares JSON File') // Caching firmwares.json to be loaded when api.ipsw.me is updating was inspired by https://github.com/ninxsoft/mist-cli/issues/110#issuecomment-1296966051

			// @ts-ignore: JXA-ObjC
			try { fileManager.removeItemAtPathError(cachedAllFirmwaresFilePath, $()) } catch (ignoredError) { /* Ignore */ } // If successfully loaded the latest firmwares.json, delete the previous cached file...
			// @ts-ignore: JXA-ObjC
			try { fileManager.moveItemAtPathToPathError(allFirmwaresFilePath, cachedAllFirmwaresFilePath, $()) } catch (ignoredError) { /* Ignore */ } // and save the new firmwares.json at the cache location to use if needed when loading when api.ipsw.me is being updated.

			break
		} else {
			// @ts-ignore: JXA-ObjC
			try { fileManager.removeItemAtPathError(allFirmwaresFilePath, $()) } catch (ignoredError) { /* Ignore */ }

			if (thisFirmwaresInfoURL.endsWith('.json') && allFirmwareInfo.iTunes && fileManager.fileExistsAtPath(cachedAllFirmwaresFilePath)) { // If failed to load the latest firmwares.json because api.ipsw.me is being updated, and have a previously cached firmwares.json file, load it instead.
				debugLog('Loading Cached Firmwares JSON File Since api.ipsw.me Is Updating Firmware Info')

				// @ts-ignore: JXA-ObjC
				allFirmwareInfo = JSON.parse($.NSString.stringWithContentsOfFileEncodingError(cachedAllFirmwaresFilePath, $.NSUTF8StringEncoding, readFirmwaresFileError).js)
			}
		}
	}
} catch (getFirmwaresError) {
	setProgressStopButtonEnabled(false)

	if (!userDidCancel) userDidCancel = (getFirmwaresError.errorNumber === -128)

	let getFirmwaresErrorMessage = getFirmwaresError.message
	if (!readFirmwaresFileError.isNil()) getFirmwaresError = readFirmwaresFileError.description.js

	try {
		// @ts-ignore: JXA-ObjC
		const progressOutputParts = $.NSString.stringWithContentsOfFileEncodingError(firmwareProgressOutputFile, $.NSUTF8StringEncoding, $()).js.split('curl: ')
		if (progressOutputParts.length > 1)
			getFirmwaresErrorMessage = `CURL Error: ${progressOutputParts.slice(-1)[0].trim()}`
	} catch (ignoredError) { /* Ignore */ }

	globalGetFirmwaresErrorMessage = getFirmwaresErrorMessage.replace(/\n|\r/g, '')

	debugLog(`Error Loading Firmware Info: ${globalGetFirmwaresErrorMessage}`, getFirmwaresError)

	if (!userDidCancel)
		downloadErrors['https://api.ipsw.me/v3/firmwares.json/condensed'] = globalGetFirmwaresErrorMessage
}

setProgressStopButtonEnabled(false)

// @ts-ignore: JXA-ObjC
try { fileManager.removeItemAtPathError(firmwareProgressOutputFile, $()) } catch (ignoredError) { /* Ignore */ }
// @ts-ignore: JXA-ObjC
try { fileManager.removeItemAtPathError(allFirmwaresFilePath, $()) } catch (ignoredError) { /* Ignore */ }

let unsignedFirmwares = []
let uniqueFirmwares = {}

let newManagedFirmware = {}
let uniqueDeviceNamesForFirmwareFileNames = {}

try {
	for (const thisModelID in allFirmwareInfo.devices) {
		if ((thisModelID == 'ADP3,2') || thisModelID.startsWith('VirtualMac')) continue // Ignore Device IDs for "Apple Silicon Developer Transition Kit" (ADP3,2) and "Apple Silicon Virtual Machine" (currently only ever "VirtualMac2,1" but ignoring any possible future numbers as well).
		// The "Apple Silicon Developer Transition Kit" (ADP3,2) device is ignored because it will always be stuck at macOS 11.2.3 Big Sur and the devices should have all been returned to Apple.
		// The "Apple Silicon Virtual Machine" (VirtualMac2,1) device is ignored because it should always be the same version as all the other actual hardware devices, and there's no need to include "Apple Virtual Machine 1" in the "displayDeviceNames" for macOS downloads.

		const thisDeviceObject = allFirmwareInfo.devices[thisModelID]
		const firmwaresForDevice = thisDeviceObject.firmwares

		for (let thisFirmwareIndex = 0; thisFirmwareIndex < firmwaresForDevice.length; thisFirmwareIndex ++) {
			const thisFirmware = firmwaresForDevice[thisFirmwareIndex]
			const thisFirmwareFileName = decodeURIComponent(thisFirmware.filename)

			if ((thisFirmwareIndex == 0) && thisFirmware.signed) {
				if (!uniqueFirmwares[thisFirmwareFileName]) {
					uniqueFirmwares[thisFirmwareFileName] = {}

					uniqueFirmwares[thisFirmwareFileName].url = thisFirmware.url
					uniqueFirmwares[thisFirmwareFileName].size = thisFirmware.size
					uniqueFirmwares[thisFirmwareFileName].sha1sum = thisFirmware.sha1sum
					uniqueFirmwares[thisFirmwareFileName].version = thisFirmware.version
				}

				if (!uniqueFirmwares[thisFirmwareFileName].modelIdentifiers)
					uniqueFirmwares[thisFirmwareFileName].modelIdentifiers = []
				uniqueFirmwares[thisFirmwareFileName].modelIdentifiers.push(thisModelID)
				uniqueFirmwares[thisFirmwareFileName].modelIdentifiers.sort()

				if (!uniqueFirmwares[thisFirmwareFileName].deviceNames)
					uniqueFirmwares[thisFirmwareFileName].deviceNames = []
				if (!uniqueFirmwares[thisFirmwareFileName].deviceNames.includes(thisDeviceObject.name)) {
					uniqueFirmwares[thisFirmwareFileName].deviceNames.push(thisDeviceObject.name)
					uniqueFirmwares[thisFirmwareFileName].deviceNames.sort()
				}

				if (!uniqueFirmwares[thisFirmwareFileName].baseDeviceNames)
					uniqueFirmwares[thisFirmwareFileName].baseDeviceNames = []
				let deviceNameParts = thisDeviceObject.name.split(' (')
				if (deviceNameParts.length == 1) deviceNameParts = thisDeviceObject.name.split(',')
				const baseDeviceName = deviceNameParts[0]
				if (!uniqueFirmwares[thisFirmwareFileName].baseDeviceNames.includes(baseDeviceName))
					uniqueFirmwares[thisFirmwareFileName].baseDeviceNames.push(baseDeviceName)
				uniqueFirmwares[thisFirmwareFileName].baseDeviceNames.sort()
			} else if (!thisFirmware.signed && !unsignedFirmwares.includes(thisFirmwareFileName))
				unsignedFirmwares.push(thisFirmwareFileName)
		}
	}

	for (const thisFirmwareFileName in uniqueFirmwares) {
		let thisDisplayDeviceNames = ((uniqueFirmwares[thisFirmwareFileName].deviceNames.length == 1) ? uniqueFirmwares[thisFirmwareFileName].deviceNames[0] : uniqueFirmwares[thisFirmwareFileName].baseDeviceNames.join(', '))
		for (const thatFirmwareFileName in uniqueFirmwares)
			if (thisFirmwareFileName != thatFirmwareFileName) {
				const thatDisplayDeviceNames = uniqueFirmwares[thatFirmwareFileName].baseDeviceNames.join(', ')
				if ((thisDisplayDeviceNames == ((uniqueFirmwares[thatFirmwareFileName].deviceNames.length == 1) ? uniqueFirmwares[thatFirmwareFileName].deviceNames[0] : thatDisplayDeviceNames)) || (thisDisplayDeviceNames == thatDisplayDeviceNames)) {
					thisDisplayDeviceNames = uniqueFirmwares[thisFirmwareFileName].deviceNames.join(', ')
					break
				}
			}

		if (thisDisplayDeviceNames == 'iBridge2') thisDisplayDeviceNames = 'iBridge (for T2 Macs)'

		uniqueFirmwares[thisFirmwareFileName].displayDeviceNames = thisDisplayDeviceNames
		uniqueDeviceNamesForFirmwareFileNames[thisDisplayDeviceNames] = thisFirmwareFileName

		uniqueFirmwares[thisFirmwareFileName].productType = 'Unknown'
		uniqueFirmwares[thisFirmwareFileName].productSoftwareUpdatesFolder = 'Unknown Software Updates'

		for (const thisProductType of everyProductType)
			if (thisDisplayDeviceNames.includes(thisProductType) || (thisDisplayDeviceNames.startsWith('iBridge') && thisProductType.includes('iBridge')) || (thisDisplayDeviceNames.includes('Mac') && thisProductType.includes('Silicon'))) {
				uniqueFirmwares[thisFirmwareFileName].productType = thisProductType

				const thisProductSoftwareUpdatesFolder = ((thisProductType.startsWith('iP')) ? `${libraryITunesFolder}/${thisProductType.replace(' touch', '')} Software Updates` : appleConfiguratorFirmwareFolder)
				uniqueFirmwares[thisFirmwareFileName].productSoftwareUpdatesFolder = thisProductSoftwareUpdatesFolder

				if (fileManager.fileExistsAtPath(`${thisProductSoftwareUpdatesFolder}/${thisFirmwareFileName}`))
					newManagedFirmware[thisFirmwareFileName] = thisDisplayDeviceNames

				break
			}
	}
} catch (parseFirmwaresError) {
	debugLog('Error Parsing Firmwares', parseFirmwaresError)

	unsignedFirmwares = []
	uniqueFirmwares = {}

	newManagedFirmware = {}
	uniqueDeviceNamesForFirmwareFileNames = {}
}

//debugDialog(uniqueFirmwares)
//debugDialog(unsignedFirmwares)

let oldManagedFirmware = getPreference('ManagedFirmwares', 'dict')
if ((typeof oldManagedFirmware !== 'object') || Array.isArray(oldManagedFirmware))
	oldManagedFirmware = {}

const sortedUniqueDeviceNames = Object.keys(uniqueDeviceNamesForFirmwareFileNames).sort()
const sortedUniqueFirmwareFileNames = Object.keys(uniqueFirmwares).sort()
const uniqueFirmwaresCount = sortedUniqueFirmwareFileNames.length
const excludedProducts = getPreference('ExcludeProducts', 'string array') // This returned excluded product will always be sanitized to a valid value by "getPreference()".
const includedVersions = getPreference('IncludeVersions', 'int') // This returned version will always be sanitized to a valid value by "getPreference()".
let firmwaresNeedingUpdate = {}
let totalFirmwaresToUpdateSize = 0

if (uniqueFirmwaresCount > 0) {
	try {
		wakeMacUp()

		Progress.completedUnitCount = 0
		Progress.totalUnitCount = uniqueFirmwaresCount
		Progress.description = `âš–ï¸	Verifying IPSW Firmware Files & Checking for Updates`
		Progress.additionalDescription = `
ðŸ” Checking 0 of ${uniqueFirmwaresCount}: Preparing to Check IPSW Firmware Filesâ€¦

ðŸ“² 0 Available Updates Found for IPSW Firmware Files So Farâ€¦`

		// @ts-ignore: JXA
		delay(0.25)

		setProgressStopButtonEnabled(true)

		for (let firmwareIndex = 0; firmwareIndex < uniqueFirmwaresCount; firmwareIndex ++) {
			const thisFirmwareFileName = ((uniqueFirmwaresCount == sortedUniqueDeviceNames.length) ? uniqueDeviceNamesForFirmwareFileNames[sortedUniqueDeviceNames[firmwareIndex]] : sortedUniqueFirmwareFileNames[firmwareIndex])
			Progress.completedUnitCount ++

			const firmwaresNeedingUpdateSoFarCount = Object.keys(firmwaresNeedingUpdate).length

			Progress.additionalDescription = `
ï¸ðŸ” Checking ${Progress.completedUnitCount} of ${uniqueFirmwaresCount}: ${uniqueFirmwares[thisFirmwareFileName].displayDeviceNames}

ðŸ“² ${firmwaresNeedingUpdateSoFarCount} Available Update${((firmwaresNeedingUpdateSoFarCount == 1) ? '' : 's')} Found for IPSW Firmware Files So Farâ€¦`

			const thisProductType = uniqueFirmwares[thisFirmwareFileName].productType
			if (thisProductType != 'Unknown' && !excludedProducts.includes(thisProductType) &&
				// @ts-ignore: JXA-ObjC
				(thisProductType.includes('HomePod') || thisProductType.includes('Mac') || ($(uniqueFirmwares[thisFirmwareFileName].version).compareOptions(includedVersions.toString(), $.NSNumericSearch) >= 0)) &&
				(uniqueFirmwares[thisFirmwareFileName].sha1sum != calculateChecksumForFile(`${uniqueFirmwares[thisFirmwareFileName].productSoftwareUpdatesFolder}/${thisFirmwareFileName}`))) {
					firmwaresNeedingUpdate[thisFirmwareFileName] = uniqueFirmwares[thisFirmwareFileName]
					totalFirmwaresToUpdateSize += firmwaresNeedingUpdate[thisFirmwareFileName].size
			}

			// @ts-ignore: JXA
			delay(0.1)
		}

		setProgressStopButtonEnabled(false)
	} catch (verifyFirmwareAndCheckForUpdatesError) {
		setProgressStopButtonEnabled(false)

		debugLog('Error Verifying Firmware & Checking for Updates', verifyFirmwareAndCheckForUpdatesError)

		if (verifyFirmwareAndCheckForUpdatesError.errorNumber === -128) {
			userDidCancel = true
			firmwaresNeedingUpdate = {}
		}
	}

	Progress.completedUnitCount = uniqueFirmwaresCount
}

setProgressStopButtonEnabled(false)

//debugDialog(firmwaresNeedingUpdate)

const trashedOutdatedFiles = {}
const downloadedFiles = {}
let totalDownloadedSize = 0
const firmwaresNeedingUpdateCount = Object.keys(firmwaresNeedingUpdate).length
let actualProgressCount = 0
let skippedCount = 0

if (allFirmwareInfo.devices && !userDidCancel) {
	setPreference('LastFirmwareUpdateCheck', startDate, 'date')
	setPreference('FirmwareUpdatesAvailable', firmwaresNeedingUpdateCount, 'int')
	if (firmwaresNeedingUpdateCount > 0) setProgressStopButtonToSkip()
}

if (firmwaresNeedingUpdateCount > 0) {
	Progress.completedUnitCount = 0
	Progress.totalUnitCount = (totalFirmwaresToUpdateSize / 100)
}

for (const thisFirmwareFileName in firmwaresNeedingUpdate)
	try {
		setProgressStopButtonEnabled(false)

		if (curlPIDs.length > 0) try { app.doShellScript(`kill ${curlPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }

		actualProgressCount ++
		const progressBeforeDownload = Progress.completedUnitCount

		const thisDisplayDeviceNames = firmwaresNeedingUpdate[thisFirmwareFileName].displayDeviceNames
		const iTunesSoftwareUpdatesFilePath = `${firmwaresNeedingUpdate[thisFirmwareFileName].productSoftwareUpdatesFolder}/${thisFirmwareFileName}`

		wakeMacUp()

		Progress.description = `${actualProgressCount} of ${firmwaresNeedingUpdateCount}: ${thisDisplayDeviceNames}`
		Progress.additionalDescription = `
ðŸ“² Downloading: ${((thisFirmwareFileName.length > 81) ? `${thisFirmwareFileName.slice(0, 40)}â€¦${thisFirmwareFileName.slice(thisFirmwareFileName.length - 40)}` : thisFirmwareFileName)}

ðŸ”„ Initializing ${formatBytes(firmwaresNeedingUpdate[thisFirmwareFileName].size)} Downloadâ€¦`

		// @ts-ignore: JXA
		delay(0.1)

		setProgressStopButtonEnabled(true)

		if (firmwaresNeedingUpdate[thisFirmwareFileName].sha1sum != calculateChecksumForFile(iTunesSoftwareUpdatesFilePath)) {
			const downloadFirmwareFilePath = `${temporaryFilesFolder}/${thisFirmwareFileName}-download`
			firmwareProgressOutputFile = `${temporaryFilesFolder}/${thisFirmwareFileName}-progress`

			let maxDownloadAttempts = 2
			for (let downloadAttempt = 1; downloadAttempt <= maxDownloadAttempts; downloadAttempt ++) {
				setProgressStopButtonEnabled(true)

				Progress.completedUnitCount = progressBeforeDownload

				try {
					let hasFreeSpaceToDownloadFile = true

					try {
						// "NSURLVolumeAvailableCapacityForImportantUsageKey" is the *real* free space to check and should always be available, but still get "NSURLVolumeAvailableCapacityKey" as a fallback since I have seen
						// that "NSURLVolumeAvailableCapacityForImportantUsageKey" can return "0" when run when no users are logged in or when run as another user (even though that should never be the case for a GUI app like this).
						// NOTE: The "$.NSURLVolumeAvailableCapacityForImportantUsageKey" and "$.NSURLVolumeAvailableCapacityKey" constants are not bridged in JXA on macOS 10.13 High Sierra (but are bridged on macOS 10.14 Mojave and newer), so use the string values instead which work on all versions of macOS.

						// @ts-ignore: JXA-ObjC
						const availableCapacities = ObjC.deepUnwrap($.NSURL.fileURLWithPath(temporaryFilesFolder).resourceValuesForKeysError(['NSURLVolumeAvailableCapacityForImportantUsageKey', 'NSURLVolumeAvailableCapacityKey'], $()))
						const freeSpaceWithPadding = ((availableCapacities.NSURLVolumeAvailableCapacityForImportantUsageKey || availableCapacities.NSURLVolumeAvailableCapacityKey) - 10000000000) // Always leave at least 10 GB available on the system.
						hasFreeSpaceToDownloadFile = (freeSpaceWithPadding >= firmwaresNeedingUpdate[thisFirmwareFileName].size)
					} catch (ignoredError) {
						hasFreeSpaceToDownloadFile = true
					}

					if (hasFreeSpaceToDownloadFile) {
						try {
							if (curlPIDs.length > 0) try { app.doShellScript(`kill ${curlPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }

							const downloadFirmwarePID = app.doShellScript(`/usr/bin/curl --connect-timeout 5 -L ${quoteForShell(firmwaresNeedingUpdate[thisFirmwareFileName].url)} -o ${quoteForShell(downloadFirmwareFilePath)} > ${quoteForShell(firmwareProgressOutputFile)} 2>&1 & echo $!`)
							curlPIDs.push(downloadFirmwarePID)
							debugLog(`Download ${thisFirmwareFileName} CURL PID`, downloadFirmwarePID)

							try { app.doShellScript(`/usr/bin/caffeinate -dimsu -w ${downloadFirmwarePID} > /dev/null 2>&1 &`) } catch (ignoredError) { /* Ignore */ } // Prevent this Mac from Sleeping while CURL is running.

							// @ts-ignore: JXA
							delay(1)

							for (let delaySeconds = 0; delaySeconds < 5; delaySeconds ++)
								if (!fileManager.fileExistsAtPath(firmwareProgressOutputFile))
									// @ts-ignore: JXA
									delay(1)
								else
									break

							let tickTock = true
							while (app.doShellScript(`/bin/ps -p ${downloadFirmwarePID} > /dev/null 2>&1; echo $?`) == 0) {
								let rawProgressSpeed = '0'
								try {
									// @ts-ignore: JXA-ObjC
									rawProgressSpeed = $.NSString.stringWithContentsOfFileEncodingError(firmwareProgressOutputFile, $.NSUTF8StringEncoding, $()).js.split(/\n|\r/).slice(-1)[0].split(' ').slice(-1)[0]
								} catch (readProgressError) {
									if (readProgressError.errorNumber === -128)
										throw readProgressError
								}

								let downloadedFileSize = 0
								try {
									if (fileManager.fileExistsAtPath(downloadFirmwareFilePath))
										// @ts-ignore: JXA-ObjC
										downloadedFileSize = fileManager.attributesOfItemAtPathError(downloadFirmwareFilePath, $()).objectForKey('NSFileSize').js
								} catch (downloadedFileSizeError) {
									if (downloadedFileSizeError.errorNumber === -128)
										throw downloadedFileSizeError
								}

								let progressSpeedNumber = 0
								const lastSpeedChar = rawProgressSpeed.charAt(rawProgressSpeed.length - 1)
								if (lastSpeedChar == 'k') {
									rawProgressSpeed.slice(-1)
									progressSpeedNumber = (parseInt(rawProgressSpeed) * 1000)
								} else if (lastSpeedChar == 'M') {
									rawProgressSpeed.slice(-1)
									progressSpeedNumber = (parseFloat(rawProgressSpeed) * 1000000)
								} else
									progressSpeedNumber = parseInt(rawProgressSpeed)

								if (isNaN(progressSpeedNumber)) progressSpeedNumber = 0
								const progressSpeedString = `${formatBytes(progressSpeedNumber, 1)}/sec`
								Progress.completedUnitCount = (progressBeforeDownload + (downloadedFileSize / 100))
								const hourGlass = (tickTock ? 'â³' : 'âŒ›ï¸')
								tickTock = !tickTock

								const progressPercentage = ((downloadedFileSize / firmwaresNeedingUpdate[thisFirmwareFileName].size) * 100).toFixed(1).replace('.0', '')

								Progress.additionalDescription = `
ðŸ“² Downloading: ${((thisFirmwareFileName.length > 81) ? `${thisFirmwareFileName.slice(0, 40)}â€¦${thisFirmwareFileName.slice(thisFirmwareFileName.length - 40)}` : thisFirmwareFileName)}

${hourGlass} ${progressPercentage}% Downloaded: ${formatBytes(downloadedFileSize)} of ${formatBytes(firmwaresNeedingUpdate[thisFirmwareFileName].size)} @ ${progressSpeedString}`
								// @ts-ignore: JXA
								delay(1)
							}
						} catch (waitingForDownloadError) {
							setProgressStopButtonEnabled(false)

							debugLog('Waiting for Download Error', waitingForDownloadError)

							if (curlPIDs.length > 0) try { app.doShellScript(`kill ${curlPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }

							throw waitingForDownloadError
						}

						let downloadedFileSize = 0
						try {
							if (fileManager.fileExistsAtPath(downloadFirmwareFilePath))
								// @ts-ignore: JXA-ObjC
								downloadedFileSize = fileManager.attributesOfItemAtPathError(downloadFirmwareFilePath, $()).objectForKey('NSFileSize').js
						} catch (ignoredError) { /* Ignore */ }

						if (downloadedFileSize > 0) {
							setProgressStopButtonEnabled(false)

							Progress.completedUnitCount = progressBeforeDownload + (downloadedFileSize / 100)
							totalDownloadedSize += downloadedFileSize

							Progress.additionalDescription = `
ðŸ“² Downloaded: ${((thisFirmwareFileName.length > 81) ? `${thisFirmwareFileName.slice(0, 40)}â€¦${thisFirmwareFileName.slice(thisFirmwareFileName.length - 40)}` : thisFirmwareFileName)}

ðŸ” Verifying and Moving IPSW Firmware Fileâ€¦`
							// @ts-ignore: JXA
							delay(0.25)

							const downloadedFileSHA1Sum = calculateChecksumForFile(downloadFirmwareFilePath)

							if (firmwaresNeedingUpdate[thisFirmwareFileName].sha1sum == downloadedFileSHA1Sum) {
								const thisProductSoftwareUpdatesFolder = firmwaresNeedingUpdate[thisFirmwareFileName].productSoftwareUpdatesFolder

								if (fileManager.fileExistsAtPath(iTunesSoftwareUpdatesFilePath))
									// @ts-ignore: JXA-ObjC
									try { fileManager.removeItemAtPathError(iTunesSoftwareUpdatesFilePath, $()) } catch (ignoredError) { /* Ignore */ }
								else if (!fileManager.fileExistsAtPath(thisProductSoftwareUpdatesFolder))
									// @ts-ignore: JXA-ObjC
									fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(thisProductSoftwareUpdatesFolder, true, {}, $())

								// @ts-ignore: JXA-ObjC
								try { fileManager.moveItemAtPathToPathError(downloadFirmwareFilePath, iTunesSoftwareUpdatesFilePath, $()) } catch (ignoredError) { /* Ignore */ }

								downloadedFiles[thisFirmwareFileName] = {
									Devices: thisDisplayDeviceNames,
									Version: firmwaresNeedingUpdate[thisFirmwareFileName].version,
									Size: formatBytes(downloadedFileSize)
								}

								break
							} else
								throw new Error(`Downloaded File Checksum (${downloadedFileSHA1Sum}) != Intended Checksum (${firmwaresNeedingUpdate[thisFirmwareFileName].sha1sum})`)
						} else
							throw new Error(`No File Downloaded`)
					} else {
						maxDownloadAttempts = 1
						throw new Error(`Not Enough Free Space to Download ${formatBytes(firmwaresNeedingUpdate[thisFirmwareFileName].size)} IPSW Firmware File`)
					}
				} catch (firmwareDownloadError) {
					setProgressStopButtonEnabled(false)

					if (curlPIDs.length > 0) try { app.doShellScript(`kill ${curlPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }

					if (!userDidCancel) userDidCancel = (firmwareDownloadError.errorNumber === -128)

					let firmwareDownloadErrorMessage = firmwareDownloadError.message

					try {
						// @ts-ignore: JXA-ObjC
						const progressOutputParts = $.NSString.stringWithContentsOfFileEncodingError(firmwareProgressOutputFile, $.NSUTF8StringEncoding, $()).js.split('curl: ')
						if (progressOutputParts.length > 1)
							firmwareDownloadErrorMessage = `CURL Error: ${progressOutputParts.slice(-1)[0].trim()}`
					} catch (ignoredError) { /* Ignore */ }

					firmwareDownloadErrorMessage = firmwareDownloadErrorMessage.replace(/\n|\r/g, '')

					// @ts-ignore: JXA-ObjC
					try { fileManager.removeItemAtPathError(downloadFirmwareFilePath, $()) } catch (ignoredError) { /* Ignore */ }

					debugLog(`Error Downloading Firmware (${thisFirmwareFileName}) Attempt ${downloadAttempt} of ${maxDownloadAttempts}: ${firmwareDownloadErrorMessage}`, firmwareDownloadError)

					if (userDidCancel) break // Break before errors get saved in Updates Log when user canceled.

					if (!downloadErrors[thisFirmwareFileName]) downloadErrors[thisFirmwareFileName] = {}
					downloadErrors[thisFirmwareFileName][`Attempt ${downloadAttempt} of ${maxDownloadAttempts}`] = firmwareDownloadErrorMessage
				}
			}

			// @ts-ignore: JXA-ObjC
			try { fileManager.removeItemAtPathError(firmwareProgressOutputFile, $()) } catch (ignoredError) { /* Ignore */ }
		}

		setProgressStopButtonEnabled(false)

		if (firmwaresNeedingUpdate[thisFirmwareFileName].sha1sum == calculateChecksumForFile(iTunesSoftwareUpdatesFilePath)) {
			newManagedFirmware[thisFirmwareFileName] = thisDisplayDeviceNames
			for (const thisOldManagedFirmwareFileName in oldManagedFirmware)
				if ((thisOldManagedFirmwareFileName != thisFirmwareFileName) && (oldManagedFirmware[thisOldManagedFirmwareFileName] == thisDisplayDeviceNames)) {
					const thisOldManagedFirmwarePath = `${firmwaresNeedingUpdate[thisFirmwareFileName].productSoftwareUpdatesFolder}/${thisOldManagedFirmwareFileName}`

					try {
						if (fileManager.fileExistsAtPath(thisOldManagedFirmwarePath)) {
							if (trashOrDeleteOutdatedFirmware(thisOldManagedFirmwarePath))
								trashedOutdatedFiles[thisOldManagedFirmwareFileName] = {
									Devices: thisDisplayDeviceNames,
									Reason: 'Downloaded Update'
								}
						} else if (fileManager.fileExistsAtPath(`${userTrashPath}/${thisOldManagedFirmwareFileName}`)) {
							trashedOutdatedFiles[thisOldManagedFirmwareFileName] = {
								Devices: thisDisplayDeviceNames,
								Reason: 'Downloaded Update (File Already in Trash)'
							}
						}
					} catch (cleanUpAfterDownloadError) {
						debugLog('Clean Up After Download Error', cleanUpAfterDownloadError)

						if (!userDidCancel) userDidCancel = (cleanUpAfterDownloadError.errorNumber === -128)
					}

					break
				}
		}

		Progress.completedUnitCount = progressBeforeDownload + (firmwaresNeedingUpdate[thisFirmwareFileName].size / 100)

		if (userDidCancel) {
			Progress.additionalDescription = `

â­ï¸ Skipped: ${((thisFirmwareFileName.length > 81) ? `${thisFirmwareFileName.slice(0, 40)}â€¦${thisFirmwareFileName.slice(thisFirmwareFileName.length - 40)}` : thisFirmwareFileName)}
`
			throw new Error('Skipped Download Because User Canceled')
		}

		// @ts-ignore: JXA
		delay(0.25)
	} catch (updatingError) {
		setProgressStopButtonEnabled(false)

		debugLog('Updating Error', updatingError)

		if (curlPIDs.length > 0) try { app.doShellScript(`kill ${curlPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }

		if (userDidCancel || (updatingError.errorNumber === -128)) {
			skippedCount ++

			if (firmwaresNeedingUpdateCount > actualProgressCount) {
				try {
					app.activate()
					app.displayAlert('Are you sure you want to skip all remaining updates?',
						{
							message: 'Remaining updates will be skipped in 30 secondsâ€¦',
							as: 'critical',
							buttons: [`Just Skip â€œ${firmwaresNeedingUpdate[thisFirmwareFileName].displayDeviceNames}â€`, 'Skip Remaining Updates'],
							cancelButton: 1,
							defaultButton: 2,
							givingUpAfter: 30
						}
					)

					userDidCancel = true // If gaveUp or defaultButton, then really cancel and skip all.
				} catch (confirmCancelError) {
					if (confirmCancelError.errorNumber === -128) // This time, -128 is the user selecting "cancelButton" which is choosing to just skip one, not all.
						userDidCancel = false // So, undo previously set "userDidCancel" to keep going after just skipping one.
					else
						debugLog('Confirm Cancel Error', updatingError)
				}

				if (userDidCancel) {
					skippedCount += (firmwaresNeedingUpdateCount - actualProgressCount)
					Progress.additionalDescription = `

â­ï¸ Skipped Remaining Updatesâ€¦
`
					break
				}
			} else {
				userDidCancel = true
				break
			}
		}
	}

for ( ; ; ) {
	try {
		if (curlPIDs.length > 0) try { app.doShellScript(`kill ${curlPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }

		setProgressStopButtonEnabled(false)
		setProgressSkipButtonToStop()

		Progress.totalUnitCount = 1
		Progress.completedUnitCount = 1
		// @ts-ignore: JXA
		delay(0.1)

		let isInitialDownloads = false
		const failedToLoadFirmwareInfo = (!allFirmwareInfo.devices && !allFirmwareInfo.iTunes && !userDidCancel)
		const ipswMeUpdatingFirmwareInfo = (!allFirmwareInfo.devices && allFirmwareInfo.iTunes && !userDidCancel) // When new firmwares are released and ipsw.me is updating, the "iTunes" object will exist, but the "devices" object will be null.
		const isUpToDate = (!userDidCancel && (firmwaresNeedingUpdateCount == 0))
		const downloadedFilesCount = Object.keys(downloadedFiles).length
		const downloadErrorsCount = Object.keys(downloadErrors).length
		const failedToDownloadAnyUpdates = (allFirmwareInfo.devices && !userDidCancel && !isUpToDate && (downloadedFilesCount == 0))
		const downloadedAllUpdates = (firmwaresNeedingUpdateCount == downloadedFilesCount)

		setPreference('FirmwareUpdatesAvailable', (firmwaresNeedingUpdateCount - downloadedFilesCount), 'int')

		if (downloadedFilesCount > 0) {
			lastUpdateSummary = ''
			lastErrorSummary = ''

			isInitialDownloads = true

			if (updatesLog.length > 0)
				for (let updateIndex = (updatesLog.length - 1); updateIndex >= 0; updateIndex --) {
					const thisUpdate = updatesLog[updateIndex]
					if (thisUpdate.Status && (thisUpdate.Status.includes('Updated') || thisUpdate.Status.includes('Initial'))) {
						isInitialDownloads = false
						break
					}
				}
		} else if (downloadErrorsCount > 0)
			lastErrorSummary = ''

		wakeMacUp()

		Progress.description = `
ðŸ—‘	Cleaning Up After ${(failedToLoadFirmwareInfo ?
			'Error Loading Firmware Information' :
			(ipswMeUpdatingFirmwareInfo ?
				'Detecting That ipsw.me Is Updating Firmware Info' :
				(failedToDownloadAnyUpdates ?
					'Error Updating Any IPSW Firmware Files' :
					(isUpToDate ?
						'Checking for Updates' :
						(userDidCancel ?
							((skippedCount > 0) ?
								((downloadedFilesCount > 0) ?
									'Updating and Skipping' :
									'Skipping'
								) :
								'Stopping'
							) :
							(isInitialDownloads ?
								'Initial IPSW Firmware Downloads' :
								'Updating IPSW Firmware Files'
							)
						)
					)
				)
			)
		)}`
		Progress.additionalDescription = ''

		// @ts-ignore: JXA
		delay(0.5)

		// @ts-ignore: JXA-ObjC
		try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }

		//debugDialog(newManagedFirmware)

		if (!failedToLoadFirmwareInfo && !ipswMeUpdatingFirmwareInfo) {
			Progress.totalUnitCount = Object.keys(oldManagedFirmware).length + 2
			Progress.completedUnitCount = Progress.totalUnitCount

			const checkedSoftwareUpdatesFolderForUnsignedFirmware = []

			for (const thisProductType of everyProductType)
				if (!excludedProducts.includes(thisProductType)) {
					const thisProductSoftwareUpdatesFolder = ((thisProductType.startsWith('iP')) ? `${libraryITunesFolder}/${thisProductType.replace(' touch', '')} Software Updates` : appleConfiguratorFirmwareFolder)

					if (!checkedSoftwareUpdatesFolderForUnsignedFirmware.includes(thisProductSoftwareUpdatesFolder)) {
						try {
							if (fileManager.fileExistsAtPath(thisProductSoftwareUpdatesFolder)) {
								// @ts-ignore: JXA-ObjC
								for (const thisFirmwareFileNameInSoftwareUpdatesFolder of ObjC.deepUnwrap(fileManager.contentsOfDirectoryAtPathError(thisProductSoftwareUpdatesFolder, $())))
									if (!newManagedFirmware[thisFirmwareFileNameInSoftwareUpdatesFolder] && unsignedFirmwares.includes(thisFirmwareFileNameInSoftwareUpdatesFolder) && trashOrDeleteOutdatedFirmware(`${thisProductSoftwareUpdatesFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`))
										trashedOutdatedFiles[thisFirmwareFileNameInSoftwareUpdatesFolder] = {Reason: 'No Longer Signed by Apple'}
							}

							checkedSoftwareUpdatesFolderForUnsignedFirmware.push(thisProductSoftwareUpdatesFolder)
						} catch (trashUnsignedFirmwareError) {
							debugLog('Trash Unsigned Firmware Error', trashUnsignedFirmwareError)

							if (!userDidCancel) userDidCancel = (trashUnsignedFirmwareError.errorNumber === -128)
						}
					}
				}

			Progress.completedUnitCount --
			// @ts-ignore: JXA
			delay(0.01)

			for (const thisOldManagedFirmwareFileName in oldManagedFirmware) {
				try {
					if (!newManagedFirmware[thisOldManagedFirmwareFileName]) {
						const thisOldManagedFirmwareDisplayDeviceNames = oldManagedFirmware[thisOldManagedFirmwareFileName]

						if (!userDidCancel && downloadedAllUpdates) {
							for (const thisProductType of everyProductType)
								if (thisOldManagedFirmwareDisplayDeviceNames.includes(thisProductType) || (thisOldManagedFirmwareDisplayDeviceNames.startsWith('iBridge') && thisProductType.includes('iBridge')) || (thisOldManagedFirmwareDisplayDeviceNames.includes('Mac') && thisProductType.includes('Silicon'))) {
									const thisOldManagedFirmwarePath = `${((thisProductType.startsWith('iP')) ? `${libraryITunesFolder}/${thisProductType.replace(' touch', '')} Software Updates` : appleConfiguratorFirmwareFolder)}/${thisOldManagedFirmwareFileName}`

									if (fileManager.fileExistsAtPath(thisOldManagedFirmwarePath)) {
										if (excludedProducts.includes(thisProductType))
											newManagedFirmware[thisOldManagedFirmwareFileName] = thisOldManagedFirmwareDisplayDeviceNames
										else if (trashOrDeleteOutdatedFirmware(thisOldManagedFirmwarePath))
											trashedOutdatedFiles[thisOldManagedFirmwareFileName] = {Reason: 'Not Associated with Any Current Device'}
									} else if (!trashedOutdatedFiles[thisOldManagedFirmwareFileName] && fileManager.fileExistsAtPath(`${userTrashPath}/${thisOldManagedFirmwareFileName}`))
										trashedOutdatedFiles[thisOldManagedFirmwareFileName] = {
											Devices: thisOldManagedFirmwareDisplayDeviceNames,
											Reason: 'Not Associated with Any Current Device (File Already in Trash)'
										}

									break
								}
						} else
							newManagedFirmware[thisOldManagedFirmwareFileName] = thisOldManagedFirmwareDisplayDeviceNames
					}
				} catch (cleanUpAfterUpdateError) {
					debugLog('Clean Up After Update Error', cleanUpAfterUpdateError)

					if (!userDidCancel) userDidCancel = (cleanUpAfterUpdateError.errorNumber === -128)
				}

				Progress.completedUnitCount --
				// @ts-ignore: JXA
				delay(0.01)
			}

			if (JSON.stringify(oldManagedFirmware) != JSON.stringify(newManagedFirmware))
				setPreference('ManagedFirmwares', newManagedFirmware, 'dict')

			Progress.completedUnitCount = 0
		}

		const trashedOutdatedFilesCount = Object.keys(trashedOutdatedFiles).length

		const endDate = new Date()

		const logStatus = `${(failedToLoadFirmwareInfo ?
			'Load Error' :
			(ipswMeUpdatingFirmwareInfo ?
				'ipsw.me Updating Firmware Info' :
				(failedToDownloadAnyUpdates ?
					'Update Error' :
					(isUpToDate ?
						'Up-to-Date' :
						(userDidCancel ?
							((skippedCount > 0) ?
								((downloadedFilesCount > 0) ?
									'Updated + Skipped' :
									'Skipped'
								) :
								'Stopped'
							) :
							(isInitialDownloads ?
								'Initial Downloads' :
								'Updated'
							)
						)
					)
				)
			)
		)}${((!failedToLoadFirmwareInfo && !ipswMeUpdatingFirmwareInfo && !failedToDownloadAnyUpdates && (downloadErrorsCount > 0)) ? ' + Errors' : '')}`

		debugLog('Finished Checking for IPSW Firmware Updates', logStatus)

		const startDateDisplay = `${startDate.toLocaleDateString('en-US', dateFormatOptions)} @ ${startDate.toLocaleTimeString('en-US')}`

		let updatedUpdatesLog = false
		if ((downloadedFilesCount > 0) || (downloadErrorsCount > 0) || (trashedOutdatedFilesCount > 0)) {
			if ((downloadedFilesCount > 0) || (downloadErrorsCount > 0))
				setPreference('AcknowledgedSignificantResults', false, 'bool')

			updatesLog.unshift({
				Status: logStatus,
				Times: {
					Start: startDateDisplay,
					End: `${endDate.toLocaleDateString('en-US', dateFormatOptions)} @ ${endDate.toLocaleTimeString('en-US')}`,
					Duration: durationConversion(endDate.getTime() - startDate.getTime())
				},
				Downloaded: {
					'Total Size': formatBytes(totalDownloadedSize),
					Files: downloadedFiles,
					Skipped: skippedCount
				},
				Trashed: {
					'Outdated Files': trashedOutdatedFiles
				},
				Errors: downloadErrors
			})

			updatedUpdatesLog = true

			//debugDialog(updatesLog)

			try {
				// @ts-ignore: JXA-ObjC
				const writeUpdateLogFileError = $()
				// @ts-ignore: JXA-ObjC
				if (!$(JSON.stringify(updatesLog, null, 4)).writeToFileAtomicallyEncodingError(updatesLogPath, true, $.NSUTF8StringEncoding, writeUpdateLogFileError)) { // NOTE: NOT using "$.NSString.alloc.initWithDataEncoding($.NSJSONSerialization.dataWithJSONObjectOptionsError(...), ...).writeToFileAtomicallyEncodingError(...)" to write this JSON to the file since it alters the order of the keys within dicts, which should be preserved since it's the desired dispay order of this human readable "Updates Log.json" file.
					if (!writeUpdateLogFileError.isNil()) throw new Error(writeUpdateLogFileError.description.js)
					throw new Error('Write Updates Log JSON Failed')
				}
			} catch (writeUpdatedLogError) {
				debugLog('Write "Updates Log.json" Error', writeUpdatedLogError)
			}
		}

		wakeMacUp()

		let dialogTimedOutEarly = false
		do {
			try {
				let trashedFilesDisplay = ''
				if (trashedOutdatedFilesCount > 0) {
					trashedFilesDisplay = `

ðŸ—‘ ${shouldImmediatelyDeleteOutdatedFirmwares ? 'Deleted' : 'Trashed'} ${trashedOutdatedFilesCount} Outdated IPSW File${((trashedOutdatedFilesCount == 1) ? '' : 's')}${shouldImmediatelyDeleteOutdatedFirmwares ? '' : `
	ðŸ‘‰ â€œEmpty Trashâ€ in Finder to Delete File${((trashedOutdatedFilesCount == 1) ? '' : 's')}`}`
				}

				let downloadErrorsDisplay = ''
				if (!failedToLoadFirmwareInfo && !ipswMeUpdatingFirmwareInfo && (downloadErrorsCount > 0))
					downloadErrorsDisplay = `

âš ï¸ ${downloadErrorsCount} Download Error${((downloadErrorsCount == 1) ? '' : 's')} Occurred`

				const appUpdateAvailable = getPreference('AppUpdateAvailable', 'bool')
				const resultsDialogButtons = [(appUpdateAvailable ? 'Update Appâ€¦' : 'Quit')]

				let openUpdatesLogDisplay = ''
				if ((updatedUpdatesLog && !failedToLoadFirmwareInfo && !ipswMeUpdatingFirmwareInfo) || lastUpdateSummary || lastErrorSummary) {
					resultsDialogButtons.unshift('View â€œUpdates Logâ€ File')
					openUpdatesLogDisplay = `

ðŸ“ View the â€œUpdates Logâ€ file for full details.`
				}

				if (failedToLoadFirmwareInfo || ipswMeUpdatingFirmwareInfo)
					resultsDialogButtons.unshift('Visit ipsw.me')

				while (resultsDialogButtons.length > 3)
					resultsDialogButtons.shift()

				const autoLaunchSchedule = parseLaunchAgentSchedule()
				const didAcknowledgeSignificantResultsAndUpToDate = (getPreference('AcknowledgedSignificantResults', 'bool') && !appUpdateAvailable)

				const nowDate = new Date()

				let giveUpDate = new Date(nowDate)
				if (didAcknowledgeSignificantResultsAndUpToDate)
					giveUpDate.setMinutes(giveUpDate.getMinutes() + 30)
				else
					giveUpDate.setMonth(giveUpDate.getMonth() + 1)

				if (autoLaunchSchedule.days.length > 0) {
					const everyDayOfTheWeekStartingWithSunday = everyDayOfTheWeek.slice(-1).concat(everyDayOfTheWeek.slice(0, -1))

					const todayIndex = nowDate.getDay()
					const thisDayOfWeek = everyDayOfTheWeekStartingWithSunday[todayIndex]

					let nextAutoLaunchDayIndex = -1

					for (const autoLaunchDayOfWeek of autoLaunchSchedule.days) {
						let autoLaunchDayIndex = everyDayOfTheWeekStartingWithSunday.indexOf(autoLaunchDayOfWeek)

						if (autoLaunchDayIndex > todayIndex) {
							nextAutoLaunchDayIndex = autoLaunchDayIndex
							break
						} else if ((nextAutoLaunchDayIndex == -1) || (autoLaunchDayIndex < nextAutoLaunchDayIndex))
							nextAutoLaunchDayIndex = autoLaunchDayIndex
					}

					if (nextAutoLaunchDayIndex > -1) {
						const daysUntilNextAutoLaunchDay = ((nextAutoLaunchDayIndex < todayIndex) ? (7 - todayIndex + nextAutoLaunchDayIndex) : (nextAutoLaunchDayIndex - todayIndex))

						const autoLaunchGiveUpDate = new Date(nowDate.getFullYear(), nowDate.getMonth(), (nowDate.getDate() + (((nowDate.getHours() < autoLaunchSchedule.hour) && autoLaunchSchedule.days.includes(thisDayOfWeek)) ? 0 : daysUntilNextAutoLaunchDay)), autoLaunchSchedule.hour, autoLaunchSchedule.minute - 10)

						if (autoLaunchGiveUpDate.getTime() < giveUpDate.getTime())
							giveUpDate = autoLaunchGiveUpDate
					}
				}

				let giveUpAfterSeconds = -1

				const resultsSummary = (failedToLoadFirmwareInfo ?
					`âŒ Error Loading IPSW Firmware Information

âš ï¸ ${globalGetFirmwaresErrorMessage}

ðŸš« ipsw.me is down or you're not connected to the internet.` :
					(ipswMeUpdatingFirmwareInfo ?
						`ðŸ”„ ipsw.me Is Currently Updating Firmware Information

â±ï¸ This may take a few hours, please try again later today.` :
						`${(failedToDownloadAnyUpdates ?
							`âŒ Error Updating ${firmwaresNeedingUpdateCount} IPSW Firmware File${((firmwaresNeedingUpdateCount == 1) ? '' : 's')}` :
							(isUpToDate ?
								`ðŸ‘ All IPSW Firmware Files are Up-to-Date as of
ðŸ—“ ${startDateDisplay}` :
								((downloadedFilesCount > 0) ?
									`âœ… ${(isInitialDownloads ? 'Initial Download of' : 'Updated')} ${downloadedFilesCount} IPSW File${((downloadedFilesCount == 1) ? '' : 's')} (${formatBytes(totalDownloadedSize)})` :
									((userDidCancel && (skippedCount == 0)) ? 'ðŸ›‘ Stopped' : '')
								)
							)
						)}${createVersionsDownloadedSummary(downloadedFiles)}${((userDidCancel && (skippedCount > 0)) ? `${(downloadedFilesCount > 0) ? `

` : ''}â­ï¸ Skipped ${skippedCount} Update${((skippedCount == 1) ? '' : 's')}` : '')}${downloadErrorsDisplay}

â±ï¸ Finished in ${durationConversion(endDate.getTime() - startDate.getTime())}.${trashedFilesDisplay}`
					)
				)

				for ( ; ; ) {
					giveUpAfterSeconds = Math.round((giveUpDate.getTime() - new Date().getTime()) / 1000)

					if (giveUpAfterSeconds <= 0) {
						debugLog(`Auto-Quitting: Hit Give Up Time BEFORE Showing ${didAcknowledgeSignificantResultsAndUpToDate ? 'Insignificant' : 'Significant'} Results`)
						cleanUpAndQuitEarly()
					}

					if (!macIsAwakeAndUnlocked()) { // AppleScript dialogs will timeout early if Mac is asleep when it's displayed, but progress can be displayed properly. So, wait until Mac is awake to display the dialog.
						if (Progress.description != resultsSummary) {
							Progress.description = resultsSummary
							Progress.additionalDescription = `
ðŸ’¤ Waiting until Mac wakes up to show full resultsâ€¦`
							Progress.completedUnitCount = 0
							Progress.totalUnitCount = -1

							if (isBigSurOrNewer && progressWindow) {
								// There is a bug in Big Sur where setting indeterminate progress AFTER determinate progress has been shown just displays 0 progress.
								// To workaround this, startAnimation on the NSProgressIndicator directly.

								for (const thisSubview of progressWindow.contentView.subviews.js)
									// @ts-ignore: JXA-ObjC
									if ($.NSStringFromClass(thisSubview.class).js == 'NSProgressIndicator') {
										thisSubview.startAnimation(thisSubview)
										break
									}
							}
						}

						// @ts-ignore: JXA
						delay(15)
					} else
						break
				}

				if (failedToLoadFirmwareInfo || ipswMeUpdatingFirmwareInfo || failedToDownloadAnyUpdates || userDidCancel || !isUpToDate) {
					try {
						// @ts-ignore: JXA-ObjC
						$.NSSound.soundNamed((failedToLoadFirmwareInfo || ipswMeUpdatingFirmwareInfo || failedToDownloadAnyUpdates || userDidCancel) ? 'Basso' : 'Glass').play
					} catch (ignoredError) {
						app.beep()
					}
				}

				dialogTimedOutEarly = false

				closeProgressWindow()

				debugLog(`Showing ${didAcknowledgeSignificantResultsAndUpToDate ? 'Insignificant' : 'Significant'} Results with Give Up Seconds`, giveUpAfterSeconds)

				app.activate()

				const fullResultsSummary = `${lastErrorSummary}${lastUpdateSummary}${openUpdatesLogDisplay}${(appUpdateAvailable ? `

â¤´ï¸ An App Update is Available!` : '')}`

				const resultsDialogReply = app.displayDialog(`${resultsSummary}${fullResultsSummary ? `
${fullResultsSummary}` : ''}`,
					{
						withTitle: `${appName}  â€”  ${logStatus}`,
						withIcon: ((failedToLoadFirmwareInfo || ipswMeUpdatingFirmwareInfo || failedToDownloadAnyUpdates) ? 'caution' : 'note'),
						buttons: resultsDialogButtons,
						// Decided cancelButton is not wanted here and would also be more complex because dialog could be displayed with only a single button.
						defaultButton: resultsDialogButtons.length,
						givingUpAfter: giveUpAfterSeconds
					},
					{timeout: (giveUpAfterSeconds + 30)}
				) // Set dialog to timeout after give up time, but it will still timeout early if Mac is asleep when it's displayed.

				if (resultsDialogReply.gaveUp)
					debugLog(`Auto-Quitting: Hit Give Up Time WHILE Showing ${didAcknowledgeSignificantResultsAndUpToDate ? 'Insignificant' : 'Significant'} Results`)
				else {
					setPreference('AcknowledgedSignificantResults', true, 'bool')

					if (resultsDialogReply.buttonReturned == 'View â€œUpdates Logâ€ File')
						// @ts-ignore: JXA-ObjC
						sharedWorkspace.openURL($.NSURL.fileURLWithPath(updatesLogPath))
					else if (resultsDialogReply.buttonReturned == 'Visit ipsw.me')
						// @ts-ignore: JXA-ObjC
						sharedWorkspace.openURL($.NSURL.URLWithString('https://ipsw.me'))
				}
			} catch (displayResultsError) {
				debugLog('Display Results Error', displayResultsError)
				if (displayResultsError.errorNumber === -1712) { // https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_error_codes.html#//apple_ref/doc/uid/TP40000983-CH220-SW6
					dialogTimedOutEarly = true
					// @ts-ignore: JXA
					delay(15)
				}
			}
		} while (dialogTimedOutEarly)

		break
	} catch (showResultsError) {
		if (showResultsError.errorNumber !== -128)
			break
	}
}

if (getPreference('AppUpdateAvailable', 'bool'))
	checkAndInstallAppUpdates()

function displayAlertOrDialogDependingOnOS(titleText, messageText, windowTitle, icon, buttons, cancelButton, defaultButton, givingUpAfter) {
	// On macOS 10.15 Catalina and older, the alert window size is very similar to the dialog window size in that is it wide with left aligned text and look good for the long detailed messages displayed by IPSW Updater.
	// On macOS 11 Big Sur and macOS 12 Monterey, alerts will only ever be a "compact" layout with a narrow window and centered text (and long text could need to be scrolled).
	// This style looks very bad for the long detailed messages displayed by IPSW Updater, so a dialog will be used instead on those versions of macOS.
	// On macOS 13 Ventura, alerts with long text will be displayed in a new "expanded" layout with a wide and tall window (https://developer.apple.com/videos/play/wwdc2022/10074/?time=728)
	// which is similar to the older macOS 10.15 Catalina and older alert style and doesn't have centered text (and is not scrollable).
	// macOS 13 Ventura will still use the "compact" layout for short alerts and will automatically switch to the "expanded" layout when the text is long.
	// The exact parameters of when the "expanded" layout is triggered is not totally obvious since it could either be some number of lines, or just the total amount of text.
	// This "expanded" layout looks good and is usable for the long detailed messages displayed by IPSW Updater so it will be used for certain long messages where approriate.

	const dialogOrAlertProperties = {}
	if (buttons) dialogOrAlertProperties.buttons = buttons
	if (cancelButton) dialogOrAlertProperties.cancelButton = cancelButton
	if (defaultButton) dialogOrAlertProperties.defaultButton = defaultButton
	if (givingUpAfter) dialogOrAlertProperties.givingUpAfter = givingUpAfter

	if (!getPreference('ForceDialogWindowStyle', 'bool') && (!isBigSurOrNewer || isVenturaOrNewer)) {
		if (isVenturaOrNewer) {
			// NOTE: One BIG catch with the macOS 11 Big Sur and newer alert style is that all leading whitespace for each line will be trimmed.
			// This makes sense so that centered text always looks decent, but that leading whitespace will STILL be trimmed when the new
			// "extended" alert style is used on macOS 13 Ventura and newer, which is not necessary since the text will be left aligned.
			// Since the messages displayed by IPSW Updater rely on tab indented formatting to look correct, this trimming behavior is worked around by replacing the first
			// TAB on each line with NULL+TAB so that the line will no longer start with whitespace (since it will start with a NULL char instead) and therefore will NOT be trimmed.

			if (titleText.includes('\t')) titleText = titleText.replace(/^\t/gm, '\0\t')
			if (messageText.includes('\t')) messageText = messageText.replace(/^\t/gm, '\0\t')
		}

		if (messageText) dialogOrAlertProperties.message = messageText
		if ((icon == 'caution') || (icon == 'stop') || (icon == 'critical') || (icon == 'warning')) dialogOrAlertProperties.as = 'critical'
		// Do not need to explicitly set "as" to "informational" if "note" is specified since it is the default.

		return app.displayAlert(titleText, dialogOrAlertProperties)
	} else {
		if (windowTitle) dialogOrAlertProperties.withTitle = windowTitle
		if (icon == 'informational') icon = 'note'
		if ((icon == 'critical') || (icon == 'warning')) icon = 'caution'
		if (icon) dialogOrAlertProperties.withIcon = icon

		return app.displayDialog(`${titleText}${((titleText && messageText) ? '\n\n' : '')}${messageText}`, dialogOrAlertProperties)
	}
}

function createVersionsDownloadedSummary(downloadedFiles, indentLevel = 0) {
	let versionsDownloadedDisplay = ''

	const versionsDownloadedForEachOS = {}
	for (const thisDownloadedFirmwareFileName in downloadedFiles) {
		let thisOSname = ''
		if (thisDownloadedFirmwareFileName.startsWith('iPhone') || thisDownloadedFirmwareFileName.startsWith('iPod')) thisOSname = 'iOS'
		else if (thisDownloadedFirmwareFileName.startsWith('iPad')) thisOSname = 'iPadOS'
		else if (thisDownloadedFirmwareFileName.startsWith('AppleTV')) thisOSname = 'tvOS'
		else if (thisDownloadedFirmwareFileName.startsWith('Audio')) thisOSname = 'audioOS'
		else if (thisDownloadedFirmwareFileName.startsWith('iBridge')) thisOSname = 'bridgeOS'
		else if (thisDownloadedFirmwareFileName.startsWith('UniversalMac')) thisOSname = 'macOS'

		if (thisOSname) {
			if (!versionsDownloadedForEachOS[thisOSname]) versionsDownloadedForEachOS[thisOSname] = []
			const thisDownloadedVersion = downloadedFiles[thisDownloadedFirmwareFileName].Version
			if (!versionsDownloadedForEachOS[thisOSname].includes(thisDownloadedVersion)) versionsDownloadedForEachOS[thisOSname].push(thisDownloadedVersion)
		}
	}

	let downloadedVersionsCount = 0
	for (const thisVersionsForOS in versionsDownloadedForEachOS) {
		downloadedVersionsCount += versionsDownloadedForEachOS[thisVersionsForOS].length
		// @ts-ignore: JXA-ObjC
		versionsDownloadedForEachOS[thisVersionsForOS].sort((thisVersion, thatVersion) => $(thatVersion).compareOptions(thisVersion, $.NSNumericSearch))
	}

	if (downloadedVersionsCount > 0) {
		let indentTabs = ''
		for (let thisIndentIndex = 0; thisIndentIndex < indentLevel; thisIndentIndex ++)
			indentTabs += '\t'

		const onlyOneVersionDownloaded = (downloadedVersionsCount == 1)
		versionsDownloadedDisplay = `
${indentTabs}ðŸ Version${(onlyOneVersionDownloaded ? '' : 's')} Downloaded:`

		if (onlyOneVersionDownloaded) {
			const downloadedOSname = Object.keys(versionsDownloadedForEachOS)[0]
			versionsDownloadedDisplay += ` ${downloadedOSname} ${versionsDownloadedForEachOS[downloadedOSname][0]}`
		} else {
			// DON'T do this in a loop so that it's always displayed in this exact desired order.
			if (versionsDownloadedForEachOS.iOS) versionsDownloadedDisplay += `\n\t${indentTabs}iOS ${versionsDownloadedForEachOS.iOS.join(', ')}`
			if (versionsDownloadedForEachOS.iPadOS) versionsDownloadedDisplay += `\n\t${indentTabs}iPadOS ${versionsDownloadedForEachOS.iPadOS.join(', ')}`
			if (versionsDownloadedForEachOS.tvOS) versionsDownloadedDisplay += `\n\t${indentTabs}tvOS ${versionsDownloadedForEachOS.tvOS.join(', ')}`
			if (versionsDownloadedForEachOS.audioOS) versionsDownloadedDisplay += `\n\t${indentTabs}audioOS ${versionsDownloadedForEachOS.audioOS.join(', ')}`
			if (versionsDownloadedForEachOS.bridgeOS) versionsDownloadedDisplay += `\n\t${indentTabs}bridgeOS ${versionsDownloadedForEachOS.bridgeOS.join(', ')}`
			if (versionsDownloadedForEachOS.macOS) versionsDownloadedDisplay += `\n\t${indentTabs}macOS ${versionsDownloadedForEachOS.macOS.join(', ')}`
		}
	}

	return versionsDownloadedDisplay
}

function trashOrDeleteOutdatedFirmware(ipswFilePathToTrashOrDelete) {
	try {
		if (fileManager.fileExistsAtPath(ipswFilePathToTrashOrDelete)) {
			if (shouldImmediatelyDeleteOutdatedFirmwares)
				// @ts-ignore: JXA-ObjC
				return fileManager.removeItemAtPathError(ipswFilePathToTrashOrDelete, $())
			else
				// @ts-ignore: JXA-ObjC
				return fileManager.trashItemAtURLResultingItemURLError($.NSURL.fileURLWithPath(ipswFilePathToTrashOrDelete), $(), $())
		}

		return true
	} catch (ignoredError) {
		return false
	}
}

function wakeMacUp() {
	try { app.doShellScript('/usr/bin/caffeinate -u -t 1 > /dev/null 2>&1 &') } catch (ignoredError) { /* Ignore */ }
}

function macIsAwakeAndUnlocked() {
	// AppleScript alerts and dialogs will timeout early if Mac is asleep when it's displayed (ie. the screen is not available to draw on).
	// So this function is used to determine if it's safe to display an alert or dialog, or if should skip it or wait instead.

	// NOTE: The previous way that I detected if a Mac is awake (by checking if the following command return "4") no longer works on Apple Silicon Macs, but using "$.CGDisplayIsActive($.CGMainDisplayID())" works properly on all Macs models and macOS versions.
	// /usr/libexec/PlistBuddy -c "Print :0:IOPowerManagement:CurrentPowerState" /dev/stdin <<< "$(ioreg -arc IODisplayWrangler -k IOPowerManagement -d 1)"
	// ALSO NOTE: I was curious what would be returned by "$.CGMainDisplayID()" and "$.CGDisplayIsActive($.CGMainDisplayID())" when NO screen was connected, and from my testing it seems that on headless Macs there is always a virtual internal screen.
	// When testing on a 2010 through 2018 Mac mini's with NO screen connected, "$.CGMainDisplayID()" still returned a value which always either "1104977154" or "1104977153" and "$.CGDisplayIsBuiltin($.CGMainDisplayID())" returned "1" which
	// means that when no screen is connected, headless Macs still have a virtual internal screen. And, "$.CGDisplayIsActive($.CGMainDisplayID())" still returned "1" when the computer itself was actually awake, so it is always safe to use.

	// Screen Lock Check Based On: https://stackoverflow.com/questions/11505255/osx-check-if-the-screen-is-locked

	// @ts-ignore: JXA-ObjC
	return (($.CGDisplayIsActive($.CGMainDisplayID()) == 1) && (ObjC.deepUnwrap(cfRefToNSObjectIfNeeded($.CGSessionCopyCurrentDictionary())).CGSSessionScreenIsLocked !== true))
}

function cfRefToNSObjectIfNeeded(cfRefToConvert) {
	// Some automatic CF-NS bridging broke in JXA in Mojave and then more broke in Catalina.
	// This "CFMakeCollectable" workaround solves the issue to convert the CF references to NS objects,
	// but cannot be used indiscriminately on older versions of macOS that don't need the workaround as it
	// will return an empty NS object unless the input is an actual CF reference that needs to be converted.
	// So, this function will check that the input object needs to be converted and only convert it if so.
	// This way, this function can be called with any objects that may or may not need to be converted
	// on any version of macOS and will only convert the CF references to NS objects when needed.
	// If an plain Ref() is passed, it will have an "undefined" type and does not need to be converted.
	// If a reference is for an NSObject pointer, its type will be "@" which doesn't need to be converted.
	// I am uncertain if there are more Ref types that do not need to be converted, but if they come up
	// they should be easy to add to the following condition to ignore as needed.
	// @ts-ignore: JXA-ObjC
	return (((cfRefToConvert instanceof Ref) && (cfRefToConvert.type !== undefined) && (cfRefToConvert.type != '@')) ? $.CFMakeCollectable(cfRefToConvert) : cfRefToConvert)
}

function calculateChecksumForFile(filePath, algorithm = 1) {
	if (typeof algorithm != 'number') algorithm = parseInt(algorithm)
	if ((algorithm != 1) && (algorithm != 224) && (algorithm != 256) && (algorithm != 384) && (algorithm != 512)) algorithm = 1

	if (fileManager.fileExistsAtPath(filePath)) {
		let returnChecksum = `SHA${algorithm}SUM-UNKOWN-ERROR`
		// @ts-ignore: JXA-ObjC
		const checksumOutputFile = `${temporaryFilesFolder}/${$(filePath).lastPathComponent.js}-checksum`
		const calculateChecksumPID = app.doShellScript(`/usr/bin/openssl dgst -sha${algorithm} ${quoteForShell(filePath)} > ${quoteForShell(checksumOutputFile)} 2>&1 & echo $!`)

		try {
			while (app.doShellScript(`/bin/ps -p ${calculateChecksumPID} > /dev/null 2>&1; echo $?`) == 0)
				// @ts-ignore: JXA
				delay(0.25)

			// @ts-ignore: JXA-ObjC
			returnChecksum = $.NSString.stringWithContentsOfFileEncodingError(checksumOutputFile, $.NSUTF8StringEncoding, $()).js.substring(`SHA${algorithm}(${filePath})= `.length).trim() // Need to "trim()"" to remove trailing linebreak.
		} catch (calculateChecksumError) {
			debugLog(`Calculate SHA${algorithm} Checksum Error`, calculateChecksumError)

			try { app.doShellScript(`kill ${calculateChecksumPID}`) } catch (ignoredError) { /* Ignore */ }

			// @ts-ignore: JXA-ObjC
			try { fileManager.removeItemAtPathError(checksumOutputFile, $()) } catch (ignoredError) { /* Ignore */ }

			if (calculateChecksumError.errorNumber === -128) {
				setProgressStopButtonEnabled(false)
				throw calculateChecksumError
			}
		}

		// @ts-ignore: JXA-ObjC
		try { fileManager.removeItemAtPathError(checksumOutputFile, $()) } catch (ignoredError) { /* Ignore */ }

		return returnChecksum
	} else
		return `SHA${algorithm}SUM-FILE-DNE`
}

// From: https://stackoverflow.com/questions/15900485/correct-way-to-convert-size-in-bytes-to-kb-mb-gb-in-javascript/18650828#18650828
function formatBytes(bytes, decimals = 2) {
	if (!+bytes) return '0 bytes'
	const k = 1000
	const sizes = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
	const i = Math.floor(Math.log(bytes) / Math.log(k))
	return `${parseFloat((bytes / Math.pow(k, i)).toFixed(decimals < 0 ? 0 : decimals))} ${sizes[i]}`
}

// From: https://stackoverflow.com/questions/19700283/how-to-convert-time-milliseconds-to-hours-min-sec-format-in-javascript32180863#32180863
function durationConversion(millisec) {
	const seconds = +(millisec / 1000).toFixed(1).replace('.0', '')
	const minutes = +(millisec / (1000 * 60)).toFixed(1).replace('.0', '')
	const hours = +(millisec / (1000 * 60 * 60)).toFixed(1).replace('.0', '')
	const days = +(millisec / (1000 * 60 * 60 * 24)).toFixed(1).replace('.0', '')

	if (seconds < 60)
		return `${seconds} second${((seconds == 1) ? '' : 's')}`
	else if (minutes < 60)
		return `${minutes} minute${((minutes == 1) ? '' : 's')}`
	else if (hours < 24)
		return `${hours} hour${((hours == 1) ? '' : 's')}`
	else
		return `${days} day${((days == 1) ? '' : 's')}`
}

function setProgressStopButtonEnabled(setEnabled) {
	if (progressWindow)
		for (const thisSubview of progressWindow.contentView.subviews.js)
			// @ts-ignore: JXA-ObjC
			if (($.NSStringFromClass(thisSubview.class).js == 'NSButton') && ((thisSubview.title.js == 'Stop') || (thisSubview.title.js == 'Skip'))) {
				thisSubview.enabled = setEnabled
				break
			}
}

function setProgressStopButtonToSkip() {
	if (progressWindow)
		for (const thisSubview of progressWindow.contentView.subviews.js)
			// @ts-ignore: JXA-ObjC
			if (($.NSStringFromClass(thisSubview.class).js == 'NSButton') && (thisSubview.title.js == 'Stop')) {
				thisSubview.title = 'Skip'
				break
			}
}

function setProgressSkipButtonToStop() {
	if (progressWindow)
		for (const thisSubview of progressWindow.contentView.subviews.js)
			// @ts-ignore: JXA-ObjC
			if (($.NSStringFromClass(thisSubview.class).js == 'NSButton') && (thisSubview.title.js == 'Skip')) {
				thisSubview.title = 'Stop'
				break
			}
}

function closeProgressWindow() {
	if (progressWindow) {
		// @ts-ignore: JXA-ObjC
		progressWindow.animationBehavior = $.NSWindowAnimationBehaviorUtilityWindow
		progressWindow.isVisible = false
		progressWindow.center
	}
}

function openProgressWindow() {
	if (progressWindow) {
		if (!progressWindow.isVisible) {
			progressWindow.center
			// @ts-ignore: JXA-ObjC
			progressWindow.animationBehavior = $.NSWindowAnimationBehaviorDocumentWindow
		}

		// @ts-ignore: JXA-ObjC
		progressWindow.makeKeyAndOrderFront($.NSApp)
	}
}

function validateCodeSignatureForAppAtPath(validateAppPath) {
	// @ts-ignore: JXA-ObjC
	const validateAppBundle = $.NSBundle.bundleWithPath(validateAppPath)
	if (validateAppBundle.isNil())
		throw new Error(`Code Signature Validation Failed

â€œ${validateAppPath}â€ is not a valid application bundle.`)

	const validateAppVersion = validateAppBundle.objectForInfoDictionaryKey('CFBundleShortVersionString').js // DO NOT use the "appVersion" variable of the running app since this function may be validating an app update and not the running app.
	if (!validateAppVersion)
		throw new Error(`Code Signature Validation Failed

â€œ${validateAppPath}â€ does not have a valid â€œCFBundleShortVersionStringâ€.`)

	const verifyNotarization = (!validateAppVersion.endsWith('-0') && isMojaveOrNewer) // DO NOT verify notarization for testing builds (with versions ending in "-0") since they will only be signed and not notarized, and see comments below about how notarization CANNOT be verified on macOS 10.13 High Sierra.

	const intendedCodeSignatureTeamID = 'YRW6NUGA63'
	const validCSReqString = `${verifyNotarization ? 'notarized and ' : ''}identifier "${bundleIdentifier}" and anchor apple generic and certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = ${intendedCodeSignatureTeamID}`
	// Explanation of Code Signing Requirement Strings: https://developer.apple.com/documentation/technotes/tn3127-inside-code-signing-requirements
	// The specified CSReqs string is verifying the correct Bundle ID, Team ID, and that it is signed with a Developer ID certificate, and starting on macOS 10.14 Mojave,
	// there is a "notarized" token which can be included in the CSReq string to confirm the app is notarized, so notarization is also verified when that token is available and it not a testing build (discovered this wasn't supported/available on macOS 10.13 High Sierra through testing).
	// This "notarized" token can be seen in the output of "spctl --list" on macOS 10.14 Mojave and newer and can also be seen here: https://gregoryszorc.com/docs/apple-codesign/stable/apple_codesign_gatekeeper.html
	// This other "generate-csreq-hex-for-tcc-db.jxa" script also contains information about CSReqs and the "Security" framework functions to retreive them via JXA (which are used below): https://github.com/freegeek-pdx/macOS-Testing-and-Deployment-Scripts/blob/main/Other%20Scripts/generate-csreq-hex-for-tcc-db.jxa

	// This first check is done using native C functions of the "Security" framework (such as https://developer.apple.com/documentation/security/1395784-secstaticcodecheckvalidity?language=objc).
	// This checking using native C function may be a bit overzealous, but the basic code was already written for "mkuser" (https://mkuser.sh) where it was important to run code signature checks using native
	// functions so the result could not be spoofed by a MITM type attack on the "codesign" or "spctl" commands: https://github.com/freegeek-pdx/mkuser/blob/c5c1642912ca1551197b9490339b0a8303a45071/mkuser.sh#L4072-L4165

	// @ts-ignore: JXA-ObjC
	const staticCodeRef = $()
	// @ts-ignore: JXA-ObjC
	const actualCSReqRef = $()
	// @ts-ignore: JXA-ObjC
	const actualCSReqStringRef = $()
	// @ts-ignore: JXA-ObjC
	const validCSReqRef = $()
	let csReqValidityErrorCode = -1
	// @ts-ignore: JXA-ObjC
	const csReqValidityPassed = (($.SecStaticCodeCreateWithPath($.NSURL.fileURLWithPath(validateAppPath), $.kSecCSDefaultFlags, staticCodeRef) === 0) && !staticCodeRef.isNil() &&
		// @ts-ignore: JXA-ObjC
		($.SecCodeCopyDesignatedRequirement(staticCodeRef, $.kSecCSDefaultFlags, actualCSReqRef) === 0) && !actualCSReqRef.isNil() &&
		// @ts-ignore: JXA-ObjC
		($.SecRequirementCopyString(actualCSReqRef, $.kSecCSDefaultFlags, actualCSReqStringRef) === 0) && !actualCSReqStringRef.isNil() && // Only retrieving actual CSReqs string for display if there is an error. DO NOT compare it litarally like "(validCSReqString === actualCSReqStringRef.js)" since it WILL NOT contain the "notarized" token, and comparing literal CSReq strings to each other is not technically reliable/correct since conditions can be specified in different orders and still be valid/equal. The following "SecStaticCodeCheckValidity" function properly evaluates the conditions in the "validCSReqString" against the "staticCodeRef" of the app.
		// @ts-ignore: JXA-ObjC
		($.SecRequirementCreateWithString($.CFStringCreateWithCString($.kCFAllocatorDefault, validCSReqString, $.kCFStringEncodingUTF8), $.kSecCSDefaultFlags, validCSReqRef) === 0) &&
		!validCSReqRef.isNil() && // First check that "validCSReqRef" is NOT nil/NULL to be sure the valid requirement string itself is a proper CSReqs string (since if not, nil/NULL would be passed to "SecStaticCodeCheckValidity" which would just verify against the binaries internal requirements).
		// @ts-ignore: JXA-ObjC
		((csReqValidityErrorCode = $.SecStaticCodeCheckValidity(staticCodeRef, $.kSecCSCheckAllArchitectures, validCSReqRef)) === 0)) // I also tried using "$.SecCodeCheckValidity(staticCodeRef, $.kSecCSDefaultFlags, validCSReqRef)" but it always returned error code "-67071" (errSecCSInvalidObjectRef = Invalid API object reference) while "SecStaticCodeCheckValidity" seems to properly check the CSReq string and return "0" when sucessfully matched.

	// The "SecStaticCodeCheckValidity" function above does basically the same thing as the following "codesign -vvR" command, but still double-check it succeeds to be extra thorough and show useful output if anything fails.
	let codesignVerifyPassed = false
	let codesignVerifyErrorCode = -1
	let codesignVerifyOutput = 'UNKNOWN CODESIGN VERIFY ERROR'
	try {
		codesignVerifyOutput = app.doShellScript(`/usr/bin/codesign -vvR ${quoteForShell(`=${validCSReqString}`)} ${quoteForShell(validateAppPath)} 2>&1`)
		codesignVerifyPassed = true
	} catch (codesignVerifyError) {
		codesignVerifyErrorCode = codesignVerifyError.errorNumber
		codesignVerifyOutput = codesignVerifyError.message
	}

	// The "SecStaticCodeCheckValidity" function AND "codesign -vvR" command above already confirm the app is signed by the intended Team ID (and notarized, when possible on macOS 10.14 Mojave or newer)
	// but still triple-check by running "spctl -avv" and confirm it succeeds AND contains specific output to be extra thorough and show useful output if anything fails.
	let spctlAssessPassed = false
	let spctlAssessErrorCode = -1
	let spctlAssessOutput = 'UNKNOWN SPCTL ASSESS ERROR'
	try {
		spctlAssessOutput = app.doShellScript(`/usr/sbin/spctl -avv ${quoteForShell(validateAppPath)} 2>&1`)
		spctlAssessPassed = (spctlAssessOutput.includes(`source=${verifyNotarization ? 'Notarized ' : ''}Developer ID`) && spctlAssessOutput.endsWith(`origin=Developer ID Application: Pico Mitchell (${intendedCodeSignatureTeamID})`)) // The "spctl -avv" output on macOS 10.13 High Sierra will only ever include "source=Developer ID" even if it's actually notarized while macOS 10.14 Mojave and newer will include "source=Notarized Developer ID".
	} catch (spctlAssessError) {
		spctlAssessErrorCode = spctlAssessError.errorNumber
		spctlAssessOutput = spctlAssessError.message
	}

	if (!csReqValidityPassed || !codesignVerifyPassed || !spctlAssessPassed)
		throw new Error(`Code Signature Validation Failed for App at Path:
${validateAppPath}

Code Signature Verification: ${codesignVerifyPassed ? 'PASSED' : `FAILED (${codesignVerifyErrorCode})`}
${codesignVerifyOutput.replace(/^.*\.app: /gm, '')}

Security Assessment: ${spctlAssessPassed ? 'PASSED' : `FAILED (${spctlAssessErrorCode})`}
${spctlAssessOutput.replace(/^.*\.app: /gm, '')}

Code Signing Requirements: ${csReqValidityPassed ? 'PASSED' : `FAILED (${csReqValidityErrorCode})`}
${actualCSReqStringRef.isNil() ? 'NO CSREQS' : actualCSReqStringRef.js}`) // Show "Code Signing Requirements" last since it's the most cryptic output and the other output has more understandable error messages.
}

function checkAndInstallAppUpdates() {
	setProgressStopButtonEnabled(false)

	Progress.description = `
ðŸ”„	Checking for App Updates`
	Progress.additionalDescription = ''
	Progress.completedUnitCount = 0
	Progress.totalUnitCount = -1

	if (isBigSurOrNewer && progressWindow) {
		// There is a bug in Big Sur where setting indeterminate progress AFTER determinate progress has been shown just displays 0 progress.
		// To workaround this, startAnimation on the NSProgressIndicator directly.

		for (const thisSubview of progressWindow.contentView.subviews.js)
			// @ts-ignore: JXA-ObjC
			if ($.NSStringFromClass(thisSubview.class).js == 'NSProgressIndicator') {
				thisSubview.startAnimation(thisSubview)
				break
			}
	}

	wakeMacUp()

	app.activate()

	openProgressWindow()

	const appUpdatesJsonFilePath = `${temporaryFilesFolder}/app-updates.json`
	let appUpdateProgressOutputFile = `${temporaryFilesFolder}/app-updates.json-progress`
	let userCanceledUpdate = false

	// @ts-ignore: JXA-ObjC
	const readAppUpdatesFileError = $()

	try {
		if (!fileManager.fileExistsAtPath(temporaryFilesFolder))
			// @ts-ignore: JXA-ObjC
			fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(temporaryFilesFolder, true, {}, $())

		if (curlPIDs.length > 0) try { app.doShellScript(`kill ${curlPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }

		const downloadAppUpdatesJsonPID = app.doShellScript(`/usr/bin/curl -m 5 -L ${quoteForShell(appUpdatesJsonURL)} -o ${quoteForShell(appUpdatesJsonFilePath)} > ${quoteForShell(appUpdateProgressOutputFile)} 2>&1 & echo $!`)
		curlPIDs.push(downloadAppUpdatesJsonPID)

		try {
			while (app.doShellScript(`/bin/ps -p ${downloadAppUpdatesJsonPID} > /dev/null 2>&1; echo $?`) == 0)
				// @ts-ignore: JXA
				delay(0.25)
		} catch (waitingForAppUpdatesJsonError) {
			debugLog('Waiting for App Updates JSON Error', waitingForAppUpdatesJsonError)

			try { app.doShellScript(`kill ${downloadAppUpdatesJsonPID}`) } catch (ignoredError) { /* Ignore */ }

			throw waitingForAppUpdatesJsonError
		}

		// @ts-ignore: JXA-ObjC
		const appUpdatesInfo = JSON.parse($.NSString.stringWithContentsOfFileEncodingError(appUpdatesJsonFilePath, $.NSUTF8StringEncoding, readAppUpdatesFileError).js)
		// NOTE: NOT using "ObjC.deepUnwrap($.NSJSONSerialization.JSONObjectWithDataOptionsError(...))" for consistency with other JSON parsing which don't use it for other reasons which aren't really important here (this JSON parse really would be fine with either technique).

		if (Array.isArray(appUpdatesInfo) && (appUpdatesInfo.length > 0)) {
			// @ts-ignore: JXA-ObjC
			try { fileManager.removeItemAtPathError(appUpdateProgressOutputFile, $()) } catch (ignoredError) { /* Ignore */ }
			// @ts-ignore: JXA-ObjC
			try { fileManager.removeItemAtPathError(appUpdatesJsonFilePath, $()) } catch (ignoredError) { /* Ignore */ }

			const latestAppUpdateInfo = appUpdatesInfo[0]

			setPreference('LastAppUpdateCheck', new Date(), 'date')

			if (latestAppUpdateInfo.version && latestAppUpdateInfo.sha512sum && latestAppUpdateInfo.url &&
				// @ts-ignore: JXA-ObjC
				($(latestAppUpdateInfo.version).compareOptions(appVersion, $.NSNumericSearch) == 1)) {
				setPreference('AppUpdateAvailable', true, 'bool')

				closeProgressWindow()

				const displayReleaseDate = (latestAppUpdateInfo.releasedate ? new Date(latestAppUpdateInfo.releasedate).toLocaleDateString('en-US', dateFormatOptions) : 'UNKNOWN')

				// @ts-ignore: JXA-ObjC
				const appPathIsWritableRef = $()
				// @ts-ignore: JXA-ObjC
				try { $.NSURL.fileURLWithPath(appPath).getResourceValueForKeyError(appPathIsWritableRef, $.NSURLIsWritableKey, $()) } catch (ignoredError) { /* Ignore */ }

				// @ts-ignore: JXA-ObjC
				const parentDirectoryToMeIsWritableRef = $()
				// @ts-ignore: JXA-ObjC
				try { $.NSURL.fileURLWithPath(parentDirectoryToMe).getResourceValueForKeyError(parentDirectoryToMeIsWritableRef, $.NSURLIsWritableKey, $()) } catch (ignoredError) { /* Ignore */ }

				const autoInstallUpdate = (appPathIsWritableRef.js && parentDirectoryToMeIsWritableRef.js)
				let shouldInstallUpdate = autoInstallUpdate
				let userClickedInstall = false

				if (macIsAwakeAndUnlocked()) { // If Mac is asleep or locked, the update will be automatically installed without prompting if "autoInstallUpdate" is true.
					for ( ; ; ) {
						app.activate()
						const appUpdateAvailableReply = displayAlertOrDialogDependingOnOS(`${appName} Version ${latestAppUpdateInfo.version} is Now Available!`,
							`Released: ${displayReleaseDate}

Version ${latestAppUpdateInfo.version} Release Notes:

${latestAppUpdateInfo.releasenotes ? latestAppUpdateInfo.releasenotes : '	No Release Notes'}

Version ${appVersion} is currently installed.
In 60 seconds, ${(autoInstallUpdate ? `version ${latestAppUpdateInfo.version} will automatically be installedâ€¦` :
'this update will be skipped until the next runâ€¦')}`,
							`${appName}  â€”  Update Available`,
							'note',
							['View All Release Notes', 'Update Later', `Update to ${latestAppUpdateInfo.version}`],
							2,
							3,
							60
						)

						if (appUpdateAvailableReply.buttonReturned == 'View All Release Notes') {
							// @ts-ignore: JXA-ObjC
							sharedWorkspace.openURL($.NSURL.URLWithString(releaseNotesURL))
						} else {
							userClickedInstall = appUpdateAvailableReply.buttonReturned.includes(latestAppUpdateInfo.version)
							shouldInstallUpdate = ((appUpdateAvailableReply.gaveUp && autoInstallUpdate) || userClickedInstall)
							break
						}
					}
				}

				if (shouldInstallUpdate) {
					Progress.description = `ðŸ”„	Downloading ${appName} Version ${latestAppUpdateInfo.version}`
					Progress.additionalDescription = `
ðŸ—“ Released: ${displayReleaseDate}

ðŸ“ Size: ${(latestAppUpdateInfo.size ? formatBytes(latestAppUpdateInfo.size) : 'UNKNOWN')}`

					setProgressStopButtonEnabled(true)
					openProgressWindow()

					// @ts-ignore: JXA-ObjC
					const appUpdateZipFileName = $(latestAppUpdateInfo.url).lastPathComponent.js
					const appUpdateZipFilePath = `${temporaryFilesFolder}/${appUpdateZipFileName}`
					appUpdateProgressOutputFile = `${temporaryFilesFolder}/${appUpdateZipFileName}-progress`

					if (curlPIDs.length > 0) try { app.doShellScript(`kill ${curlPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }

					const downloadAppUpdatePID = app.doShellScript(`/usr/bin/curl --connect-timeout 5 -L ${quoteForShell(latestAppUpdateInfo.url)} -o ${quoteForShell(appUpdateZipFilePath)} > ${quoteForShell(appUpdateProgressOutputFile)} 2>&1 & echo $!`)
					curlPIDs.push(downloadAppUpdatePID)

					try {
						while (app.doShellScript(`/bin/ps -p ${downloadAppUpdatePID} > /dev/null 2>&1; echo $?`) == 0)
							// @ts-ignore: JXA
							delay(0.25)
					} catch (waitingForAppUpdateDownloadError) {
						debugLog('Waiting for App Update Download Error', waitingForAppUpdateDownloadError)

						try { app.doShellScript(`kill ${downloadAppUpdatePID}`) } catch (ignoredError) { /* Ignore */ }

						throw waitingForAppUpdateDownloadError
					}

					setProgressStopButtonEnabled(false)

					const appUpdateZipFileSHA512Sum = calculateChecksumForFile(appUpdateZipFilePath, 512)
					if (latestAppUpdateInfo.sha512sum != appUpdateZipFileSHA512Sum)
						throw new Error(`App Update ZIP File Is Invalid

Intended ZIP Checksum:
${latestAppUpdateInfo.sha512sum}

Downloaded ZIP Checksum:
${appUpdateZipFileSHA512Sum}`)

					Progress.description = `
ðŸ”„	Installing & Launching ${appName} Version ${latestAppUpdateInfo.version}`
					Progress.additionalDescription = ''
					// @ts-ignore: JXA
					delay(0.25)

					const appUpdateTempFilePath = app.doShellScript(`/usr/bin/ditto -xkV --noqtn ${quoteForShell(appUpdateZipFilePath)} ${quoteForShell(temporaryFilesFolder)} 2>&1`).match(/copying file (.+?)\.app\/Contents\/Info\.plist \.\.\. /)[0].replace('copying file ', `${temporaryFilesFolder}/`).replace('/Contents/Info.plist ... ', '')

					// @ts-ignore: JXA-ObjC
					try { fileManager.removeItemAtPathError(appUpdateZipFilePath, $()) } catch (ignoredError) { /* Ignore */ }

					if (!fileManager.fileExistsAtPath(appUpdateTempFilePath))
						throw new Error('App Update Not Found After Unzipping Download')

					// @ts-ignore: JXA-ObjC
					try { fileManager.removeItemAtPathError(appUpdateProgressOutputFile, $()) } catch (ignoredError) { /* Ignore */ }

					// IMPORTANT: Before installing the updated app, confirm that it is properly signed (and notarized, when possible on macOS 10.14 Mojave and newer).
					// See comments in the "validateCodeSignatureForAppAtPath" function for more information.
					validateCodeSignatureForAppAtPath(appUpdateTempFilePath) // NOTE: This function with "throw" an error if validation fails which will be caught and displayed below.

					setPreference('AppJustAutoUpdated', true, 'bool')

					// @ts-ignore: JXA-ObjC
					try { fileManager.setAttributesOfItemAtPathError($.NSDictionary.dictionaryWithObjectForKey($.NSDate.date, $.NSFileModificationDate), appUpdateTempFilePath, $()) } catch (ignoredError) { /* Ignore */ } // "touch" unzipped app.

					// @ts-ignore: JXA
					delay(0.25)

					// @ts-ignore: JXA-ObjC
					const globalApplicationsFolderIsWritableRef = $()
					// @ts-ignore: JXA-ObjC
					try { $.NSURL.fileURLWithPath('/Applications').getResourceValueForKeyError(globalApplicationsFolderIsWritableRef, $.NSURLIsWritableKey, $()) } catch (ignoredError) { /* Ignore */ }
					const globalApplicationsFolderIsWritable = globalApplicationsFolderIsWritableRef.js

					// @ts-ignore: JXA-ObjC
					const updatedAppFileName = `${$(appUpdateTempFilePath).lastPathComponent.js}`

					const installAppUpdateScript = `/usr/bin/osascript -e ${quoteForShell(`
use AppleScript version "2.7"
use scripting additions
use framework "Foundation"

set currentAppFilePath to ${quoteForAppleScript(appPath)}

delay 0.5
repeat while (application currentAppFilePath is running)
	delay 0.5
end repeat

set versionedAppFilePath to ${quoteForAppleScript(`${parentDirectoryToMe}/${appName} (${appVersion}).app`)}
set appUpdateTempFilePath to ${quoteForAppleScript(appUpdateTempFilePath)}
set appInstallFilePath to ${quoteForAppleScript(`${parentDirectoryToMe}/${updatedAppFileName}`)}
set actualInstallFilePath to appInstallFilePath

set systemApplicationsFolder to (POSIX path of (path to applications folder from system domain))
set appInSystemApplicationsFolder to (systemApplicationsFolder & ${quoteForAppleScript(updatedAppFileName)})

set userApplicationsFolder to (POSIX path of (path to applications folder from user domain))
set appInUserApplicationsFolder to (userApplicationsFolder & ${quoteForAppleScript(updatedAppFileName)})

set userDownloadsFolder to (POSIX path of (path to downloads folder from user domain))
set appInUserDownloadsFolder to (userDownloadsFolder & ${quoteForAppleScript(updatedAppFileName)})

set adminPermissionPrompt to "â€œ${quoteForAppleScript(appName, true)}â€ requires Admin Permission to update itself to version ${quoteForAppleScript(latestAppUpdateInfo.version, true)}."

try
	set fileManager to (defaultManager of NSFileManager of current application)

	try
		if (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) then
			moveItemAtPath_toPath_error_(currentAppFilePath, versionedAppFilePath, missing value) of fileManager
		end if
	end try

	try
		if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (fileExistsAtPath_(versionedAppFilePath) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(versionedAppFilePath) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(versionedAppFilePath) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of versionedAppFilePath) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (fileExistsAtPath_(currentAppFilePath) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(currentAppFilePath) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(currentAppFilePath) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of currentAppFilePath) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((currentAppFilePath is not equal to appInstallFilePath) and (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (fileExistsAtPath_(appInstallFilePath) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInstallFilePath) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInstallFilePath) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInstallFilePath) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try
${((userClickedInstall || globalApplicationsFolderIsWritable) ? `
	try
		if ((currentAppFilePath is not equal to appInSystemApplicationsFolder) and (appInstallFilePath is not equal to appInSystemApplicationsFolder) and (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInSystemApplicationsFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInSystemApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try
` : '')}
	try
		if ((currentAppFilePath is not equal to appInUserApplicationsFolder) and (appInstallFilePath is not equal to appInUserApplicationsFolder) and (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInUserApplicationsFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInUserApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((currentAppFilePath is not equal to appInUserDownloadsFolder) and (appInstallFilePath is not equal to appInUserDownloadsFolder) and (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInUserDownloadsFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInUserDownloadsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	set appUpdateTempFileStructure to ""
	try
		set appUpdateTempFileStructure to (do shell script ("cd " & (quoted form of appUpdateTempFilePath) & " && /bin/ls -Rsk"))
	end try

	try
		if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInstallFilePath) of fileManager))) then
			moveItemAtPath_toPath_error_(appUpdateTempFilePath, appInstallFilePath, missing value) of fileManager
			if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInstallFilePath) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appUpdateTempFilePath) & " " & (quoted form of appInstallFilePath) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try
${((userClickedInstall || globalApplicationsFolderIsWritable) ? `
	try
		if ((appInstallFilePath is not equal to appInSystemApplicationsFolder) and (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager))) then
			moveItemAtPath_toPath_error_(appUpdateTempFilePath, appInSystemApplicationsFolder, missing value) of fileManager
			if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appUpdateTempFilePath) & " " & (quoted form of appInSystemApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
			set actualInstallFilePath to appInSystemApplicationsFolder
		end if
	end try
` : '')}
	try
		if ((appInstallFilePath is not equal to appInUserApplicationsFolder) and (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager))) then
			moveItemAtPath_toPath_error_(appUpdateTempFilePath, appInUserApplicationsFolder, missing value) of fileManager
			if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appUpdateTempFilePath) & " " & (quoted form of appInUserApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
			set actualInstallFilePath to appInUserApplicationsFolder
		end if
	end try

	if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager))) then
		moveItemAtPath_toPath_error_(appUpdateTempFilePath, appInUserDownloadsFolder, missing value) of fileManager
		if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appUpdateTempFilePath) & " " & (quoted form of appInUserDownloadsFolder) with prompt adminPermissionPrompt with administrator privileges
		set actualInstallFilePath to appInUserDownloadsFolder
	end if

	setBool_forKey_(false, "AppUpdateAvailable") of initWithSuiteName_(${quoteForAppleScript(bundleIdentifier)}) of alloc of NSUserDefaults of current application

	if (fileExistsAtPath_(actualInstallFilePath) of fileManager) then
		-- When working auto-updating for MacLand Scripts, Catalina seems to fail to launch if done too quickly after a move (with an "executable not found" error).
		-- Generating the install path file structure alone seems to delay enough to avoid the issue, but this loop makes it extra safe.

		repeat 30 times
			try
				set installAppFileStructure to ""
				try
					set installAppFileStructure to (do shell script ("cd " & (quoted form of actualInstallFilePath) & " && /bin/ls -Rsk"))
				on error
					try
						set installAppFileStructure to (do shell script ("cd " & (quoted form of actualInstallFilePath) & " && /bin/ls -Rsk") with prompt adminPermissionPrompt with administrator privileges)
					on error
						exit repeat
					end try
				end try
				if (appUpdateTempFileStructure is equal to installAppFileStructure) then exit repeat
			end try
			delay 0.5
		end repeat
	end if
on error installError
	activate
	beep
	display alert "Error Installing â€œ${quoteForAppleScript(appName, true)}â€ After Update" message installError as critical
end try

try
	do shell script "/usr/bin/open -na " & (quoted form of actualInstallFilePath)
on error
	try
		do shell script "/usr/bin/open -na " & (quoted form of ${quoteForAppleScript(`${parentDirectoryToMe}/${appName}.app`)})
	on error
		try
			do shell script "/usr/bin/open -na " & (quoted form of currentAppFilePath)
		on error
			try
				do shell script "/usr/bin/open -nb ${bundleIdentifier}"
			on error launchError
				activate
				beep
				display alert "Error Launching â€œ${quoteForAppleScript(appName, true)}â€ After Update" message launchError buttons {"Quit", "Re-Download â€œ${quoteForAppleScript(appName, true)}â€"} cancel button 1 default button 2 as critical
				do shell script "/usr/bin/open 'https://ipsw.app/download/'"
			end try
		end try
	end try
end try
`)} > /dev/null 2>&1 &`

					//debugDialog(installAppUpdateScript.replace(/\/usr\/bin\/osascript -e '|' > \/dev\/null 2>&1 &/g, '').replace(/'\\''/g, "'").trim())
					//debugDialog(app.doShellScript(installAppUpdateScript.replace('/usr/bin/osascript -e ', "printf '%s' ").replace(' > /dev/null 2>&1 &', '')).trim())

					app.doShellScript(installAppUpdateScript)

					app.quit()
				}
			} else
				setPreference('AppUpdateAvailable', false, 'bool')

			// @ts-ignore: JXA-ObjC
			try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }

			closeProgressWindow()
		} else
			throw new Error(`App Updates Info Is Empty or Is Not an Array`)
	} catch (appUpdateError) {
		if (!userCanceledUpdate) userCanceledUpdate = (appUpdateError.errorNumber === -128)

		let appUpdateErrorMessage = appUpdateError.message
		if (!readAppUpdatesFileError.isNil()) appUpdateError = readAppUpdatesFileError.description.js

		try {
			// @ts-ignore: JXA-ObjC
			const progressOutputParts = $.NSString.stringWithContentsOfFileEncodingError(appUpdateProgressOutputFile, $.NSUTF8StringEncoding, $()).js.split('curl: ')
			if (progressOutputParts.length > 1)
				appUpdateErrorMessage = `CURL Error: ${progressOutputParts.slice(-1)[0].trim()}`
		} catch (ignoredError) { /* Ignore */ }

		// @ts-ignore: JXA-ObjC
		try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }

		debugLog(`App Update Error: ${appUpdateErrorMessage}`, appUpdateError)

		closeProgressWindow()

		if (!userCanceledUpdate && macIsAwakeAndUnlocked()) {
			const appUpdateErrorAlertMessage = `${appUpdateErrorMessage.replace('CURL Error: (6) ', '')}${(appUpdateErrorMessage.startsWith('CURL Error:') || appUpdateErrorMessage.startsWith('App Update ') || appUpdateErrorMessage.startsWith('Code Signature Validation ')) ? '' : `

${((typeof appUpdateError == 'object') ? JSON.stringify(appUpdateError, Object.getOwnPropertyNames(appUpdateError)) : appUpdateError)}`}` // Do NOT display detailed error message (such as failing to read or parse file) if the actual error was because of a CURL download failure since it may just confuse the actual issue, and do not show "appUpdateError" dict for "App Update" or "Code Signature" error messages since the custom message itself contains all the relevant info.

			app.activate()
			if (getPreference('AppUpdateAvailable', 'bool'))
				try {
					const appUpdateErrorAlertReply = app.displayAlert(`${appName}: App Update Error`,
						{
							message: appUpdateErrorAlertMessage,
							as: 'critical',
							buttons: ['Continue With Outdated Version', 'Manually Download Update & Quit'],
							cancelButton: 1,
							defaultButton: 2,
							givingUpAfter: 30
						}
					)

					if (!appUpdateErrorAlertReply.gaveUp) {
						app.doShellScript('/usr/bin/open https://ipsw.app/download/')
						app.quit()
					}
				} catch (ignoredError) { /* Ignore */ }
			else
				app.displayAlert(`${appName}: App Update Error`,
					{
						message: appUpdateErrorAlertMessage,
						as: 'critical',
						givingUpAfter: 30
					}
				)
		}
	}
}

function promptForPreferences() {
	while (!macIsAwakeAndUnlocked()) // AppleScript dialogs will timeout early if Mac is asleep when it's displayed. So, wait until Mac is awake to display the dialog.
		// @ts-ignore: JXA
		delay(15)

	const listDisplayPadding = '\t\t\t\t\t\t\t'

	const previousExcludedProducts = getPreference('ExcludeProducts', 'string array') // This returned excluded product will always be sanitized to a valid value by "getPreference()".
	const previousExcludedProductsWithListDisplayPadding = []
	for (const thisPreviousExcludedProduct of previousExcludedProducts)
		previousExcludedProductsWithListDisplayPadding.push(`${listDisplayPadding}${thisPreviousExcludedProduct}`)

	const productsListWithListDisplayPadding = []
	for (const thisProductType of everyProductType)
		productsListWithListDisplayPadding.push(`${listDisplayPadding}${thisProductType}`)

	let excludeProductsArray = []
	for ( ; ; ) {
		app.activate()
		const excludeProductsChooseReply = app.chooseFromList(productsListWithListDisplayPadding,
			{
				withTitle: `${appName} ${settingsOrPreferencesName}  â€”  Exclude Product Types`,
				withPrompt: `ðŸš«\tWould you like to EXCLUDE any types of products?

Select Multiple: Click+Drag, Shift+Click, Command+Click`,
				defaultItems: previousExcludedProductsWithListDisplayPadding,
				okButtonName: 'Save Excluded Product Types Selection',
				cancelButtonName: `Don't Exclude Any Product Types`,
				multipleSelectionsAllowed: true,
				emptySelectionAllowed: true,
			}
		)

		if (Array.isArray(excludeProductsChooseReply))
			for (const thisChosenExcludedProduct of excludeProductsChooseReply)
				excludeProductsArray.push(thisChosenExcludedProduct.trim())

		if (excludeProductsArray.length >= productsListWithListDisplayPadding.length) {
			app.activate()
			app.displayAlert(`${appName} won't have any IPSW Firmware files to download if you exclude everything!`,
				{
					message: 'You must include at least one type of product.',
					as: 'critical'
				}
			)

			excludeProductsArray = []
		} else
			break
	}

	setPreference('ExcludeProducts', excludeProductsArray, 'string array')

	if (!excludeProductsArray.includes('iPhone') || !excludeProductsArray.includes('iPad') || !excludeProductsArray.includes('iPod touch') || !excludeProductsArray.includes('Apple TV')) {
		const versionDescriptions = [
			'iOS 16 / iPadOS 16 / tvOS 16 and Newer',
			'iOS 15 and Newer	(iPhone 6s - 7, iPad Air 2, iPad mini 4, iPod touch 7)',
			'iOS 12 and Newer	(iPhone 5s - 6, iPad Air, iPad mini 2 - 3, iPod touch 6)',
			'iOS 10 and Newer	(iPhone 5 - 5c, iPad 4)',
			'iOS 9 and Newer	(iPhone 4s, iPad 2 - 3, iPad mini 1, iPod touch 5)',
			'iOS 8 and Newer	(Apple TV 3)',
			'iOS 7 and Newer	(iPhone 4, Apple TV 2)',
			'iOS 6 and Newer	(iPhone 3GS, iPod touch 4)',
			'iOS 5 and Newer	(iPad 1, iPod touch 3)',
			'iOS 4 and Newer	(iPhone 3G, iPod touch 2)'
		]

		const versionsKeys = []
		for (const thisVersionDescription of versionDescriptions)
			versionsKeys.push(parseInt(thisVersionDescription.slice(4, 6)))

		app.activate()
		const includeVersionsChooseReply = app.chooseFromList(versionDescriptions,
			{
				withTitle: `${appName} ${settingsOrPreferencesName}  â€”  Include iOS / iPadOS / tvOS Versions`,
				withPrompt: `ðŸ\tWhich iOS / iPadOS / tvOS versions would you like to include?

ðŸ‘‰\tWhen HomePod mini (audioOS), T2 Mac (bridgeOS), or Apple Silicon Mac (macOS)
	are NOT EXCLUDED, their latest IPSW Firmware files will always be downloaded
	regardless of the included iOS / iPadOS / tvOS version selection chosen here
	since there is only a single latest version for each one of those OSes.

âš ï¸\tApple Configurator 2 only supports iOS 7 and newer. Restore older versions using ${isCatalinaOrNewer ? 'Finder' : 'iTunes'}.
\tAlso, older versions of iOS for iPhone 2G (1st Gen) and iPod touch 1 are no longer signed.`,
				defaultItems: versionDescriptions[versionsKeys.indexOf(getPreference('IncludeVersions', 'int'))], // This returned version will always be sanitized to a valid value by "getPreference()".
				okButtonName: 'Save iOS / iPadOS / tvOS Version Selection',
				cancelButtonName: 'Include Every iOS / iPadOS / tvOS Version',
				multipleSelectionsAllowed: false,
				emptySelectionAllowed: false,
			}
		)

		let newIncludedVersions = 1
		if (Array.isArray(includeVersionsChooseReply) && (includeVersionsChooseReply.length == 1))
			newIncludedVersions = versionsKeys[versionDescriptions.indexOf(includeVersionsChooseReply[0])]

		setPreference('IncludeVersions', newIncludedVersions, 'int')
	}

	app.activate()
	try {
		const trashOrDeleteDialogButtons = ['Immediately Delete Outdated Files', 'Trash Outdated Files']
		if (shouldImmediatelyDeleteOutdatedFirmwares) trashOrDeleteDialogButtons.reverse()
		app.displayDialog(`ðŸ—‘\tWould you like outdated IPSW Firmware files to be trashed\n\tor immediately deleted when ${appName} successfully\n\tdownloads updated IPSW Firmware files?

When outdated IPSW Firmware files are set to be trashed, you will need to manually â€œEmpty Trashâ€ in Finder to delete the files and reclaim the disk space, which could be quite a few GBs when lots of IPSW Firmware files are updated.

But, when outdated IPSW Firmware files are set to be deleted immediately, the disk space usage should stay pretty level since each outdated IPSW Firmware file will be deleted automatically when the updated IPSW Firwmare file is downloaded.

Outdated IPSW Firmware files are currently set to be ${shouldImmediatelyDeleteOutdatedFirmwares ? 'immediately deleted' : 'trashed'}.`,
			{
				withTitle: `${appName} ${settingsOrPreferencesName}  â€”  Trash or Delete Outdated Files`,
				withIcon: 'note',
				buttons: trashOrDeleteDialogButtons,
				cancelButton: 1,
				defaultButton: 2,
			}
		)
	} catch (ignoredError) {
		shouldImmediatelyDeleteOutdatedFirmwares = !shouldImmediatelyDeleteOutdatedFirmwares
		setPreference('ImmediatelyDeleteOutdatedFirmwares', shouldImmediatelyDeleteOutdatedFirmwares, 'bool')
	}

	let setAutoLaunchDialogTitle = `â°\tWould you like ${appName} to run\n\tautomatically at a scheduled time?`
	let setAutoLaunchDialogMessage = `If you choose to setup Auto-Launch, you will be prompted to set the days of the week and the time that you would like to run ${appName} automatically.`
	let setAutoLaunchDialogButtons = [`Don't Auto-Launch`, 'Setup Auto-Launchâ€¦']

	const previousAutoLaunchSchedule = parseLaunchAgentSchedule()

	if (previousAutoLaunchSchedule.days.length > 0) {
		const previousAutoWakeSchedules = parseAutoWakePowerEventPreferences()
		const hasStartUpSchedule = (previousAutoWakeSchedules.On && (previousAutoWakeSchedules.On.type == 'wakepoweron') && (previousAutoWakeSchedules.On.minute == (defaultAutoLaunchMinute - 15)))

		const displayAutoLaunchSchedule = createDisplayScheduleFor(previousAutoLaunchSchedule)

		setAutoLaunchDialogTitle = `â°\tWould you like to keep the current Auto-Launch Schedule for ${appName}?`
		setAutoLaunchDialogMessage = `The following Auto-Launch Schedule is currently set:

	${displayAutoLaunchSchedule}${hasStartUpSchedule ? `

If you choose to remove the Auto-Launch schedule, you will be prompted to remove the current Start Up Schedule.` : ''}

If you choose to change the Auto-Launch schedule, you will be prompted to set new days of the week and time.`
		setAutoLaunchDialogButtons = ['Change Auto-Launchâ€¦', `Remove Auto-Launch${hasStartUpSchedule ? 'â€¦' : ''}`, 'Keep Current Auto-Launch']
	}

	let newAutoLaunchDaysArray = []
	let newAutoLaunchHour = previousAutoLaunchSchedule.hour

	app.activate()
	try {
		const setAutoLaunchDialogReply = app.displayDialog(`${setAutoLaunchDialogTitle}

${setAutoLaunchDialogMessage}`,
			{
				withTitle: `${appName} ${settingsOrPreferencesName}  â€”  Auto-Launch`,
				withIcon: 'note',
				buttons: setAutoLaunchDialogButtons,
				cancelButton: (setAutoLaunchDialogButtons.length - 1),
				defaultButton: setAutoLaunchDialogButtons.length
			}
		)

		if (setAutoLaunchDialogReply.buttonReturned == 'Keep Current Auto-Launch')
			newAutoLaunchDaysArray = previousAutoLaunchSchedule.days
		else if ((setAutoLaunchDialogReply.buttonReturned == 'Setup Auto-Launchâ€¦') || (setAutoLaunchDialogReply.buttonReturned == 'Change Auto-Launchâ€¦')) {
			if (previousAutoLaunchSchedule.days.length == 0) previousAutoLaunchSchedule.days = everyDayOfTheWeek
			const previousAutoLaunchDaysWithListDisplayPadding = []
			for (const thisPreviousAutoLaunchScheduleDay of previousAutoLaunchSchedule.days)
				previousAutoLaunchDaysWithListDisplayPadding.push(`${listDisplayPadding}${thisPreviousAutoLaunchScheduleDay}`)

			const everyDayOfTheWeekWithListDisplayPadding = []
			for (const thisDayOfWeek of everyDayOfTheWeek)
				everyDayOfTheWeekWithListDisplayPadding.push(`${listDisplayPadding}${thisDayOfWeek}`)

			app.activate()
			const autoLaunchDaysChooseReply = app.chooseFromList(everyDayOfTheWeekWithListDisplayPadding,
				{
					withTitle: `${appName} ${settingsOrPreferencesName}  â€”  Auto-Launch Days`,
					withPrompt: `â°\tWhat days of the week would you like to Auto-Launch?

Next, you will be prompted to set the time that you'd like to Auto-Launch.

Select Multiple: Click+Drag, Shift+Click, Command+Click`,
					defaultItems: previousAutoLaunchDaysWithListDisplayPadding,
					okButtonName: 'Save Auto-Launch Days Selection',
					cancelButtonName: 'Cancel Auto-Launch',
					multipleSelectionsAllowed: true,
					emptySelectionAllowed: false,
				}
			)

			if (Array.isArray(autoLaunchDaysChooseReply))
				for (const thisChosenAutoLaunchDay of autoLaunchDaysChooseReply)
					newAutoLaunchDaysArray.push(thisChosenAutoLaunchDay.trim())

			if (newAutoLaunchDaysArray.length > 0) {
				const autoLaunch24HourTimes = []
				const autoLaunchAMPMTimes = []
				for (let hour = 0; hour <= 23; hour ++) {
					autoLaunch24HourTimes.push(`${hour}:${defaultAutoLaunchMinute}`)
					autoLaunchAMPMTimes.push(`${listDisplayPadding}${((hour == 0) ? 12 : ((hour > 12) ? (hour - 12) : hour))}:${defaultAutoLaunchMinute} ${((hour < 12) ? 'A' : 'P')}M`)
				}

				let defaultAutoLaunchTime = autoLaunchAMPMTimes[autoLaunch24HourTimes.indexOf(`${defaultAutoLaunchHour}:${defaultAutoLaunchMinute}`)]
				const defaultAutoLaunchTimeIndex = autoLaunch24HourTimes.indexOf(`${previousAutoLaunchSchedule.hour}:${defaultAutoLaunchMinute}`)
				if (defaultAutoLaunchTimeIndex != -1) defaultAutoLaunchTime = autoLaunchAMPMTimes[defaultAutoLaunchTimeIndex]

				app.activate()
				const autoLaunchTimeChooseReply = app.chooseFromList(autoLaunchAMPMTimes,
					{
						withTitle: `${appName} ${settingsOrPreferencesName}  â€”  Auto-Launch Time`,
						withPrompt: `â°\tWhat time ${createDisplayScheduleFor({days: newAutoLaunchDaysArray})} would you like to Auto-Launch?
`,
						defaultItems: [defaultAutoLaunchTime],
						okButtonName: 'Save Auto-Launch Time Selection',
						cancelButtonName: 'Cancel Auto-Launch',
						multipleSelectionsAllowed: false,
						emptySelectionAllowed: false,
					}
				)

				if (Array.isArray(autoLaunchTimeChooseReply)) {
					const selectedAutoLaunchTimeIndex = autoLaunchAMPMTimes.indexOf(autoLaunchTimeChooseReply[0])
					if (selectedAutoLaunchTimeIndex != -1) {
						const selectedAutoLaunchTimeParts = autoLaunch24HourTimes[selectedAutoLaunchTimeIndex].split(':')
						if (selectedAutoLaunchTimeParts.length == 2) {
							newAutoLaunchHour = parseInt(selectedAutoLaunchTimeParts[0])
							if (newAutoLaunchHour < 0) newAutoLaunchHour = 0
							else if (newAutoLaunchHour > 23) newAutoLaunchHour = 23
						}
					}

					if (newAutoLaunchHour == -1) {
						app.beep()
						newAutoLaunchDaysArray = []
					}
				} else
					newAutoLaunchDaysArray = []
			}
		}
	} catch (ignoredError) {
		// Don't Auto-Launch OR Remove Auto-Launch
	}

	createLaunchAgentWithDaysAndHour(newAutoLaunchDaysArray, newAutoLaunchHour) // This function will create, update, or remove the LaunchAgent as needed based on the input and any existing LaunchAgent.

	if (newAutoLaunchDaysArray.length == 0) {
		const currentAutoWakeSchedules = parseAutoWakePowerEventPreferences()
		if (currentAutoWakeSchedules.On && (currentAutoWakeSchedules.On.type == 'wakepoweron') && (currentAutoWakeSchedules.On.minute == (defaultAutoLaunchMinute - 15)))
			promptToRemovePowerSchedule()
	} else {
		if ((createDisplayScheduleFor(parseLaunchAgentSchedule()) != 'Never') && launchAgentIsDisabledOnVenturaOrNewer())
			for ( ; ; ) {
				if ((createDisplayScheduleFor(parseLaunchAgentSchedule()) == 'Never') || !launchAgentIsDisabledOnVenturaOrNewer()) break

				app.activate()
				try {
					app.displayDialog(`â°\tAuto-Launch for ${appName} has been\n\tmanually disabled in ${systemPreferencesOrSettingsName}.

Until Auto-Launch has been manually re-enable in ${systemPreferencesOrSettingsName}, ${appName} WILL NOT be able to automatically launch at the scheduled time (${createDisplayScheduleFor(parseLaunchAgentSchedule())}).

You can manually re-enable Auto-Launch for ${appName} in â€œ${systemPreferencesOrSettingsName}â€ by selecting â€œGeneralâ€ in the list on the left, and then selecting â€œLogin Itemsâ€ in the list on the right, or you can use the button below to go straight to the Login Items in the General ${systemPreferencesOrSettingsName}.

Then, in the â€œAllow in the Backgroundâ€ list in the lower portion of the window, enable the toggle switch to the right of â€œ${appName}â€.`,
						{
							withTitle: `${appName} ${settingsOrPreferencesName}  â€”  Auto-Launch Manually Disabled`,
							withIcon: 'caution',
							buttons: [`Reveal Login Items in General ${systemPreferencesOrSettingsName}`, 'Understood'],
							cancelButton: 1,
							defaultButton: 2
						}
					)

					break
				} catch (ignoredError) {
					try {
						// @ts-ignore: JXA-ObjC
						$.SMAppService.openSystemSettingsLoginItems // https://developer.apple.com/documentation/servicemanagement/smappservice/4013547-opensystemsettingsloginitems?language=objc
					} catch (ignoredError) {
						app.beep()
					}
				}
			}

		const autoLaunchSchedule = parseLaunchAgentSchedule()

		if (autoLaunchSchedule.days && Array.isArray(autoLaunchSchedule.days) && (autoLaunchSchedule.days.length > 0)) {
			const energySaverOrBatteryPaneName = ((isBigSurOrNewer && macHasBattery()) ? 'Battery' : 'Energy Saver') // On macOS 11 Big Sur and newer, separate "Battery" or "Energy Saver" preferences panes exist for laptops (with batteries) vs desktops.
			let shouldShowAutoLoginDialog = false
			let currentAutoWakeSchedules = {}

			const manualPowerScheduleManagementNotes = `${isVenturaOrNewer ?
	`Although, as of macOS 13 Ventura, the interface to manage the Power Schedule has been removed from â€œ${systemPreferencesOrSettingsName}â€ and can now only be modified via the â€œpmsetâ€ command line tool, which is how ${appName} has always modified the Power Schedule when you choose to let it do so through these prompts.

Now that there is no longer an interface in â€œ${systemPreferencesOrSettingsName}â€ for you to change the Power Schedule, you must use the â€œpmsetâ€ command line tool if you want to make any manual changes. To learn how to do that, see the Apple documentation at â€œhttps://support.apple.com/guide/mac-help/schedule-your-mac-to-turn-on-or-off-mchl40376151/13.0/mac/13.0â€ as well as the â€œpmsetâ€ manual by running â€œman pmsetâ€ in Terminal (specificially the â€œpmset repeatâ€ and â€œSCHEDULED EVENT ARGUMENTSâ€ sections). Or, you can use the button below to open both the Apple documentation in your default web browser and the â€œpmsetâ€ manual in Terminal.` :
	`The Power Schedule can be manually managed in the â€œ${energySaverOrBatteryPaneName}â€ section of â€œ${systemPreferencesOrSettingsName}â€ by clicking ${(isMontereyOrNewer || (isBigSurOrNewer && (energySaverOrBatteryPaneName == 'Battery'))) ? 'â€œScheduleâ€ in the list on the left of the window' : 'the â€œScheduleâ€¦â€ button in the bottom right corner of the window'}. You can use the button below to go straight to the Power Schedule in the ${energySaverOrBatteryPaneName} ${systemPreferencesOrSettingsName}.`}`

			for ( ; ; ) {
				const powerScheduleDict = {type: 'wakepoweron', hour: autoLaunchSchedule.hour, minute: (autoLaunchSchedule.minute - 15), days: autoLaunchSchedule.days}
				const displayPowerSchedule = createDisplayScheduleFor(powerScheduleDict)

				currentAutoWakeSchedules = parseAutoWakePowerEventPreferences()

				const proposedSchedulesConflict = hasConflictingPowerSchedules({On: powerScheduleDict, Off: currentAutoWakeSchedules.Off})

				let setPowerScheduleDialogTitle = `ðŸ”Œ\tWould you like to set a Power Schedule to Start Up this Mac 15 minutes before Auto-Launching ${appName}?

This Mac must be turned on and logged in for ${appName} to be able to run at the scheduled time.`

				let setPowerScheduleDialogMessage = `If this Mac gets shut down regularly, it's highly recommended that you set the proposed Start Up Schedule.

It's not an issue if this Mac is set to sleep when inactive since ${appName} will always wake this Mac up when it launches.

You can allow ${appName} to set the following Start Up Schedule for you:

	${displayPowerSchedule}${(currentAutoWakeSchedules.Off ? `

The following ${autoWakeTypeTranslation[currentAutoWakeSchedules.Off.type]} Schedule is currently set and will be preserved:

	${createDisplayScheduleFor(currentAutoWakeSchedules.Off)}${proposedSchedulesConflict ? `
	âš ï¸ Current ${autoWakeTypeTranslation[currentAutoWakeSchedules.Off.type]} Schedule May Conflict with Proposed Start Up Schedule âš ï¸` : ''}` : '')}

If you choose to have ${appName} set the Start Up Schedule for you, you will be prompted for Administrator Permission. Or, you can manually manage the Power Schedule yourself.

${manualPowerScheduleManagementNotes}`

				let setPowerScheduleDialogButtons = [(isVenturaOrNewer ? 'Open Apple Documentation & â€œpmsetâ€ Manual' : `Reveal Schedule in ${energySaverOrBatteryPaneName} ${systemPreferencesOrSettingsName}`), `Don't Set Start Up Schedule`, 'Set Start Up Scheduleâ€¦']
				// The Power Schedule GUI has been REMOVED from the new System Settings in macOS 13 Ventura, so do not include a button to reveal a section that will not exist. Instead, include a button to open directly to the Apple documentation about this and the "pmset" man page.

				let onScheduleName = 'Power Schedule'
				if (currentAutoWakeSchedules.On) {
					const currentSchedulesConflict = hasConflictingPowerSchedules(currentAutoWakeSchedules)

					if (JSON.stringify(currentAutoWakeSchedules.On) == JSON.stringify(powerScheduleDict)) {
						onScheduleName = `${autoWakeTypeTranslation[currentAutoWakeSchedules.On.type]} Schedule`

						setPowerScheduleDialogTitle = `ðŸ”Œ\tWould you like to keep the current Power Schedule to Start Up\n\tthis Mac 15 minutes before Auto-Launching ${appName}?

This Mac must be turned on and logged in for ${appName} to be able to run at the scheduled time.`

						setPowerScheduleDialogMessage = `If this Mac gets shut down regularly, it's highly recommended that you keep the current Start Up Schedule.

It's not an issue if this Mac is set to sleep when inactive since ${appName} will always wake this Mac up when it launches.

This Mac currently has the following Power Schedule set:

	${createDisplayScheduleFor(currentAutoWakeSchedules.On)}${(currentAutoWakeSchedules.Off ? `
	${createDisplayScheduleFor(currentAutoWakeSchedules.Off)} ðŸ“Œ Preserved, but not originally created by ${appName}${currentSchedulesConflict ? `
	âš ï¸ Current ${autoWakeTypeTranslation[currentAutoWakeSchedules.Off.type]} Schedule May Conflict with Current Start Up Schedule âš ï¸` : ''}` : '')}

If you choose to remove the ${onScheduleName}, you will be prompted for final confirmation. Or, you can manually manage the Power Schedule yourself.

${manualPowerScheduleManagementNotes}`

						setPowerScheduleDialogButtons = [(isVenturaOrNewer ? 'Open Apple Documentation & â€œpmsetâ€ Manual' : `Reveal Schedule in ${energySaverOrBatteryPaneName} ${systemPreferencesOrSettingsName}`), `Remove ${onScheduleName}â€¦`, `Keep Current ${onScheduleName}`]
						// The Power Schedule GUI has been REMOVED from the new System Settings in macOS 13 Ventura, so do not include a button to reveal a section that will not exist. Instead, include a button to open directly to the Apple documentation about this and the "pmset" man page.
					} else {
						const powerOffDisplaySchedule = (currentAutoWakeSchedules.Off ? `
	${createDisplayScheduleFor(currentAutoWakeSchedules.Off)}` : '')

						setPowerScheduleDialogTitle = `ðŸ”Œ\tWould you like to replace the current Power Schedule with one that will\n\tStart Up this Mac 15 minutes before Auto-Launching ${appName}?

This Mac must be turned on and logged in for ${appName} to be able to run at the scheduled time.`

						setPowerScheduleDialogMessage = `If this Mac gets shut down regularly, it's highly recommended that you set the proposed Start Up Schedule.

It's not an issue if this Mac is set to sleep when inactive since ${appName} will always wake this Mac up when it launches.

Current Power Schedule:

	${createDisplayScheduleFor(currentAutoWakeSchedules.On)}${powerOffDisplaySchedule}${currentSchedulesConflict ? `
	âš ï¸ Current ${autoWakeTypeTranslation[currentAutoWakeSchedules.Off.type]} Schedule May Conflict with Current Start Up Schedule âš ï¸` : ''}

Proposed Power Schedule:

	${displayPowerSchedule}${(powerOffDisplaySchedule ? `${powerOffDisplaySchedule} ðŸ“Œ Preserved, but not originally created by ${appName}${proposedSchedulesConflict ? `
	âš ï¸ Current ${autoWakeTypeTranslation[currentAutoWakeSchedules.Off.type]} Schedule May Conflict with Proposed Start Up Schedule âš ï¸` : ''}` : '')}

If you choose to replace the current Power Schedule with the proposed Start Up Schedule, you will be prompted for Administrator Permission. Or, you can manually manage the Power Schedule yourself.

${manualPowerScheduleManagementNotes}`

						setPowerScheduleDialogButtons = [(isVenturaOrNewer ? 'Open Apple Documentation & â€œpmsetâ€ Manual' : `Reveal Schedule in ${energySaverOrBatteryPaneName} ${systemPreferencesOrSettingsName}`), `Don't Replace Power Schedule`, 'Replace Power Scheduleâ€¦']
						// The Power Schedule GUI has been REMOVED from the new System Settings in macOS 13 Ventura, so do not include a button to reveal a section that will not exist. Instead, include a button to open directly to the Apple documentation about this and the "pmset" man page.
					}
				}

				app.activate()
				try {
					const setPowerScheduleDialogReply = app.displayDialog(`${setPowerScheduleDialogTitle}

${setPowerScheduleDialogMessage}`,
						{
							withTitle: `${appName} ${settingsOrPreferencesName}  â€”  Power Schedule`,
							withIcon: 'note',
							buttons: setPowerScheduleDialogButtons,
							cancelButton: (setPowerScheduleDialogButtons.length - 1),
							defaultButton: setPowerScheduleDialogButtons.length
						}
					)

					if (setPowerScheduleDialogReply.buttonReturned == `Keep Current ${onScheduleName}`) {
						shouldShowAutoLoginDialog = true

						break
					} else if ((setPowerScheduleDialogReply.buttonReturned == `Reveal Schedule in ${energySaverOrBatteryPaneName} ${systemPreferencesOrSettingsName}`) || (setPowerScheduleDialogReply.buttonReturned == 'Open Apple Documentation & â€œpmsetâ€ Manual')) {
						revealPowerScheduleInSystemPreferences() // This will open Apple documentation and the "pmset" man page when on macOS 13 Ventura.
					} else if ((setPowerScheduleDialogReply.buttonReturned == 'Set Start Up Scheduleâ€¦') || (setPowerScheduleDialogReply.buttonReturned == 'Replace Power Scheduleâ€¦')) {
						try {
							let onDaysForPMSet = ''
							for (const thisPowerScheduleDay of powerScheduleDict.days)
								onDaysForPMSet += daysAsLettersForPMSet[everyDayOfTheWeek.indexOf(thisPowerScheduleDay)]

							const newOnPowerSchedule = `${((powerScheduleDict.type == 'wakepoweron') ? 'wakeorpoweron' : powerScheduleDict.type)} ${onDaysForPMSet} ${powerScheduleDict.hour}:${(powerScheduleDict.minute)}:00`

							const latestAutoWakeSchedules = parseAutoWakePowerEventPreferences()
							let existingOffPowerSchedule = ''
							if (latestAutoWakeSchedules.Off) {
								let offDaysForPMSet = ''
								for (const thisLatestAutoWakeScheduleOffDay of latestAutoWakeSchedules.Off.days)
									offDaysForPMSet += daysAsLettersForPMSet[everyDayOfTheWeek.indexOf(thisLatestAutoWakeScheduleOffDay)]

								existingOffPowerSchedule = ` ${latestAutoWakeSchedules.Off.type} ${offDaysForPMSet} ${latestAutoWakeSchedules.Off.hour}:${(latestAutoWakeSchedules.Off.minute)}:00`
							}

							app.doShellScript(`/usr/bin/pmset repeat ${newOnPowerSchedule}${existingOffPowerSchedule}`,
								{
									administratorPrivileges: true,
									withPrompt: `â€œ${appName}â€ requires Admin Permission to set the following Start Up Schedule:

${displayPowerSchedule}${(latestAutoWakeSchedules.Off ? `


The following ${autoWakeTypeTranslation[latestAutoWakeSchedules.Off.type]} Schedule will be preserved:

${createDisplayScheduleFor(latestAutoWakeSchedules.Off)}` : '')}` // Always include "appName" in admin prompt since the requesting app name IS NOT included in the prompt on macOS 11 Big Sur and older (but it is included in the prompt on macOS 12 Monterey and newer).
								}
							)

							shouldShowAutoLoginDialog = true

							break
						} catch (setPowerScheduleError) {
							debugLog(`Set ${onScheduleName} Error`, setPowerScheduleError)

							if (setPowerScheduleError.errorNumber !== -128) {
								app.activate()
								app.displayAlert(`${appName}: Failed to Set ${onScheduleName}`,
									{
										message: `${setPowerScheduleError.message}

${JSON.stringify(setPowerScheduleError, Object.getOwnPropertyNames(setPowerScheduleError))}`,
										as: 'critical'
									}
								)
							}
						}
					} else {
						app.beep()
						break
					}
				} catch (setPowerScheduleDialogError) {
					if ((setPowerScheduleDialogError.errorNumber === -128) && currentAutoWakeSchedules.On && (JSON.stringify(currentAutoWakeSchedules.On) == JSON.stringify(powerScheduleDict)))
						promptToRemovePowerSchedule()

					break
				}
			}

			// @ts-ignore: JXA-ObjC
			if (shouldShowAutoLoginDialog && (createDisplayScheduleFor(parseAutoWakePowerEventPreferences().On) != 'Never') && ($.NSUserDefaults.alloc.initWithSuiteName('/Library/Preferences/com.apple.loginwindow').stringForKey('autoLoginUser').js != currentUserName))
				for ( ; ; ) {
					// @ts-ignore: JXA-ObjC
					if ((createDisplayScheduleFor(parseAutoWakePowerEventPreferences().On) == 'Never') || ($.NSUserDefaults.alloc.initWithSuiteName('/Library/Preferences/com.apple.loginwindow').stringForKey('autoLoginUser').js == currentUserName)) break

					let shouldRevealLoginOptions = false

					const autoLoginNoteDialogButtons = [`Reveal${isVenturaOrNewer ? '' : ' Login Options in'} Users & Groups ${systemPreferencesOrSettingsName}`, 'Understood']

					currentAutoWakeSchedules = parseAutoWakePowerEventPreferences()
					let removeScheduleName = ''
					if (currentAutoWakeSchedules.On) {
						removeScheduleName = `${autoWakeTypeTranslation[currentAutoWakeSchedules.On.type]} Schedule`
						autoLoginNoteDialogButtons.splice(1, 0, `Remove ${removeScheduleName}â€¦`)
					}

					app.activate()
					try {
						// @ts-ignore: JXA-ObjC
						const autoLoginNoteDialogReply = app.displayDialog(`ðŸ‘¤\tMake sure Automatic Login is enabled for â€œ${$.NSFullUserName().js}â€\n\tso that ${appName} can always run at the scheduled time.

If Automatic Login is disabled, ${appName} won't be able to Auto-Launch when this Mac is turned on by a Start Up Schedule.

You can enable Automatic Login in the â€œUsers & Groupsâ€ section of â€œ${systemPreferencesOrSettingsName}â€${isVenturaOrNewer ? '' : ' by clicking the â€œLogin Optionsâ€ at the bottom of the users list'}, or you can use the button below to go straight to the ${isVenturaOrNewer ? '' : ' Login Options in'} Users & Groups ${systemPreferencesOrSettingsName}.

PLEASE NOTE:
If this Mac has FileVault turned on or an account uses an iCloud password, then Automatic Login cannot be enabled.${(removeScheduleName ? `

If you choose to remove the ${removeScheduleName}, you will be prompted for final confirmation.` : '')}`,
							{
								withTitle: `${appName} ${settingsOrPreferencesName}  â€”  Automatic Login Disabled`,
								withIcon: 'caution',
								buttons: autoLoginNoteDialogButtons,
								cancelButton: (autoLoginNoteDialogButtons.length - 1),
								defaultButton: autoLoginNoteDialogButtons.length
							}
						)

						if (autoLoginNoteDialogReply.buttonReturned == `Reveal${isVenturaOrNewer ? '' : ' Login Options in'} Users & Groups ${systemPreferencesOrSettingsName}`)
							shouldRevealLoginOptions = true
						else
							break
					} catch (autoLoginNoteDialogError) {
						if (autoLoginNoteDialogError.errorNumber === -128) {
							if (currentAutoWakeSchedules.On) {
								promptToRemovePowerSchedule()

								break
							} else
								shouldRevealLoginOptions = true
						} else {
							app.beep()
							break
						}
					}

					if (shouldRevealLoginOptions) {
						try {
							// @ts-ignore: JXA
							const systemPreferencesOrSettingsApp = Application('com.apple.systempreferences')
							systemPreferencesOrSettingsApp.activate()

							if (isVenturaOrNewer)
								// AppleScript support was not been implemented for the new System Settings app in macOS 13 Ventura, but most sections that could previously be opened via
								// AppleScript "reveal" using pane IDs and anchors can now be opened via URL Scheme using the same pane IDs and anchors (and some have updated pane IDs as well).
								// These URL Schemes even work for some sections like this one where the the URL Schemes did not work in previous versions of macOS
								// (which is why AppleScript "reveal" must still be used on previous versions of macOS).
								// Also, the automatic login options are now visible in the main view instead of behind another section, so the "loginOptionsPref" anchor no longer exists and is not needed
								// (but could still have been accessed by adding "?loginOptionsPref" to the end of the URL Scheme if it was needed).
								// The old pane ID of "com.apple.preferences.users" still works on macOS 13 Ventura, but use the new ID of "com.apple.Users-Groups-Settings.extension" to make sure this is
								// future-proof if the old pane ID ever stops working in a future version of macOS (https://github.com/bvanpeski/SystemPreferences/blob/main/macos_preferencepanes-Ventura.md#users--groups).

								// @ts-ignore: JXA-ObjC
								sharedWorkspace.openURL($.NSURL.URLWithString('x-apple.systempreferences:com.apple.Users-Groups-Settings.extension'))
							else
								systemPreferencesOrSettingsApp.panes.byId('com.apple.preferences.users').anchors.byName('loginOptionsPref').reveal()

							systemPreferencesOrSettingsApp.activate()
						} catch (ignoredError) {
							app.beep()
						}
					}
				}

			for ( ; ; ) {
				const conflictingPowerSchedules = hasConflictingPowerSchedules()
				if (conflictingPowerSchedules) {
					const conflictingOnScheduleName = `${autoWakeTypeTranslation[conflictingPowerSchedules.On.type]} Schedule`
					const conflictingOnDisplaySchedule = createDisplayScheduleFor(conflictingPowerSchedules.On)

					const conflictingOffScheduleName = `${autoWakeTypeTranslation[conflictingPowerSchedules.Off.type]} Schedule`
					const conflictingOffDisplaySchedule = createDisplayScheduleFor(conflictingPowerSchedules.Off)

					app.activate()
					try {
						const conflictingPowerScheduleDialogReply = app.displayDialog(`ðŸ”Œ\tThis Mac's current ${conflictingOffScheduleName} may conflict with the current ${conflictingOnScheduleName}.

This Mac currently has the following Power Schedule set:

	${conflictingOnDisplaySchedule}
	${conflictingOffDisplaySchedule}

This could cause ${appName} to not be able to finish updating your IPSW Firmware files properly when it's Auto-Launched.

To solve this conflict, you can allow ${appName} to completely remove the conflicting ${conflictingOffScheduleName} using the button below. Or, you can manually manage the Power Schedule yourself.

${manualPowerScheduleManagementNotes}`,
							{
								withTitle: `${appName} ${settingsOrPreferencesName}  â€”  Power Schedule Conflict`,
								withIcon: 'caution',
								buttons: [(isVenturaOrNewer ? 'Open Apple Documentation & â€œpmsetâ€ Manual' : `Reveal Schedule in ${energySaverOrBatteryPaneName} ${systemPreferencesOrSettingsName}`), `Leave Conflicting ${conflictingOffScheduleName} Alone`, `Remove Conflicting ${conflictingOffScheduleName}â€¦`], // The Power Schedule GUI has been REMOVED from the new System Settings in macOS 13 Ventura, so do not include a button to reveal a section that will not exist. Instead, include a button to open directly to the Apple documentation about this and the "pmset" man page.
								cancelButton: 2,
								defaultButton: 3
							}
						)

						if (conflictingPowerScheduleDialogReply.buttonReturned == `Remove Conflicting ${conflictingOffScheduleName}â€¦`) {
							if (conflictingPowerSchedules.On) {
								let onDaysForPMSet = ''
								for (const thisConflictingAutoWakeScheduleOnDay of conflictingPowerSchedules.On.days)
									onDaysForPMSet += daysAsLettersForPMSet[everyDayOfTheWeek.indexOf(thisConflictingAutoWakeScheduleOnDay)]

								try {
									app.doShellScript(`/usr/bin/pmset repeat wakeorpoweron ${onDaysForPMSet} ${conflictingPowerSchedules.On.hour}:${(conflictingPowerSchedules.On.minute)}:00`,
										{
											administratorPrivileges: true,
											withPrompt: `â€œ${appName}â€ requires Admin Permission to REMOVE the following CONFLICTING ${conflictingOffScheduleName}:

${conflictingOffDisplaySchedule}


The following ${conflictingOnScheduleName} will be preserved:

${conflictingOnDisplaySchedule}` // Always include "appName" in admin prompt since the requesting app name IS NOT included in the prompt on macOS 11 Big Sur and older (but it is included in the prompt on macOS 12 Monterey and newer).
										}
									)

									break
								} catch (removeConflictingPowerScheduleError) {
									debugLog(`Remove Conflicting ${conflictingOffScheduleName} Error`, removeConflictingPowerScheduleError)

									if (removeConflictingPowerScheduleError.errorNumber !== -128) {
										app.activate()
										app.displayAlert(`${appName}: Failed to Remove Conflicting ${conflictingOffScheduleName}`,
											{
												message: `${removeConflictingPowerScheduleError.message}

${JSON.stringify(removeConflictingPowerScheduleError, Object.getOwnPropertyNames(removeConflictingPowerScheduleError))}`,
												as: 'critical'
											}
										)
									}
								}
							} else {
								app.beep()
								break
							}
						} else
							revealPowerScheduleInSystemPreferences() // This will open Apple documentation and the "pmset" man page when on macOS 13 Ventura.
					} catch (ignoredError) {
						break // Leave Conflicting Power Schedule Alone
					}
				} else
					break
			}
		} else {
			app.activate()
			app.displayAlert(`${appName}: Failed to Set Auto-Launch Schedule`,
				{
					message: 'Restart your computer and then try again.',
					as: 'critical'
				}
			)
		}
	}
}

function promptToRemovePowerSchedule() {
	for ( ; ; ) {
		const currentAutoWakeSchedules = parseAutoWakePowerEventPreferences()

		if (currentAutoWakeSchedules.On) {
			const removeScheduleName = `${autoWakeTypeTranslation[currentAutoWakeSchedules.On.type]} Schedule`

			app.activate()
			try {
				app.displayDialog(`ðŸ”Œ\tRemove the current ${removeScheduleName} for this Mac?

This Mac currently has the following Power Schedule set:

${createDisplayScheduleFor(currentAutoWakeSchedules.On)}${(currentAutoWakeSchedules.Off ? `
${createDisplayScheduleFor(currentAutoWakeSchedules.Off)}

PLEASE NOTE:
The ${autoWakeTypeTranslation[currentAutoWakeSchedules.Off.type]} Schedule will not be removed if you choose remove the ${removeScheduleName}.` : '')}

If you choose to remove the ${removeScheduleName}, you will be prompted for Administrator Permission.`,
					{
						withTitle: `${appName} ${settingsOrPreferencesName}  â€”  Remove ${removeScheduleName}`,
						withIcon: 'note',
						buttons: [`Keep Current ${removeScheduleName}`, `Remove ${removeScheduleName}â€¦`],
						cancelButton: 1,
						defaultButton: 2
					}
				)

				const latestAutoWakeSchedules = parseAutoWakePowerEventPreferences()
				if (latestAutoWakeSchedules.On) {
					let existingOffPowerSchedule = ''
					if (latestAutoWakeSchedules.Off) {
						let offDaysForPMSet = ''
						for (const thisLatestAutoWakeScheduleOffDay of latestAutoWakeSchedules.Off.days)
							offDaysForPMSet += daysAsLettersForPMSet[everyDayOfTheWeek.indexOf(thisLatestAutoWakeScheduleOffDay)]

						existingOffPowerSchedule = `${latestAutoWakeSchedules.Off.type} ${offDaysForPMSet} ${latestAutoWakeSchedules.Off.hour}:${(latestAutoWakeSchedules.Off.minute)}:00`
					}

					try {
						app.doShellScript(`/usr/bin/pmset repeat ${existingOffPowerSchedule || 'cancel'}`,
							{
								administratorPrivileges: true,
								withPrompt: `â€œ${appName}â€ requires Admin Permission to REMOVE the following ${removeScheduleName}:

${createDisplayScheduleFor(latestAutoWakeSchedules.On)}${(latestAutoWakeSchedules.Off ? `


The following ${autoWakeTypeTranslation[latestAutoWakeSchedules.Off.type]} Schedule will be preserved:

${createDisplayScheduleFor(latestAutoWakeSchedules.Off)}` : '')}` // Always include "appName" in admin prompt since the requesting app name IS NOT included in the prompt on macOS 11 Big Sur and older (but it is included in the prompt on macOS 12 Monterey and newer).
							}
						)

						break
					} catch (removePowerScheduleError) {
						debugLog(`Remove ${removeScheduleName} Error`, removePowerScheduleError)

						if (removePowerScheduleError.errorNumber !== -128) {
							app.activate()
							app.displayAlert(`${appName}: Failed to Remove ${removeScheduleName}`,
								{
									message: `${removePowerScheduleError.message}

${JSON.stringify(removePowerScheduleError, Object.getOwnPropertyNames(removePowerScheduleError))}`,
									as: 'critical'
								}
							)
						}
					}
				} else {
					app.beep()
					break
				}
			} catch (ignoredError) {
				break // Keep Current Power Schedule
			}
		} else {
			app.beep()
			break
		}
	}
}

function hasConflictingPowerSchedules(latestAutoWakeSchedules = parseAutoWakePowerEventPreferences()) {
	if (latestAutoWakeSchedules.Off && latestAutoWakeSchedules.On &&
		(typeof latestAutoWakeSchedules.Off.type === 'string') && (typeof latestAutoWakeSchedules.On.type === 'string') &&
		((latestAutoWakeSchedules.Off.type == 'shutdown') || (latestAutoWakeSchedules.Off.type == 'restart')) &&
		(latestAutoWakeSchedules.On.type == 'wakepoweron') &&
		(typeof latestAutoWakeSchedules.On.minute === 'number') &&
		(latestAutoWakeSchedules.On.minute == (defaultAutoLaunchMinute - 15)) &&
		Array.isArray(latestAutoWakeSchedules.Off.days) && (latestAutoWakeSchedules.Off.days.length > 0) &&
		Array.isArray(latestAutoWakeSchedules.On.days) && (latestAutoWakeSchedules.On.days.length > 0))
		for (const thisLatestAutoWakeScheduleOffDay of latestAutoWakeSchedules.Off.days)
			if (latestAutoWakeSchedules.On.days.includes(thisLatestAutoWakeScheduleOffDay) &&
				(typeof latestAutoWakeSchedules.Off.hour === 'number') && (typeof latestAutoWakeSchedules.On.hour === 'number') &&
				(latestAutoWakeSchedules.Off.hour >= latestAutoWakeSchedules.On.hour) &&
				(latestAutoWakeSchedules.Off.hour <= (latestAutoWakeSchedules.On.hour + 2)))
				return latestAutoWakeSchedules

	return undefined
}

function createDisplayScheduleFor(eventDict) {
	if ((eventDict !== undefined) && (typeof eventDict === 'object') && Array.isArray(eventDict.days) && (eventDict.days.length > 0)) {
		let displayReturnString = ''

		if ((typeof eventDict.type === 'string')) {
			const eventTypeName = autoWakeTypeTranslation[eventDict.type]
			if (eventTypeName) displayReturnString += `${eventTypeName}: `
		}

		displayReturnString += 'Every '

		const JSONdaysString = JSON.stringify(eventDict.days)

		if (JSONdaysString == JSON.stringify(everyDayOfTheWeek))
			displayReturnString += 'Day'
		else if (JSONdaysString == '["Saturday","Sunday"]')
			displayReturnString += 'Weekend'
		else if (JSONdaysString == '["Monday","Tuesday","Wednesday","Thursday","Friday"]')
			displayReturnString += 'Weekday'
		else if (eventDict.days.length <= 2)
			displayReturnString += eventDict.days.join(' and ')
		else
			displayReturnString += `${eventDict.days.slice(0, -1).join(', ')}, and ${eventDict.days.slice(-1)[0]}`

		if ((typeof eventDict.hour === 'number') && (typeof eventDict.minute === 'number'))
			displayReturnString += ` @ ${((eventDict.hour == 0) ? 12 : ((eventDict.hour > 12) ? (eventDict.hour - 12) : eventDict.hour))}:${eventDict.minute.toString().padStart(2, '0')} ${((eventDict.hour < 12) ? 'A' : 'P')}M`

		return displayReturnString
	}

	return 'Never'
}

function parseLaunchAgentSchedule() {
	/** @type {{hour: number, minute: number, days: string[]}} */
	const returnAutoLaunchSchedule = {hour: defaultAutoLaunchHour, minute: defaultAutoLaunchMinute, days: []}

	if (!fileManager.fileExistsAtPath(launchAgentPlistPath)) return returnAutoLaunchSchedule

	let launchAgentScheduleArray = []
	try {
		// @ts-ignore: JXA-ObjC
		const parseLaunchAgentPlistFileError = $()
		// @ts-ignore: JXA-ObjC
		const launchAgentPlistDict = $.NSDictionary.dictionaryWithContentsOfURLError($.NSURL.fileURLWithPath(launchAgentPlistPath), parseLaunchAgentPlistFileError)
		if (!parseLaunchAgentPlistFileError.isNil()) throw new Error(parseLaunchAgentPlistFileError.description.js)
		// @ts-ignore: JXA-ObjC
		launchAgentScheduleArray = ObjC.deepUnwrap(launchAgentPlistDict.objectForKey('StartCalendarInterval'))
		if (launchAgentScheduleArray === undefined) throw new Error('No "StartCalendarInterval" Specified')
		if (typeof launchAgentScheduleArray != 'object') throw new Error('INVALID "StartCalendarInterval" Specified')
	} catch (readLaunchAgentPlistError) {
		debugLog('Read Schedule From LaunchAgent PLIST Error', readLaunchAgentPlistError)

		return returnAutoLaunchSchedule
	}

	if (!Array.isArray(launchAgentScheduleArray)) launchAgentScheduleArray = [launchAgentScheduleArray] // Could be a dict if only one day is specified, so wrap it in an array for consistency for the following code.

	const launchAgentDayInts = []

	for (const thisLaunchAgentScheduleDict of launchAgentScheduleArray)
		if (thisLaunchAgentScheduleDict.hasOwnProperty('Hour') && thisLaunchAgentScheduleDict.hasOwnProperty('Minute')) {
			returnAutoLaunchSchedule.hour = +thisLaunchAgentScheduleDict.Hour
			returnAutoLaunchSchedule.minute = +thisLaunchAgentScheduleDict.Minute

			if (thisLaunchAgentScheduleDict.hasOwnProperty('Weekday')) // Weekday won't be specified if every day of the week is intended.
				launchAgentDayInts.push(+thisLaunchAgentScheduleDict.Weekday)
		}

	if (launchAgentDayInts.length == 0)
		returnAutoLaunchSchedule.days = everyDayOfTheWeek
	else {
		const everyDayOfTheWeekStartingAndEndingWithSunday = everyDayOfTheWeek.slice(-1).concat(everyDayOfTheWeek)

		for (let dayIndex = 0; dayIndex < everyDayOfTheWeekStartingAndEndingWithSunday.length; dayIndex ++) {
			const thisDayOfTheWeek = everyDayOfTheWeekStartingAndEndingWithSunday[dayIndex]
			if (launchAgentDayInts.includes(dayIndex) && !returnAutoLaunchSchedule.days.includes(thisDayOfTheWeek))
				returnAutoLaunchSchedule.days.push(thisDayOfTheWeek)
		}

		if ((returnAutoLaunchSchedule.days.length > 1) && (returnAutoLaunchSchedule.days[0] == 'Sunday')) {
			returnAutoLaunchSchedule.days.shift()
			returnAutoLaunchSchedule.days.push('Sunday')
		}
	}

	return returnAutoLaunchSchedule
}

function createLaunchAgentWithDaysAndHour(newAutoLaunchDaysArray, newAutoLaunchHour) {
	if (newAutoLaunchDaysArray.length > 0) {
		// NOTE: The following LaunchAgent dictionary specifies a "Launch IPSW Updater" script which is created and SIGNED by the "Build IPSW Updater.applescript" script.
		// This script MUST be signed so that the "AssociatedBundleIdentifier" key can be used in macOS 13 Ventura so that the LaunchAgent is properly displayed as being for the "IPSW Updater" app.
		// This is because the executable in the LaunchAgent MUST have a Code Signing Team ID that matches the Team ID of the app Bundle ID specified in the "AssociatedBundleIdentifiers" key (as described in https://developer.apple.com/documentation/servicemanagement/updating_helper_executables_from_earlier_versions_of_macos?language=objc#4065210).
		// DO NOT want to have the LaunchAgent just run the "IPSW Updater" app binary directly because if the app is launched that way via the LaunchAgent and then the LaunchAgent is removed during that execution the app will be terminated immediately when "launchctl bootout" is run.
		// That issue has always been avoided by using the "/usr/bin/open" binary to launch the app instead. But using "/usr/bin/open" directly in the LaunchAgent on macOS 13 Ventura makes it show as just running "open" from an unidentified developer in the new Login Items list, which may seem suspicious or confusing.
		// Making this simple SIGNED "Launch IPSW Updater" script which just runs "/usr/bin/open" with the path to the app and then using the "AssociatedBundleIdentifiers" allows the LaunchAgent to be properly displayed as being for the "IPSW Updater" app.
		// When on macOS 12 Monterey and older, the "AssociatedBundleIdentifiers" will just be ignored and the "Launch IPSW Updater" will function the same as if "/usr/bin/open" was directly specified with the path to the app in the LaunchAgent.
		// Search for "AssociatedBundleIdentifiers" in the "Build IPSW Updater.applescript" script to see the "Launch IPSW Updater" script creation and signing code.

		// ALSO NOTE: Manually creating the LaunchAgent plist in this way is considered to be a "Legacy LaunchAgent" as of macOS 13 Ventura: https://developer.apple.com/documentation/servicemanagement/updating_helper_executables_from_earlier_versions_of_macos?language=objc
		// But, the new modern LaunchAgent and LaunchDaemon setup requires that the plist be pre-made and included within the app contents.
		// That is not easily feasible for the needs of this use-case where the user can dynamically choose the day(s) and time that they want the app to be launched.
		// It would techinically be possible pre-make and include every possible LaunchAgent plist and enable the correct one based on the users choice, but that would be hundreds of possible plists.
		// Continuing to create a "Legacy LaunchAgent" by making the LaunchAgent plist dynamically based on the user input and using the "AssociatedBundleIdentifiers" key as described above to properly associate it with the "IPSW Updater" app makes the most sense as long as this "Legacy LaunchAgent" technique continues to work and be allowed by macOS.

		const launchAgentDict = {
			Label: bundleIdentifier,
			Program: `${appPath}/Contents/Resources/Launch ${appName}`,
			AssociatedBundleIdentifiers: bundleIdentifier,
			RunAtLoad: false,
			StandardOutPath: '/dev/null',
			StandardErrorPath: '/dev/null'
		}

		// NOTE: If the following numbers for the LaunchAgent plist are left as JS ints,
		// they will be set to "real" types instead of "integer" types when the
		// dictionary is wrapped to an NSDictionary and written as a plist.
		// So, explicitly wrapping them into NSNumbers solves that.

		// @ts-ignore: JXA-ObjC
		const newAutoLaunchHourNumber = $.NSNumber.numberWithInt(newAutoLaunchHour)
		// @ts-ignore: JXA-ObjC
		const defaultAutoLaunchMinuteNumber = $.NSNumber.numberWithInt(defaultAutoLaunchMinute)

		if (JSON.stringify(newAutoLaunchDaysArray) == JSON.stringify(everyDayOfTheWeek))
			launchAgentDict.StartCalendarInterval = {
				Hour: newAutoLaunchHourNumber,
				Minute: defaultAutoLaunchMinuteNumber
			}
		else if (newAutoLaunchDaysArray.length == 1)
			launchAgentDict.StartCalendarInterval = {
				Hour: newAutoLaunchHourNumber,
				Minute: defaultAutoLaunchMinuteNumber,
				// @ts-ignore: JXA-ObjC
				Weekday: $.NSNumber.numberWithInt(everyDayOfTheWeek.indexOf(newAutoLaunchDaysArray[0]) + 1)
			}
		else {
			launchAgentDict.StartCalendarInterval = []

			for (const thisNewAutoLaunchDay of newAutoLaunchDaysArray)
				launchAgentDict.StartCalendarInterval.push({
					Hour: newAutoLaunchHourNumber,
					Minute: defaultAutoLaunchMinuteNumber,
					// @ts-ignore: JXA-ObjC
					Weekday: $.NSNumber.numberWithInt(everyDayOfTheWeek.indexOf(thisNewAutoLaunchDay) + 1)
				})
		}

		let needsToWriteLaunchAgentPlistFile = true
		if (fileManager.fileExistsAtPath(launchAgentPlistPath)) {
			try {
				// @ts-ignore: JXA-ObjC
				const readCurrentLaunchAgentPlistFileError = $()
				// @ts-ignore: JXA-ObjC
				const currentLaunchAgentPlistContents = $.NSString.stringWithContentsOfFileEncodingError(launchAgentPlistPath, $.NSUTF8StringEncoding, readCurrentLaunchAgentPlistFileError).js
				if (!readCurrentLaunchAgentPlistFileError.isNil()) throw new Error(readCurrentLaunchAgentPlistFileError.description.js)

				// @ts-ignore: JXA-ObjC
				const parseNewLaunchAgentPlistContentsError = $()
				// @ts-ignore: JXA-ObjC
				const newLaunchAgentPlistContents = $.NSString.alloc.initWithDataEncoding($.NSPropertyListSerialization.dataWithPropertyListFormatOptionsError($(launchAgentDict), $.NSPropertyListXMLFormat_v1_0, 0, parseNewLaunchAgentPlistContentsError), $.NSUTF8StringEncoding).js
				if (!parseNewLaunchAgentPlistContentsError.isNil()) throw new Error(parseNewLaunchAgentPlistContentsError.description.js)

				needsToWriteLaunchAgentPlistFile = (currentLaunchAgentPlistContents != newLaunchAgentPlistContents)
			} catch (readLaunchAgentPlistError) {
				debugLog('Read LaunchAgent Plist Error', readLaunchAgentPlistError)
			}

			if (needsToWriteLaunchAgentPlistFile) {
				try {
					app.doShellScript(`/bin/launchctl bootout ${quoteForShell(`gui/${currentUserID}/${bundleIdentifier}`)}`)
				} catch (bootoutLaunchAgentError) {
					debugLog('Bootout LaunchAgent Error', bootoutLaunchAgentError)
				}

				// @ts-ignore: JXA-ObjC
				try { fileManager.removeItemAtPathError(launchAgentPlistPath, $()) } catch (ignoredError) { /* Ignore */ }
			}
		} else if (!fileManager.fileExistsAtPath(launchAgentsPath))
			// @ts-ignore: JXA-ObjC
			fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(launchAgentsPath, true, {}, $())

		if (needsToWriteLaunchAgentPlistFile)
			try {
				// @ts-ignore: JXA-ObjC
				const writeLaunchAgentToFileError = $()
				// @ts-ignore: JXA-ObjC
				if ($(launchAgentDict).writeToURLError($.NSURL.fileURLWithPath(launchAgentPlistPath), writeLaunchAgentToFileError))
					try {
						app.doShellScript(`/bin/launchctl bootstrap ${quoteForShell(`gui/${currentUserID}`)} ${quoteForShell(launchAgentPlistPath)}`)
					} catch (bootstrapLaunchAgentError) {
						debugLog('Bootstrap LaunchAgent Error', bootstrapLaunchAgentError)
					}
				else {
					if (!writeLaunchAgentToFileError.isNil()) throw new Error(writeLaunchAgentToFileError.description.js)
					throw new Error('Write LaunchAgent Dict to PLIST Failed')
				}
			} catch (writeLaunchAgentPlistError) {
				debugLog('Write LaunchAgent PLIST Error', writeLaunchAgentPlistError)
			}
	} else {
		try { app.doShellScript(`/bin/launchctl bootout ${quoteForShell(`gui/${currentUserID}/${bundleIdentifier}`)}`) } catch (ignoredError) { /* Ignore */ }

		// @ts-ignore: JXA-ObjC
		try { fileManager.removeItemAtPathError(launchAgentPlistPath, $()) } catch (ignoredError) { /* Ignore */ }
	}
}

function launchAgentIsDisabledOnVenturaOrNewer() {
	if (isVenturaOrNewer) {
		// Check whether our "Legacy LaunchAgent" has been manually disabled in "System Settings" on macOS 13 Ventura: https://developer.apple.com/documentation/servicemanagement/updating_helper_executables_from_earlier_versions_of_macos?language=objc#4031315
		// The "SMAppServiceStatus" constants (https://developer.apple.com/documentation/servicemanagement/smappservicestatus?language=objc) returned by "statusForLegacyURL" HAVE NOT been bridged to JXA,
		// but through testing on macOS 13 Ventura, I found that "statusForLegacyURL" returns unwrapped JS string values for each "SMAppServiceStatus" constant with the following values:
			// SMAppServiceStatusNotRegistered = "0" (This status is returned when the LaunchAgent plist does not exist.)
			// SMAppServiceStatusEnabled = "1" (This status is returned when the LaunchAgent is enabled, which it should be by default after initial creation.)
			// SMAppServiceStatusRequiresApproval = "2" (This status is returned when the LaunchAgent has been manually disabled in System Settings.)
			// SMAppServiceStatusNotFound = "3" (This status seems to sometimes be returned for a moment after the LaunchAgent is created and boostrapped. See comments below for more information.)

		let launchAgentStatus = '-1'
		for (let waitForLaunchAgentStatus = 0; waitForLaunchAgentStatus < 15; waitForLaunchAgentStatus ++) {
			// I have noticed that right after the LaunchAgent plist has been created and boostrapped, "statusForLegacyURL" may return "3" (SMAppServiceStatusNotFound) for a moment (usually less than half a second) before returning the actual LaunchAgent status.
			// So, wait for UP TO 3 seconds (in 0.2 second increments) for any status value which is not "3" (SMAppServiceStatusNotFound) since this function is only be called when we know the LaunchAgent plist file exists and should have a status of "1" (or "2" when manually disabled).

			try {
				// @ts-ignore: JXA-ObjC
				launchAgentStatus = $.SMAppService.statusForLegacyURL($.NSURL.fileURLWithPath(launchAgentPlistPath)) // https://developer.apple.com/documentation/servicemanagement/smappservice/4024717-statusforlegacyurl?language=objc
			} catch (ignoredError) { /* Ignore */ }

			if (launchAgentStatus === '3')
				debugLog('LaunchAgent WAITING FOR STATUS')
			else
				break

			// @ts-ignore: JXA
			delay(0.2)
		}

		const launchAgentIsDisabled = (launchAgentStatus !== '1')
		if (launchAgentIsDisabled) debugLog('LaunchAgent DISABLED', launchAgentStatus)

		return launchAgentIsDisabled
	}

	return false
}

function parseAutoWakePowerEventPreferences() {
	const returnPowerEvents = {}

	let autoWakePrefsDict = {}
	try {
		// @ts-ignore: JXA-ObjC
		const readAutoWakePrefsError = $()
		// @ts-ignore: JXA-ObjC
		autoWakePrefsDict = ObjC.deepUnwrap($.NSPropertyListSerialization.propertyListWithDataOptionsFormatError($(app.doShellScript('/usr/bin/defaults export /Library/Preferences/SystemConfiguration/com.apple.AutoWake -')).dataUsingEncoding($.NSUTF8StringEncoding), $.NSPropertyListImmutable, null, readAutoWakePrefsError))
		// NOTE: For some reason trying to retrieve the "RepeatingPowerOn" or "RepeatingPowerOff" keys via ObjC with the following NSUserDefaults method does not return anything, but other keys do work.
		// $.NSUserDefaults.alloc.initWithSuiteName('/Library/Preferences/SystemConfiguration/com.apple.AutoWake').dictionaryForKey('RepeatingPowerOn')
		// So, must just shell out to "defaults export" instead and then create an "NSDictionary" from those contents so that the preferences are properly retrieved through cfprefsd-aware techniques.
		if (!readAutoWakePrefsError.isNil()) throw new Error(readAutoWakePrefsError.description.js)
	} catch (loadAutoWakePrefsError) {
		debugLog('Load AutoWake Prefs Error', loadAutoWakePrefsError)
	}

	if (autoWakePrefsDict && (autoWakePrefsDict.hasOwnProperty('RepeatingPowerOn') || autoWakePrefsDict.hasOwnProperty('RepeatingPowerOff'))) {
		const powerEventOnOrOff = ['On', 'Off']
		const reverseDays = ['Sunday', 'Saturday', 'Friday', 'Thursday', 'Wednesday', 'Tuesday', 'Monday']
		const intsForReverseDays = [64, 32, 16, 8, 4, 2, 1]

		for (const thisPowerEventOnOrOff of powerEventOnOrOff) {
			const thisRepeatingPowerOnOrOffDict = autoWakePrefsDict[`RepeatingPower${thisPowerEventOnOrOff}`]
			if (thisRepeatingPowerOnOrOffDict && thisRepeatingPowerOnOrOffDict.hasOwnProperty('time') && thisRepeatingPowerOnOrOffDict.hasOwnProperty('weekdays') && thisRepeatingPowerOnOrOffDict.hasOwnProperty('eventtype')) {
				const repeatingPowerTimeInt = thisRepeatingPowerOnOrOffDict.time
				const repeatingPowerTimeMinute = (repeatingPowerTimeInt % 60)
				const repeatingPowerTimeHour = ((repeatingPowerTimeInt - repeatingPowerTimeMinute) / 60)

				const repeatingPowerDays = []
				let repeatingPowerWeekdaysInt = thisRepeatingPowerOnOrOffDict.weekdays
				for (let dayIndex = 0; dayIndex < reverseDays.length; dayIndex ++) {
					const thisDayInt = intsForReverseDays[dayIndex]
					if (repeatingPowerWeekdaysInt >= thisDayInt) {
						repeatingPowerDays.unshift(reverseDays[dayIndex])
						repeatingPowerWeekdaysInt -= thisDayInt
					}
				}

				returnPowerEvents[thisPowerEventOnOrOff] = {}
				returnPowerEvents[thisPowerEventOnOrOff].type = thisRepeatingPowerOnOrOffDict.eventtype
				returnPowerEvents[thisPowerEventOnOrOff].hour = repeatingPowerTimeHour
				returnPowerEvents[thisPowerEventOnOrOff].minute = repeatingPowerTimeMinute
				returnPowerEvents[thisPowerEventOnOrOff].days = repeatingPowerDays
			}
		}
	}

	return returnPowerEvents
}

function macHasBattery() {
	// On Intel desktops "ioreg -arc AppleSmartBattery" will return nothing, and on all laptops it will always return an array even if no battery is currently connected/installed.
	// But, on Apple Silicon desktops, it will return the same kind of dictionary as a laptop with no battery currently connected/installed.
	// The following code checks the returned dictionary to see if a battery is installed to properly handle Apple Silicon desktops as well as laptops *with no battery installed*
	// since they will also show the Energy Saver preferences pane, like a desktop does instead of the Battery pane on macOS 11 Big Sur and newer.
	// Errors are totally ignored since it is expected for the following check to error on an Intel desktop, which will then correctly return "false" when the battery check fails for any reason.

	try {
		// @ts-ignore: JXA-ObjC
		return (ObjC.deepUnwrap($.NSPropertyListSerialization.propertyListWithDataOptionsFormatError($(app.doShellScript('/usr/sbin/ioreg -arc AppleSmartBattery')).dataUsingEncoding($.NSUTF8StringEncoding), $.NSPropertyListImmutable, null, $()))[0].BatteryInstalled === true)
	} catch (ignoredError) { /* Ignore */ }

	return false
}

function revealPowerScheduleInSystemPreferences() {
	if (isVenturaOrNewer) { // The Power Schedule GUI has been REMOVED from the new System Settings in macOS 13 Ventura, and can now only be editing using the CLI "pmset repeat" command (see Apple documentation link that is opened below for more info).
		// @ts-ignore: JXA-ObjC
		sharedWorkspace.openURL($.NSURL.URLWithString('https://support.apple.com/guide/mac-help/schedule-your-mac-to-turn-on-or-off-mchl40376151/13.0/mac/13.0'))
		// @ts-ignore: JXA-ObjC
		sharedWorkspace.openURL($.NSURL.URLWithString('x-man-page://pmset'))
	} else {
		let powerSchedulePaneID = 'com.apple.preference.energysaver' // On macOS 10.15 Catalina and older, the Energy Saver preferences pane exists for both laptops and desktops and on macOS 11 Big Sur, the Energy Saver preferences pane still exists for desktops.
		let powerScheduleAnchor = 'Schedule'

		if (isBigSurOrNewer) { // On macOS 11 Big Sur and newer, separate Battery or Energy Saver preferences panes exist for laptops (with batteries) vs desktops.
			if (macHasBattery()) {
				powerSchedulePaneID = 'com.apple.preference.battery'
				powerScheduleAnchor = 'schedule'// Notice this anchor has a lowercased "s" for this new Battery pane.
			} else if (isMontereyOrNewer) {
				// In macOS 12 Monterey, the Energy Saver pane for desktops was re-designed to match the style of the Battery pane and has a new pane ID.
				powerSchedulePaneID = 'com.apple.preferences.EnergySaverPrefPane'
				powerScheduleAnchor = 'schedule'// Notice this anchor has a lowercased "s" for this new Energy Saver pane.
			}
		}

		try {
			// @ts-ignore: JXA
			const systemPreferencesOrSettingsApp = Application('com.apple.systempreferences')
			systemPreferencesOrSettingsApp.activate()
			systemPreferencesOrSettingsApp.panes.byId(powerSchedulePaneID).anchors.byName(powerScheduleAnchor).reveal()
			systemPreferencesOrSettingsApp.activate()
		} catch (ignoredError) {
			app.beep()
		}
	}
}

function quoteForShell(unquotedString, onlyEscape = false) {
	const escapedString = unquotedString.replace(/'/g, "'\\''")
	return (onlyEscape ? escapedString : `'${escapedString}'`)
}

function quoteForAppleScript(unquotedString, onlyEscape = false) {
	const escapedString = unquotedString.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
	return (onlyEscape ? escapedString : `"${escapedString}"`)
}

function getPreference(key, intendedType = 'string', isReattempt = false) {
	let returnPreferenceValue = undefined

	if (key !== undefined) {
		try {
			if (intendedType == 'url') {
				returnPreferenceValue = standardUserDefaults.URLForKey(key).absoluteString.js
				if (typeof returnPreferenceValue != 'string')
					throw new Error(`URL Preference Value is "${typeof returnPreferenceValue}" instead of "string"`)
			} else if (intendedType == 'array') {
				// @ts-ignore: JXA-ObjC
				returnPreferenceValue = ObjC.deepUnwrap(standardUserDefaults.arrayForKey(key))
				if (!Array.isArray(returnPreferenceValue))
					throw new Error(`Array Preference Value is not "array"`)
			} else if (intendedType == 'dict') {
				// @ts-ignore: JXA-ObjC
				returnPreferenceValue = ObjC.deepUnwrap(standardUserDefaults.dictionaryForKey(key))
				if (typeof returnPreferenceValue != 'object')
					throw new Error(`Dict Preference Value is "${typeof returnPreferenceValue}" instead of "object"`)
			} else if (intendedType == 'string') {
				returnPreferenceValue = standardUserDefaults.stringForKey(key).js
				if (typeof returnPreferenceValue != 'string')
					throw new Error(`String Preference Value is "${typeof returnPreferenceValue}" instead of "string"`)
			} else if (intendedType == 'string array') {
				// @ts-ignore: JXA-ObjC
				returnPreferenceValue = ObjC.deepUnwrap(standardUserDefaults.stringArrayForKey(key))
				if (!Array.isArray(returnPreferenceValue))
					throw new Error(`String Array Preference Value is not "array"`)
			} else if (intendedType == 'data')
				returnPreferenceValue = standardUserDefaults.dataForKey(key)
			else if (intendedType == 'bool') {
				returnPreferenceValue = standardUserDefaults.boolForKey(key) // DO NOT ".js" unwrap boolean since it's already unwrapped and will be undefined if ".js" is used.
				if (typeof returnPreferenceValue != 'boolean')
					throw new Error(`Bool Preference Value is "${typeof returnPreferenceValue}" instead of "bool"`)
			} else if (intendedType == 'int') {
				returnPreferenceValue = parseInt(standardUserDefaults.integerForKey(key)) // DO NOT ".js" unwrap integer since it's already unwrapped and will be undefined if ".js" is used.
				if (typeof returnPreferenceValue != 'number')
					throw new Error(`Int Preference Value is "${typeof returnPreferenceValue}" instead of "number"`)
			} else if (intendedType == 'float') {
				returnPreferenceValue = parseFloat(standardUserDefaults.floatForKey(key)) // DO NOT ".js" unwrap float since it's already unwrapped and will be undefined if ".js" is used.
				if (typeof returnPreferenceValue != 'number')
					throw new Error(`Float Preference Value is "${typeof returnPreferenceValue}" instead of "number"`)
			} else if (intendedType == 'double') {
				returnPreferenceValue = parseFloat(standardUserDefaults.doubleForKey(key)) // DO NOT ".js" unwrap double since it's already unwrapped and will be undefined if ".js" is used.
				if (typeof returnPreferenceValue != 'number')
					throw new Error(`Double Preference Value is "${typeof returnPreferenceValue}" instead of "number"`)
			} else
				// @ts-ignore: JXA-ObjC
				returnPreferenceValue = ObjC.deepUnwrap(standardUserDefaults.objectForKey(key))
		} catch (getPreferenceError) {
			debugLog(`GET Preference Error (${key}, ${intendedType}): ${returnPreferenceValue}`, getPreferenceError)

			if (!isReattempt && (returnPreferenceValue !== undefined)) { // Do not reattempt if the the preference key already doesn't exist.
				try { standardUserDefaults.removeObjectForKey(key) } catch (ignoredError) { /* Ignore */ }

				debugLog(`DELETED Preference ${key} & Reattempting GET`)

				return getPreference(key, intendedType, true)
			}

			returnPreferenceValue = undefined
		}
	}

	if (key == 'IncludeVersions') {
		if (!returnPreferenceValue || (returnPreferenceValue <= 0)) returnPreferenceValue = 7 // Default to iOS 7 if no value or a negative (invalid) value is set.
		else if (returnPreferenceValue < 4) returnPreferenceValue = 4 // iOS 4 supports the same devices as iOS 1 through iOS 3, except for the iPhone 2G (1st Gen) and iPod touch 1 which supported iOS 3 but that's no longer signed.
		else if (returnPreferenceValue == 11) returnPreferenceValue = 12 // iOS 12 supports the same devices as iOS 11.
		else if ((returnPreferenceValue == 13) || (returnPreferenceValue == 14)) returnPreferenceValue = 15 // iOS 15 supports the same devices as iOS 13 and iOS 14.
		else if (returnPreferenceValue > 16) returnPreferenceValue = 16 // iOS 16 is the latest version at this time (and the newest version listed in the "versionDescriptions" array).
	} else if ((returnPreferenceValue !== undefined) && (key == 'ExcludeProducts')) {
		const validatedExcludedProducts = []
		for (const thisProductType of everyProductType)
			if (returnPreferenceValue.includes(thisProductType))
				validatedExcludedProducts.push(thisProductType)

		returnPreferenceValue = validatedExcludedProducts
	}

	return returnPreferenceValue
}

function setPreference(key, value, type = 'string') {
	if ((key !== undefined) && (value !== undefined))
		try {
			if (type == 'url')
				// @ts-ignore: JXA-ObjC
				standardUserDefaults.setURLForKey($.NSURL.URLWithString(value), key)
			else if (type == 'bool')
				standardUserDefaults.setBoolForKey(value, key)
			else if (type == 'int')
				standardUserDefaults.setIntegerForKey(value, key)
			else if (type == 'float')
				standardUserDefaults.setFloatForKey(value, key)
			else if (type == 'double')
				standardUserDefaults.setDoubleForKey(value, key)
			else
				standardUserDefaults.setObjectForKey(value, key)

			return true
		} catch (setPreferenceError) {
			debugLog(`SET Preference Error (${key}, ${value}, ${type})`, setPreferenceError)
			return false
		}

	return false
}

function debugLog(message, error) {
	if (message !== undefined) {
		if (typeof message == 'object')
			message = JSON.stringify(message, null, 4)

		let displayError = ''
		if (error !== undefined) {
			displayError = ': '
			if (error.message) displayError += error.message
			if (typeof error == 'object') displayError += ` - ${JSON.stringify(error, Object.getOwnPropertyNames(error))}`
			else displayError += error
		}

		// @ts-ignore: JXA-ObjC
		$.NSLog(`DEBUG - ${message}${displayError}`)
	}
}

/** @param {*} message, @param {string} title */
function debugDialog(message = 'UNDEFINED', title = 'DEBUG') {
	if (!title.startsWith('DEBUG')) title = `DEBUG: ${title}`
	if (typeof message == 'object') message = JSON.stringify(message, (Object.getOwnPropertyNames(message).includes('stack') ? Object.getOwnPropertyNames(message) : null), 4) // Check if object properties contains "stack" to determine if it's an error object that needs its properties specified in "JSON.stringify()".

	app.activate()
	app.displayDialog(title,
		{
			defaultAnswer: message,
			buttons: ['Quit', 'Continue'],
			cancelButton: 1,
			defaultButton: 2
		}
	)
}

function cleanUpBeforeQuitting() {
	// CANNOT use the "quit()" handler (https://developer.apple.com/library/archive/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW15)
	// because it appears to not get run when the "quit()" function is loaded via "eval()" like it would be if it was included in this code.
	// For the "quit()" handler to work properly, it must exist in the main script when it is first loaded.
	// So, instead just call this "cleanUpBeforeQuitting()" function manually at the very end of this script to behave the same as the automatic "quit()" handler would.

	debugLog('Quittingâ€¦')

	if (curlPIDs.length > 0)
		try { app.doShellScript(`kill ${curlPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }

	if (appIsQuarantined) {
		let appPaths = []
		try { appPaths = app.doShellScript(`/usr/bin/mdfind kMDItemCFBundleIdentifier = ${bundleIdentifier}`).split(/\n|\r/) } catch (ignoredError) { /* Ignore */ }

		if (appPaths.length > 0)
			app.doShellScript(`/usr/bin/osascript -e ${quoteForShell(`
delay 0.5
repeat while (application ${quoteForAppleScript(appPath)} is running)
	delay 0.5
end repeat
try
	do shell script "/usr/bin/xattr -drs com.apple.quarantine " & ${appPaths.map(thisAppPath => `(quoted form of ${quoteForAppleScript(thisAppPath)})`).join(' & " " & ')}
end try
`)} > /dev/null 2>&1 &`)
	}

	// @ts-ignore: JXA-ObjC
	try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }
}

function cleanUpAndQuitEarly() {
	cleanUpBeforeQuitting()
	app.quit() // Even if the JXA "quit()" handler could be used, it would NOT get called when "app.quit()" is run manually, so the handler would have to be called manually before running "app.quit()" anyways.
}

cleanUpBeforeQuitting() // Call "cleanUpBeforeQuitting()" manually at the end of the script since getting here would indicate a graceful quit, and can't use the JXA "quit()" handler (as described in the "cleanUpBeforeQuitting()" comments).
