//
// Created by Pico Mitchell (of Free Geek)
//
// https://ipsw.app
// https://github.com/freegeek-pdx/IPSW-Updater
//
// Uses: IPSW Downloads API (https://ipsw.me) by Callum Jones (https://ipsw.me/about)
// Icon: ‚ÄúPhone with Arrow‚Äù from Fluent Emoji (https://github.com/microsoft/fluentui-emoji) by Microsoft (https://opensource.microsoft.com)
//       licensed under the MIT License (https://github.com/microsoft/fluentui-emoji/blob/main/LICENSE)
//
// MIT License
//
// Copyright (c) 2022 Free Geek
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

// NOTES:
// "use strict" is set and "AppKit" is imported in "main.scpt".
// "LSMinimumSystemVersion" is set to 10.13 in "Build IPSW Updater" (make sure to only use ECMAScript 2018 features, which is what macOS 10.13 High Sierra supports).
// 10.12.2+ Compatible Emoji List: https://emojipedia.org/apple/ios-10.2/ (To make sure that only emoji that are available on at least macOS 10.13 High Sierra are used.)
// Emoji Used: üõë‚öôÔ∏èüö´üóë‚è∞üîåüë§‚úÖüîÑ‚öñÔ∏èüîçüì≤‚è≥‚åõÔ∏è‚è≠Ô∏èüçè‚Ü©Ô∏è‚Ü™Ô∏èüóìüí§‚ö†Ô∏è‚ùåüëâüìù‚§¥Ô∏èüëç‚è±Ô∏èüìåüìè

// @ts-nocheck: Do not check for TypeScript errors since there's a lot of JXA and JXA-ObjC code that would incorrectly show errors.

const appVersion = '2025.10.21-1'

ObjC.import('unistd') // For "getuid" function.
ObjC.import('Security') // For "SecStaticCodeCheckValidity" and other functions for code signature validation.

const app = a // "Application.currentApplication()" is set to "a" and "a.includeStandardAdditions" is set to "true" in "main.scpt" which runs this script via "exec()".
const appBundle = ab // "$.NSBundle.mainBundle" is set to "ab" in "main.scpt" which runs this script via "exec()".
let appPath = ap // "ab.bundlePath.js" is set to "ap" in "main.scpt" which runs this script via "exec()".

wakeMacUp()

const appName = appBundle.objectForInfoDictionaryKey('CFBundleName').js
const bundleExecutableName = appBundle.objectForInfoDictionaryKey('CFBundleExecutable').js

const fileManager = $.NSFileManager.defaultManager

if (!fileManager.fileExistsAtPath(`${appPath}/Contents/MacOS/${bundleExecutableName}`) || !fileManager.fileExistsAtPath(`${appPath}/Contents/Resources/Scripts/main.scpt`) || !fileManager.fileExistsAtPath(`${appPath}/Contents/Resources/Launch ${bundleExecutableName}`)) {
	debugLog('App Check Error', appPath)

	while (!macIsAwakeAndUnlocked()) // AppleScript dialogs will timeout early if Mac is asleep when it's displayed. So, wait until Mac is awake to display the dialog.
		delay(15)

	try {
		app.activate()
		app.displayAlert(`${appName}: App Check Error`,
			{
				message: `${appName} must be run as an application.`,
				as: 'critical',
				buttons: ['Quit', `Re-Download ‚Äú${appName}‚Äù`],
				cancelButton: 1,
				defaultButton: 2
			}
		)

		app.doShellScript('/usr/bin/open https://ipsw.app/download/')
	} catch (ignoredError) { /* Ignore */ }

	app.quit()
}

const bundleIdentifier = appBundle.bundleIdentifier.js
const intendedBundleIdentifier = `org.freegeek.${bundleExecutableName.replace(/ /g, '-')}`
if (bundleIdentifier != intendedBundleIdentifier) {
	debugLog('Incorrect Bundle Identifier Error', bundleIdentifier)

	while (!macIsAwakeAndUnlocked()) // AppleScript dialogs will timeout early if Mac is asleep when it's displayed. So, wait until Mac is awake to display the dialog.
		delay(15)

	try {
		app.activate()
		app.displayAlert(`${appName}: Bundle Identifier Error`,
			{
				message: `Intended Bundle Identifier:
${intendedBundleIdentifier}

Actual Bundle Identifier:
${bundleIdentifier}`,
				as: 'critical',
				buttons: ['Quit', `Re-Download ‚Äú${appName}‚Äù`],
				cancelButton: 1,
				defaultButton: 2
			}
		)

		app.doShellScript('/usr/bin/open https://ipsw.app/download/')
	} catch (ignoredError) { /* Ignore */ }

	app.quit()
}

const infoDictVersion = appBundle.objectForInfoDictionaryKey('CFBundleShortVersionString').js
if (infoDictVersion != appVersion) {
	debugLog(`Incorrect App Version Error: ${infoDictVersion} != ${appVersion}`)

	while (!macIsAwakeAndUnlocked()) // AppleScript dialogs will timeout early if Mac is asleep when it's displayed. So, wait until Mac is awake to display the dialog.
		delay(15)

	try {
		app.activate()
		app.displayAlert(`${appName}: App Version Error`,
			{
				message: `Intended App Version:
${appVersion}

Actual App Version:
${infoDictVersion}`,
				as: 'critical',
				buttons: ['Quit', `Re-Download ‚Äú${appName}‚Äù`],
				cancelButton: 1,
				defaultButton: 2
			}
		)

		app.doShellScript('/usr/bin/open https://ipsw.app/download/')
	} catch (ignoredError) { /* Ignore */ }

	app.quit()
}

const processInfo = $.NSProcessInfo.processInfo
const isMojaveOrNewer = processInfo.isOperatingSystemAtLeastVersion({majorVersion: 10, minorVersion: 14, patchVersion: 0})
const isCatalinaOrNewer = processInfo.isOperatingSystemAtLeastVersion({majorVersion: 10, minorVersion: 15, patchVersion: 0})
const isBigSurOrNewer = processInfo.isOperatingSystemAtLeastVersion({majorVersion: 11, minorVersion: 0, patchVersion: 0})
const isMontereyOrNewer = processInfo.isOperatingSystemAtLeastVersion({majorVersion: 12, minorVersion: 0, patchVersion: 0})
const isVenturaOrNewer = processInfo.isOperatingSystemAtLeastVersion({majorVersion: 13, minorVersion: 0, patchVersion: 0})
const isSonomaOrNewer = processInfo.isOperatingSystemAtLeastVersion({majorVersion: 14, minorVersion: 0, patchVersion: 0})
const isSequoiaOrNewer = processInfo.isOperatingSystemAtLeastVersion({majorVersion: 15, minorVersion: 0, patchVersion: 0})
const isTahoeOrNewer = processInfo.isOperatingSystemAtLeastVersion({majorVersion: 16, minorVersion: 0, patchVersion: 0})

try {
	// IMPORTANT: On each launch, confirm the running app is properly signed (and notarized, when possible on macOS 10.14 Mojave and newer).
	// See comments in the "validateCodeSignatureForAppAtPath" function for more information.
	validateCodeSignatureForAppAtPath(appPath) // NOTE: This function with "throw" an error if validation fails which will be caught and displayed below.
} catch (codeSignatureValidationError) {
	debugLog('Code Signature Error', codeSignatureValidationError)

	while (!macIsAwakeAndUnlocked()) // AppleScript dialogs will timeout early if Mac is asleep when it's displayed. So, wait until Mac is awake to display the dialog.
		delay(15)

	try {
		app.activate()
		app.displayAlert(`${appName}: Code Signature Error`,
			{
				message: codeSignatureValidationError.message,
				as: 'critical',
				buttons: ['Quit', `Re-Download ‚Äú${appName}‚Äù`],
				cancelButton: 1,
				defaultButton: 2
			}
		)

		app.doShellScript('/usr/bin/open https://ipsw.app/download/')
	} catch (ignoredError) { /* Ignore */ }

	app.quit()
}

if (isVenturaOrNewer) {
	ObjC.import('ServiceManagement') // For "SMAppService" to check if the LaunchAgent is enabled on macOS 13 Ventura (see comments in "launchAgentIsDisabledOnVenturaOrNewer()" function for more information).
}

const mainMenu = $.NSApp.mainMenu
try { mainMenu.removeItem(mainMenu.itemWithTitle('File')) } catch (ignoredError) { /* Ignore */ }

try {
	const appMenu = mainMenu.itemWithTitle('applet').submenu
	try {
		const preferencesMenuItem = appMenu.itemWithTitle('Preferences‚Ä¶')
		if (!preferencesMenuItem.isNil()) appMenu.removeItem(preferencesMenuItem)
		else if (isVenturaOrNewer) appMenu.removeItem(appMenu.itemWithTitle('Settings‚Ä¶')) // This menu item will be "Settings‚Ä¶" instead of "Preferences‚Ä¶" when built with and running on macOS 13 Ventura.
	} catch (ignoredError) { /* Ignore */ }
	try { appMenu.removeItem(appMenu.itemWithTitle(`Quit ${appName}`)) } catch (ignoredError) { /* Ignore */ }
	try {
		// NOTE: This "Quit and Keep Windows" menu item (which is the alternate menu item for the "Quit" menu item, accessed by holding the Option key)
		// will only be created and therefore only need to be remove IF the app menu was opened BEFORE this code had a chance to run,
		// which isn't super likely but can still happen so it should still always be checked and removed if it exists.
		const quitAndKeepWindowsMenuItem = appMenu.itemWithTitle('Quit and Keep Windows')
		if (!quitAndKeepWindowsMenuItem.isNil()) appMenu.removeItem(quitAndKeepWindowsMenuItem) // Check if isn't nil before removing since it might not exist and "removeItem" will log an error if nil is passed to it.
	} catch (ignoredError) { /* Ignore */ }
} catch (ignoredError) { /* Ignore */ }

try {
	const editMenu = mainMenu.itemWithTitle('Edit').submenu
	try { editMenu.removeItem(editMenu.itemWithTitle('Edit Script')) } catch (ignoredError) { /* Ignore */ }
} catch (ignoredError) { /* Ignore */ }

const currentUserName = $.NSUserName().js
const currentUserID = $.getuid()

const standardUserDefaults = $.NSUserDefaults.standardUserDefaults
standardUserDefaults.registerDefaults({
	RefusedMoveToApplications: false,
	FirstRun: true,
	AppJustAutoUpdated: false,
	AppUpdateAvailable: false,
	ExcludeProducts: [],
	IncludeVersions: 15,
	ManagedFirmwares: {},
	FirmwareUpdatesAvailable: 0,
	AcknowledgedSignificantResults: true,
	ImmediatelyDeleteOutdatedFirmwares: false,
	DeleteAppleConfiguratorTemporaryFiles: false,
	ForceDialogWindowStyle: false
})

let uuid = getPreference('UUID', 'string')
if (!uuid) {
	uuid = $.NSUUID.UUID.UUIDString.js
	setPreference('UUID', uuid, 'string')
}

const sharedWorkspace = $.NSWorkspace.sharedWorkspace

const settingsOrPreferencesName = (isVenturaOrNewer ? 'Settings' : 'Preferences')
const systemPreferencesOrSettingsName = `System ${settingsOrPreferencesName}`

const backgroundPIDs = [] // Save background PIDs as they are spawned to be able kill them all when an error is caught or before quitting just in case any are left behind before being removed from this list after they are known to not be running anymore.

const applicationSupportFolder = `${fileManager.URLsForDirectoryInDomains($.NSApplicationSupportDirectory, $.NSUserDomainMask).firstObject.path.js}/${appName}`
if (!fileManager.fileExistsAtPath(applicationSupportFolder))
	fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(applicationSupportFolder, true, {}, $())

const temporaryFilesFolder = `${applicationSupportFolder}/Temporary Files`

const userTrashPath = fileManager.URLsForDirectoryInDomains($.NSTrashDirectory, $.NSUserDomainMask).firstObject.path.js

const appIsQuarantined = (appPath.includes('/AppTranslocation/') || app.doShellScript(`/usr/bin/xattr ${quoteForShell(appPath)}`).includes('com.apple.quarantine'))

let appPaths = []
try { appPaths = app.doShellScript(`/usr/bin/mdfind kMDItemCFBundleIdentifier = ${bundleIdentifier}`).split(/\n|\r/) } catch (ignoredError) { /* Ignore */ }

let parentDirectoryToMe = $(appPath).stringByDeletingLastPathComponent.js
if (appPath.includes('/AppTranslocation/')) {
	let mostRecentlyOpenedAppPath = appPath
	let mostRecentlyOpenedAppDate = new Date('1984-01-24')
	for (const thisAppPath of appPaths)
		try {
			if (!thisAppPath.includes('/AppTranslocation/')) {
				let appLastUsedDateString = app.doShellScript(`/usr/bin/mdls -raw -name kMDItemLastUsedDate ${quoteForShell(thisAppPath)}`)

				// kMDItemLastUsedDate will be "(null)" if it was never launched (which would happen when launching a quarantined app), so lets check the date added.
				if (!appLastUsedDateString || (appLastUsedDateString == '(null)'))
					appLastUsedDateString = app.doShellScript(`/usr/bin/mdls -raw -name kMDItemDateAdded ${quoteForShell(thisAppPath)}`)

				const appLastUsedDate = new Date(appLastUsedDateString.slice(0, -6).replace(' ', 'T'))

				if (appLastUsedDate > mostRecentlyOpenedAppDate) {
					mostRecentlyOpenedAppDate = appLastUsedDate
					mostRecentlyOpenedAppPath = thisAppPath
				}
			}
		} catch (ignoredError) { /* Ignore */ }

	if (appPath != mostRecentlyOpenedAppPath) {
		appPath = mostRecentlyOpenedAppPath
		parentDirectoryToMe = $(appPath).stringByDeletingLastPathComponent.js
	}
}

try {
	// Set Touch Bar settings to NOT be "App Controls" for this Bundle ID because AppleScript alert and dialog buttons don't update properly on the Touch Bar.
	const touchBarPrefs = $.NSUserDefaults.alloc.initWithSuiteName('com.apple.touchbar.agent')
	const touchBarPrefsPresentationModePerAppDict = $.NSMutableDictionary.dictionaryWithDictionary(touchBarPrefs.dictionaryForKey('PresentationModePerApp'))
	if (touchBarPrefsPresentationModePerAppDict.objectForKey(bundleIdentifier).js != 'fullControlStrip') {
		touchBarPrefsPresentationModePerAppDict.setObjectForKey('fullControlStrip', bundleIdentifier)
		touchBarPrefs.setObjectForKey(touchBarPrefsPresentationModePerAppDict, 'PresentationModePerApp')
	}
} catch (ignoredError) { /* Ignore */ }

// Always "killall ControlStrip" even if PresentationModePerApp was set on a previous launch
// because for some reason the setting won't take effect until the app loses and regains focus,
// or if I just go ahead and "killall ControlStrip" right away.
try { app.doShellScript('/usr/bin/killall ControlStrip') } catch (ignoredError) { /* Ignore */ }

if (!getPreference('RefusedMoveToApplications', 'bool') && !appPath.startsWith('/Applications/')) {
	while (!macIsAwakeAndUnlocked()) // AppleScript dialogs will timeout early if Mac is asleep when it's displayed. So, wait until Mac is awake to display the dialog.
		delay(15)

	delay(0.5)

	app.activate()

	try {
		let parentDirectoryName = fileManager.displayNameAtPath(parentDirectoryToMe).js

		if (parentDirectoryToMe.endsWith('/Applications')) parentDirectoryName = 'User Applications'

		const moveToApplicationsDialogButtons = [
			((appPath.includes('/AppTranslocation/') || (parentDirectoryName == 'UNKNOWN')) ? 'No, Run from Current Folder' : `No, Run from ‚Äú${parentDirectoryName}‚Äù Folder`),
			'Reveal in Finder & Quit',
			'Yes, Move to ‚ÄúApplications‚Äù Folder'
		]

		const moveToApplicationsDialogReply = displayAlertOrDialogDependingOnOS(`${appName} is not properly installed in the ‚ÄúApplications‚Äù folder.

Would you like ${appName} to move itself to the ‚ÄúApplications‚Äù folder?`,
			`${((appPath.includes('/AppTranslocation/') || (parentDirectoryName == 'UNKNOWN')) ? '' : `${appName} is currently running from within the ‚Äú${parentDirectoryName}‚Äù folder: ${parentDirectoryToMe}/

`)}Like all applications, ${appName} should be run from within the ‚ÄúApplications‚Äù folder.`,
			`${appName}  ‚Äî  Install Application`,
			'caution',
			moveToApplicationsDialogButtons,
			2,
			3
		)

		if (moveToApplicationsDialogReply.buttonReturned == moveToApplicationsDialogButtons[2]) {
			if (!fileManager.fileExistsAtPath(temporaryFilesFolder))
				fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(temporaryFilesFolder, true, {}, $())

			const appFileName = $(appPath).lastPathComponent.js

			const moveToApplicationsFolderScript = `/usr/bin/osascript -e ${quoteForShell(`
use AppleScript version "2.7"
use scripting additions
use framework "Foundation"

set currentAppFilePath to ${quoteForAppleScript(appPath)}

delay 0.5
repeat while (application currentAppFilePath is running)
	delay 0.5
end repeat
${((appIsQuarantined && (appPaths.length > 0)) ? `
try
	do shell script "/usr/bin/xattr -drs com.apple.quarantine " & ${appPaths.map(thisAppPath => `(quoted form of ${quoteForAppleScript(thisAppPath)})`).join(' & " " & ')}
end try
` : '')}
set appInTempFolder to ${quoteForAppleScript(`${temporaryFilesFolder}/${appFileName}`)}

set systemApplicationsFolder to (POSIX path of (path to applications folder from system domain))
set appInSystemApplicationsFolder to (systemApplicationsFolder & ${quoteForAppleScript(appFileName)})
set actualInstallFilePath to appInSystemApplicationsFolder

set userApplicationsFolder to (POSIX path of (path to applications folder from user domain))
set appInUserApplicationsFolder to (userApplicationsFolder & ${quoteForAppleScript(appFileName)})

set userDownloadsFolder to (POSIX path of (path to downloads folder from user domain))
set appInUserDownloadsFolder to (userDownloadsFolder & ${quoteForAppleScript(appFileName)})

set adminPermissionPrompt to "‚Äú${quoteForAppleScript(appName, true)}‚Äù requires Admin Permission to move itself to the ‚ÄúApplications‚Äù folder."

try
	set appOriginalFileStructure to ""
	try
		set appOriginalFileStructure to (do shell script ("cd " & (quoted form of currentAppFilePath) & " && /bin/ls -Rsk"))
	end try

	set fileManager to (defaultManager of NSFileManager of current application)

	try
		if (fileExistsAtPath_(appInTempFolder) of fileManager) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInTempFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInTempFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInTempFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((fileExistsAtPath_(currentAppFilePath) of fileManager) and (not (fileExistsAtPath_(appInTempFolder) of fileManager))) then moveItemAtPath_toPath_error_(currentAppFilePath, appInTempFolder, missing value) of fileManager -- This fails when currentAppFilePath is in /AppTranslocation/
	end try
	try
		if ((fileExistsAtPath_(appInUserDownloadsFolder) of fileManager) and (not (fileExistsAtPath_(appInTempFolder) of fileManager))) then moveItemAtPath_toPath_error_(appInUserDownloadsFolder, appInTempFolder, missing value) of fileManager -- Fall back on this even though its not the best assumption.
	end try
	try
		if ((fileExistsAtPath_(currentAppFilePath) of fileManager) and (not (fileExistsAtPath_(appInTempFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of currentAppFilePath) & " " & (quoted form of appInTempFolder) with prompt adminPermissionPrompt with administrator privileges -- This fails when currentAppFilePath is in /AppTranslocation/
	end try
	if ((fileExistsAtPath_(appInUserDownloadsFolder) of fileManager) and (not (fileExistsAtPath_(appInTempFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appInUserDownloadsFolder) & " " & (quoted form of appInTempFolder) with prompt adminPermissionPrompt with administrator privileges -- Fall back on this even though its not the best assumption.
${(appIsQuarantined ? `
	try
		if (fileExistsAtPath_(appInTempFolder) of fileManager) then do shell script "/usr/bin/xattr -drs com.apple.quarantine " & (quoted form of appInTempFolder)
	end try
` : '')}
	try
		if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInSystemApplicationsFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInSystemApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInUserApplicationsFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInUserApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInUserDownloadsFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInUserDownloadsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (not (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager))) then
			moveItemAtPath_toPath_error_(appInTempFolder, appInSystemApplicationsFolder, missing value) of fileManager
			if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (not (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appInTempFolder) & " " & (quoted form of appInSystemApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (not (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager))) then
			moveItemAtPath_toPath_error_(appInTempFolder, appInUserApplicationsFolder, missing value) of fileManager
			if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (not (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appInTempFolder) & " " & (quoted form of appInUserApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
			set actualInstallFilePath to appInUserApplicationsFolder
		end if
	end try

	if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (not (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager))) then
		moveItemAtPath_toPath_error_(appInTempFolder, appInUserDownloadsFolder, missing value) of fileManager
		if ((fileExistsAtPath_(appInTempFolder) of fileManager) and (not (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appInTempFolder) & " " & (quoted form of appInUserDownloadsFolder) with prompt adminPermissionPrompt with administrator privileges
		set actualInstallFilePath to appInUserDownloadsFolder
	end if

	if (fileExistsAtPath_(actualInstallFilePath) of fileManager) then
		-- When working auto-updating for MacLand Scripts, Catalina seems to fail to launch if done too quickly after a move (with an "executable not found" error).
		-- Generating the install path file structure alone seems to delay enough to avoid the issue, but this loop makes it extra safe.

		repeat 30 times
			try
				set installAppFileStructure to ""
				try
					set installAppFileStructure to (do shell script ("cd " & (quoted form of actualInstallFilePath) & " && /bin/ls -Rsk"))
				on error
					try
						set installAppFileStructure to (do shell script ("cd " & (quoted form of actualInstallFilePath) & " && /bin/ls -Rsk") with prompt adminPermissionPrompt with administrator privileges)
					on error
						exit repeat
					end try
				end try
				if (appOriginalFileStructure is equal to installAppFileStructure) then exit repeat
			end try
			delay 0.5
		end repeat
	end if
on error moveError
	activate
	beep
	display alert "Error Moving ‚Äú${quoteForAppleScript(appName, true)}‚Äù to ‚ÄúApplications‚Äù Folder" message moveError as critical
end try
do shell script "/bin/rm -rf " & (quoted form of ${quoteForAppleScript(temporaryFilesFolder)})
try
	do shell script "/usr/bin/open -na " & (quoted form of actualInstallFilePath)
on error
	try
		do shell script "/usr/bin/open -na " & (quoted form of currentAppFilePath)
	on error
		try
			do shell script "/usr/bin/open -nb ${bundleIdentifier}"
		on error launchError
			activate
			beep
			display alert "Error Re-Launching ‚Äú${quoteForAppleScript(appName, true)}‚Äù\nAfter Moving to ‚ÄúApplications‚Äù Folder" message launchError buttons {"Quit", "Re-Download ‚Äú${quoteForAppleScript(appName, true)}‚Äù"} cancel button 1 default button 2 as critical
			do shell script "/usr/bin/open 'https://ipsw.app/download/'"
		end try
	end try
end try
`)} > /dev/null 2>&1 &`

			//debugDialog(moveToApplicationsFolderScript.replace(/\/usr\/bin\/osascript -e '|' > \/dev\/null 2>&1 &/g, '').replace(/'\\''/g, "'").trim())
			//debugDialog(app.doShellScript(moveToApplicationsFolderScript.replace('/usr/bin/osascript -e ', "printf '%s' ").replace(' > /dev/null 2>&1 &', '')).trim())

			app.doShellScript(moveToApplicationsFolderScript)

			app.quit()
		} else if (moveToApplicationsDialogReply.buttonReturned == moveToApplicationsDialogButtons[0]) {
			setPreference('RefusedMoveToApplications', true, 'bool')

			if (appIsQuarantined && (appPaths.length > 0)) {
				app.doShellScript(`/usr/bin/osascript -e ${quoteForShell(`
delay 0.5
repeat while (application ${quoteForAppleScript(appPath)} is running)
	delay 0.5
end repeat
try
	do shell script "/usr/bin/xattr -drs com.apple.quarantine " & ${appPaths.map(thisAppPath => `(quoted form of ${quoteForAppleScript(thisAppPath)})`).join(' & " " & ')}
end try
try
	do shell script "/usr/bin/open -na " & (quoted form of ${quoteForAppleScript(appPath)})
on error
	try
		do shell script "/usr/bin/open -nb ${bundleIdentifier}"
	end try
end try
`)} > /dev/null 2>&1 &`)

				app.quit()
			}
		}
	} catch (moveToApplicationsError) {
		if (moveToApplicationsError.errorNumber !== -128)
			debugLog('Move to Applications Folder Error', moveToApplicationsError)

		if (appPath.includes('/AppTranslocation/'))
			app.beep()
		else
			try { sharedWorkspace.activateFileViewerSelectingURLs($.NSArray.arrayWithObject($.NSURL.fileURLWithPath(appPath))) } catch (ignoredError) { app.beep() }

		if (appIsQuarantined && (appPaths.length > 0))
			app.doShellScript(`/usr/bin/osascript -e ${quoteForShell(`
delay 0.5
repeat while (application ${quoteForAppleScript(appPath)} is running)
	delay 0.5
end repeat
try
	do shell script "/usr/bin/xattr -drs com.apple.quarantine " & ${appPaths.map(thisAppPath => `(quoted form of ${quoteForAppleScript(thisAppPath)})`).join(' & " " & ')}
end try
`)} > /dev/null 2>&1 &`)

		if (moveToApplicationsError.errorNumber !== -128)
			throw moveToApplicationsError
		else
			app.quit()
	}
}

let justInstalledUpdate = getPreference('AppJustAutoUpdated', 'bool')
if (justInstalledUpdate) setPreference('AppJustAutoUpdated', false, 'bool')

let lastInstall = getPreference('LastAppInstall', 'dict')
const versionLastRun = ((lastInstall && lastInstall.NewVersion) ? lastInstall.NewVersion : undefined)
if (versionLastRun != appVersion) {
	const lastInstallInfo = {NewVersion: appVersion, LaunchDate: new Date()}

	if (versionLastRun) {
		lastInstallInfo.OldVersion = versionLastRun
		justInstalledUpdate = true
	}

	setPreference('LastAppInstall', lastInstallInfo, 'dict')
}

const everyProductType = ['iPhone', 'iPad', 'iPod touch', 'Apple TV', 'HomePod mini', 'Apple Vision', 'T2 Mac (iBridge Firmware)', 'Apple Silicon Mac']
const everyDayOfTheWeek = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
const defaultAutoLaunchHour = 18
const defaultAutoLaunchMinute = 30 // NOTE: DO NOT change this to less that 15 since the auto-wake time will always be 15 minutes before and that math only does a basic subtraction of these minutes without worrying about moving to a previous hour.
const daysAsLettersForPMSet = ['M', 'T', 'W', 'R', 'F', 'S', 'U']
const autoWakeTypeTranslation = {wakepoweron: 'Start Up'/* or Wake*/, wake: 'Wake', poweron: 'Start Up', sleep: 'Sleep', restart: 'Restart', shutdown: 'Shut Down'}

/** @type Intl.DateTimeFormatOptions */
const dateFormatOptions = {weekday: 'short', month: 'long', day: 'numeric', year: 'numeric'}

let shouldImmediatelyDeleteOutdatedFirmwares = getPreference('ImmediatelyDeleteOutdatedFirmwares', 'bool')
let shouldDeleteAppleConfiguratorTemporaryFiles = getPreference('DeleteAppleConfiguratorTemporaryFiles', 'bool')

const isFirstRun = getPreference('FirstRun', 'bool')
let userDidCancel = false

const userLibraryFolder = fileManager.URLsForDirectoryInDomains($.NSLibraryDirectory, $.NSUserDomainMask).firstObject.path.js

const launchAgentsPath = `${userLibraryFolder}/LaunchAgents`
const launchAgentPlistPath = `${launchAgentsPath}/${bundleIdentifier}.plist`

if (fileManager.fileExistsAtPath(launchAgentPlistPath)) { // Check if a LaunchAgent exists and update it if needed. See comments below for more info.
	const currentAutoLaunchSchedule = parseLaunchAgentSchedule()
	createLaunchAgentWithDaysAndHour(currentAutoLaunchSchedule.days, currentAutoLaunchSchedule.hour)

	// NOTES ABOUT CHECKING AND UPDATING LAUNCHAGENT (IF NEEDED) ON EVERY LAUNCH:

	// The "createLaunchAgentWithDaysAndHour" function with the same schedule that is already set will check the existing LaunchAgent and make sure it matches the current structure and
	// expected values and update it if needed, which is very important for the "Program" path in case the app is moved since the launcher path must point to the current app location to work.

	// If the existing LaunchAgent matches the exact expected LaunchAgent structure and values, it WILL NOT be updated or re-bootstrapped.

	// Calling the "createLaunchAgentWithDaysAndHour" function will also update any LaunchAgents made by previous versions to the currently used structure
	// which would be used when creating a new LaunchAgent, such as the following changes (and fixes):

	// LaunchAgents created prior to version 2022.10.21-1 specified "ProgramArguments" instead of a single "Program" path to the signed launcher script
	// and also didn't have "AssociatedBundleIdentifiers" specified for compatibility with macOS 13 Ventura.

	// LaunchAgents updated on launch by version 2022.11.17-1 and 2022.11.23-1 would accidentally/incorrectly have their "integer" values converted to "real" values
	// (because of running "deepUnwrap" on the NSDictionary of the plist, see comments in "createLaunchAgentWithDaysAndHour" function for more info about this JS int conversion issue)
	// which would not get parsed correctly by "launchd" and cause the app to incorrectly be automatically launched every minute or every hour.
}

const libraryITunesFolder = `${userLibraryFolder}/iTunes`
if (!fileManager.fileExistsAtPath(libraryITunesFolder))
	fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(libraryITunesFolder, true, {}, $())

const appleConfiguratorFirmwareFolder = `${userLibraryFolder}/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Firmware`
if (!fileManager.fileExistsAtPath(appleConfiguratorFirmwareFolder) && !needsFullDiskAccess()) // On macOS 15 Sequoia, there is a new "would like to access data from other apps" prompt that comes up when accessing the Apple Configurator Group Container each run unless the app has Full Disk Access.
	fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(appleConfiguratorFirmwareFolder, true, {}, $())

try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }

if (isFirstRun) {
	for ( ; ; ) {
		while (!macIsAwakeAndUnlocked()) // AppleScript dialogs will timeout early if Mac is asleep when it's displayed. So, wait until Mac is awake to display the dialog.
			delay(15)

		app.activate()

		try {
			const welcomeDialogReply = displayAlertOrDialogDependingOnOS(`Welcome to ${appName}!
Made by Pico Mitchell of Free Geek (freegeek.org) using the IPSW Downloads API (ipsw.me) by Callum Jones.

${appName} can batch download all the latest IPSW Firmware files from Apple and place them in the correct iTunes Software Updates or Apple Configurator Firmware folders so that they are automatically found by ${isCatalinaOrNewer ? 'Finder' : 'iTunes'} and/or Apple Configurator.

You can set which IPSW Firmware files to download based on versions as well as product types, such as ${everyProductType.slice(0, -1).join(', ')}, and ${everyProductType.slice(-1)[0]}. You can also set ${appName} to run automatically at a scheduled time so that all of your IPSW Firmware files will always be kept up-to-date.`,
				`If you agree, ${appName} will take over management of your iTunes Software Updates and Apple Configurator Firmware folders. You can use the button below to view these folders in Finder.

iPhone, iPad, and iPod touch IPSW Firmware files will be stored within iTunes Software Updates folders at ‚Äú${libraryITunesFolder}‚Äù since they will be found by both ${isCatalinaOrNewer ? 'Finder' : 'iTunes'} and Apple Configurator at that location.

Apple TV, HomePod mini, Apple Vision, and T2 and Apple Silicon Mac IPSW Firmware files will be stored within the Apple Configurator Firmware folder at ‚Äú${appleConfiguratorFirmwareFolder}‚Äù. This is because unlike iPhone, iPad, and iPod touch IPSW Firmware files, Apple Configurator will not detect or use IPSW Firmware files in the iTunes Software Updates folders for any other device types.${(isSonomaOrNewer ? '' : ` Also, T2 and Apple Silicon Macs cannot be restored by ${isCatalinaOrNewer ? 'Finder' : 'iTunes'} and can only be restored by Apple Configurator when they are put into DFU mode.`)}

Any IPSW Firmware files that are already in these folders will become managed by ${appName}. That means that IPSW Firmware files in these locations will be moved to the Trash (or deleted, based on your ${settingsOrPreferencesName.toLowerCase()}) when they become out-of-date after an update for them has been downloaded by ${appName}. Also, as described above, any iPhone, iPad, and iPod touch IPSW Firmware files that are currently in the Apple Configurator Firmware folder will be moved into their correct iTunes Software Updates folder and any IPSW Firmware files in the iTunes Software Updates folders for any other device types will be moved into the Apple Configurator Firmware folder. Finally, any IPSW Firmware files currently in these folders that are out-of-date but are still signed by Apple will be left alone and any that are no longer signed by Apple will be moved to the Trash (or deleted). ${appName} will check for unsigned IPSW Firmware files each time it runs, so existing files may be trashed (or deleted) in the future if and when Apple no longer signs them.

To use ${appName}, you must agree to let it manage your iTunes Software Updates and Apple Configurator Firmware folders and to update itself (app updates are checked on each launch). Once you agree, you'll be prompted to choose your desired ${settingsOrPreferencesName.toLowerCase()}, such as Excluded Product Types, Included iOS / iPadOS / tvOS Versions, Trash or Delete Outdated Files, Auto-Launch Schedule, and Start Up Schedule.`,
				`${appName}  ‚Äî  Welcome`,
				'note',
				['View iTunes Software Updates and Apple Configurator Firmware Folders', 'Quit', `Agree & Choose ${settingsOrPreferencesName}`],
				2,
				3
			)

			if (welcomeDialogReply.buttonReturned == `Agree & Choose ${settingsOrPreferencesName}`)
				break
			else if (welcomeDialogReply.buttonReturned == 'View iTunes Software Updates and Apple Configurator Firmware Folders') {
				sharedWorkspace.openURL($.NSURL.fileURLWithPath(libraryITunesFolder))
				sharedWorkspace.openURL($.NSURL.fileURLWithPath(appleConfiguratorFirmwareFolder))
			}
		} catch (welcomeDialogError) {
			if (welcomeDialogError.errorNumber === -128)
				cleanUpAndQuitEarly()
			else {
				debugLog('Welcome Dialog Error', welcomeDialogError)
				break // Just start if somehow times out or other error
			}
		}
	}

	promptForFullDiskAccessIfNeeded()

	promptForPreferences()

	setPreference('FirstRun', false, 'bool')
} else
	promptForFullDiskAccessIfNeeded()

if (!fileManager.fileExistsAtPath(appleConfiguratorFirmwareFolder))
	fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(appleConfiguratorFirmwareFolder, true, {}, $())

Progress.totalUnitCount = (isTahoeOrNewer ? 1 : -1)
// There is a bug in macOS 26 Tahoe where setting indeterminate progress at launch just displays 0 progress, EVEN IF manually running startAnimation on the NSProgressIndicator directly.
// To workaround this, first set determinate progress, then delay 0.01s to make sure the UI updates (without a delay the progress bar occasionally still doesn't animate), then set indeterminate progress, and THEN STILL startAnimation on the NSProgressIndicator directly.

Progress.completedUnitCount = 0
Progress.description = `
${(justInstalledUpdate ? `‚úÖ	Updated to Version ${appVersion}!` : (isFirstRun ? `üì≤	Welcome to ${appName}!` : 'üîÑ	Checking for App Updates'))}`
Progress.additionalDescription = ''

let progressWindow = undefined
let progressWindowProgressBar = undefined
for (const thisWindow of $.NSApp.windows.js)
	if (thisWindow.title.js == appName) {
		for (const thisSubview of thisWindow.contentView.subviews.js)
			if ($.NSStringFromClass(thisSubview.class).js == 'NSProgressIndicator') { // Check for NSProgressIndicator to not accidentally choose the "startup screen" window in case the app was launched when the Control key was being held.
				progressWindow = thisWindow
				progressWindowProgressBar = thisSubview
				progressWindow.standardWindowButton($.NSWindowZoomButton).enabled = false
				break
			}

		if (progressWindow) break
	}

if (isTahoeOrNewer) { // See comments above about macOS 26 Tahoe bug when setting indeterminate progress at launch.
	delay(0.01)

	Progress.totalUnitCount = -1

	if (progressWindowProgressBar)
		progressWindowProgressBar.startAnimation(null)
}

const releaseNotesURL = 'https://ipsw.app/download/updates.php'
const appUpdatesJsonURL = `${releaseNotesURL}?current_version=${appVersion}&os=${app.systemInfo().systemVersion}&uuid=${uuid}`

if (!justInstalledUpdate && !isFirstRun)
	checkAndInstallAppUpdates()
else {
	setProgressStopButtonEnabled(false)
	app.activate()

	if (justInstalledUpdate) {
		if (macIsAwakeAndUnlocked()) { // Skip update installed confirmation prompt if Mac IS NOT awake and unlocked.
			const appUpdatesJsonFilePath = `${temporaryFilesFolder}/app-updates.json`
			const appUpdatesJsonProgressOutputFile = `${temporaryFilesFolder}/app-updates.json-progress`

			const readAppUpdatesFileError = $()

			try {
				if (!fileManager.fileExistsAtPath(temporaryFilesFolder))
					fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(temporaryFilesFolder, true, {}, $())

				const downloadAppUpdatesJsonPID = app.doShellScript(`/usr/bin/curl --connect-timeout 5 -fL ${quoteForShell(`${appUpdatesJsonURL}&just_updated=1`)} -o ${quoteForShell(appUpdatesJsonFilePath)} > ${quoteForShell(appUpdatesJsonProgressOutputFile)} 2>&1 & echo $!`)
				backgroundPIDs.push(downloadAppUpdatesJsonPID)

				try {
					while (app.doShellScript(`kill -0 ${downloadAppUpdatesJsonPID}; echo $?`) == 0)
						delay(0.25)
				} catch (waitingForAppUpdatesJsonError) {
					debugLog('Waiting for App Updates JSON Error', waitingForAppUpdatesJsonError)

					try { app.doShellScript(`kill ${downloadAppUpdatesJsonPID}`) } catch (ignoredError) { /* Ignore */ }

					throw waitingForAppUpdatesJsonError
				}

				backgroundPIDs.splice(backgroundPIDs.indexOf(downloadAppUpdatesJsonPID), 1)

				const appUpdatesInfo = JSON.parse($.NSString.stringWithContentsOfFileEncodingError(appUpdatesJsonFilePath, $.NSUTF8StringEncoding, readAppUpdatesFileError).js)
				// NOTE: NOT using "ObjC.deepUnwrap($.NSJSONSerialization.JSONObjectWithDataOptionsError(...))" for consistency with other JSON parsing which don't use it for other reasons which aren't really important here (this JSON parse really would be fine with either technique).

				if (!Array.isArray(appUpdatesInfo)) throw new Error('App Updates JSON Is NOT an Array')

				try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }

				let newVersionReleaseNotes = 'No Release Notes'

				if (appUpdatesInfo.length > 0)
					for (const thisAppUpdate of appUpdatesInfo)
						if (thisAppUpdate.version == appVersion) {
							if (thisAppUpdate.releasenotes)
								newVersionReleaseNotes = thisAppUpdate.releasenotes

							break
						}

				closeProgressWindow()

				if (macIsAwakeAndUnlocked()) {
					for ( ; ; ) {
						app.activate()
						try {
							displayAlertOrDialogDependingOnOS(`Welcome to ${appName} Version ${appVersion}!`,
								`Version ${appVersion} Release Notes:

${newVersionReleaseNotes}`,
								`${appName}  ‚Äî  Updated to ${appVersion}`,
								'note',
								['View All Release Notes', 'Continue'],
								1,
								2,
								60
							)

							break
						} catch (appUpdatedDialogError) {
							if (appUpdatedDialogError.errorNumber === -128)
								sharedWorkspace.openURL($.NSURL.URLWithString(releaseNotesURL))
							else
								break
						}
					}
				}
			} catch (appUpdateError) {
				closeProgressWindow()

				let appUpdateErrorMessage = appUpdateError.message
				if (!readAppUpdatesFileError.isNil()) appUpdateError = readAppUpdatesFileError.description.js

				try {
					const progressOutputParts = $.NSString.stringWithContentsOfFileEncodingError(appUpdatesJsonProgressOutputFile, $.NSUTF8StringEncoding, $()).js.split('curl: ')
					if (progressOutputParts.length > 1)
						appUpdateErrorMessage = `CURL Error: ${progressOutputParts.slice(-1)[0].trim()}`
				} catch (ignoredError) { /* Ignore */ }

				try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }

				debugLog(`Confirm App Update Error: ${appUpdateErrorMessage}`, appUpdateError)
			}
		} else
			try {
				// But, even if Mac IS NOT awake and unlocked still do the "curl" call to "appUpdatesJsonURL" with the new version parameters,
				// (but do not wait for it to finish or save the output) just so that the successful app update is still saved in the server log.

				app.doShellScript(`/usr/bin/curl --connect-timeout 5 -sfL ${quoteForShell(`${appUpdatesJsonURL}&just_updated=2`)} > /dev/null 2>&1 &`) // "just_updated=2" indicates an update when the Mac is asleep or locked (while "just_updated=1" indicates updated while awake an unlocked).
			} catch (ignoredError) { /* Ignore */ }
	} else {
		delay(0.5)
		closeProgressWindow()
	}
}

let lastAppUpdatedNote = ''
try {
	lastInstall = getPreference('LastAppInstall', 'dict')
	if (lastInstall && lastInstall.OldVersion && lastInstall.NewVersion && lastInstall.LaunchDate) {
		const oneWeekAgoDate = new Date()
		oneWeekAgoDate.setDate(oneWeekAgoDate.getDate() - 7)

		if (lastInstall.LaunchDate.getTime() >= oneWeekAgoDate.getTime())
			lastAppUpdatedNote = `
‚§¥Ô∏è App Last Updated:
	üóì ${lastInstall.LaunchDate.toLocaleDateString('en-US', dateFormatOptions)} @ ${lastInstall.LaunchDate.toLocaleTimeString('en-US')}`
	}
} catch (ignoredError) { /* Ignore */ }

const updatesLogPath = `${applicationSupportFolder}/Updates Log.json`
let updatesLog = []
if (fileManager.fileExistsAtPath(updatesLogPath)) {
	const readUpdateLogFileError = $()

	try {
		updatesLog = JSON.parse($.NSString.stringWithContentsOfFileEncodingError(updatesLogPath, $.NSUTF8StringEncoding, readUpdateLogFileError).js)
		// NOTE: NOT using "ObjC.deepUnwrap($.NSJSONSerialization.JSONObjectWithDataOptionsError(...))" to read this JSON to the file since it alters the order of the keys within dicts when written later, which should be preserved since it's the desired dispay order of this human readable "Updates Log.json" file.
		if (!Array.isArray(updatesLog)) throw new Error('Parsed JSON Is NOT an Array')
	} catch (readUpdatesLogError) {
		let readUpdatesLogErrorMessage = readUpdatesLogError.message
		if (!readUpdateLogFileError.isNil()) readUpdatesLogError = readUpdateLogFileError.description.js

		try { fileManager.removeItemAtPathError(updatesLogPath, $()) } catch (ignoredError) { /* Ignore */ } // Delete any invalid Updates Log since it would just get overwritten anyways.

		debugLog(`Read "Updates Log.json" Error: ${readUpdatesLogErrorMessage}`, readUpdatesLogError)
		updatesLog = []
	}
}
let lastFirmwareUpdateCheck = `

	üîç Last Checked:`
const lastFirmwareUpdateCheckDate = getPreference('LastFirmwareUpdateCheck', 'date')
if (lastFirmwareUpdateCheckDate) {
	try {
		const firmwareUpdatesAvailable = getPreference('FirmwareUpdatesAvailable', 'int')
		lastFirmwareUpdateCheck += `
		üóì ${lastFirmwareUpdateCheckDate.toLocaleDateString('en-US', dateFormatOptions)} @ ${lastFirmwareUpdateCheckDate.toLocaleTimeString('en-US')}${(
		(firmwareUpdatesAvailable && (firmwareUpdatesAvailable > 0)) ? `
		‚§¥Ô∏è ${firmwareUpdatesAvailable} Firmware Update${(firmwareUpdatesAvailable == 1) ? '' : 's'} Available` : '')}`
	} catch (ignoredError) {
		lastFirmwareUpdateCheck += `
		UNKNOWN`
	}
} else
	lastFirmwareUpdateCheck += `
		Never`

let lastUpdateSummary = ''
let lastErrorSummary = ''

for (const thisUpdate of updatesLog)
	if (thisUpdate.Status)
		if (thisUpdate.Status.includes('Updated') || thisUpdate.Status.includes('Initial')) {
			try {
				const lastDownloadedFilesCount = Object.keys(thisUpdate.Downloaded.Files).length
				if (lastDownloadedFilesCount > 0) {
					if (lastFirmwareUpdateCheck.includes(thisUpdate.Times.Start)) lastFirmwareUpdateCheck = ''

					const lastSkippedDownloadsCount = (thisUpdate.Downloaded.Skipped ? parseInt(thisUpdate.Downloaded.Skipped) : 0)
					const lastDownloadErrorsCount = Object.keys(thisUpdate.Errors).length
					lastUpdateSummary = `

‚Ü©Ô∏è ${(thisUpdate.Status.includes('Updated') ? `Last ${thisUpdate.Status}` : thisUpdate.Status)}:
	üóì ${thisUpdate.Times.Start}
	üì≤ Updated ${lastDownloadedFilesCount} IPSW File${((lastDownloadedFilesCount == 1) ? '' : 's')} (${thisUpdate.Downloaded['Total Size']})${createVersionsDownloadedSummary(thisUpdate.Downloaded.Files, 1)}${((lastSkippedDownloadsCount > 0) ? `
	‚è≠Ô∏è Skipped ${lastSkippedDownloadsCount} Update${((lastSkippedDownloadsCount == 1) ? '' : 's')}` : '')}${((lastDownloadErrorsCount > 0) ? `
	‚ö†Ô∏è ${lastDownloadErrorsCount} Download Error${((lastDownloadErrorsCount == 1) ? '' : 's')} Occurred` : '')}`
				}
			} catch (ignoredError) { /* Ignore */ }

			break
		} else if (!lastErrorSummary && thisUpdate.Status.includes('Error')) {
			try {
				const lastDownloadErrorKeys = Object.keys(thisUpdate.Errors)
				const lastDownloadErrorsCount = lastDownloadErrorKeys.length
				if (lastDownloadErrorsCount > 0) {
					if (lastFirmwareUpdateCheck.includes(thisUpdate.Times.Start)) lastFirmwareUpdateCheck = ''
					const firstLastDownloadErrorObject = thisUpdate.Errors[lastDownloadErrorKeys[0]]
					lastErrorSummary = `

‚Ü™Ô∏è Last ${thisUpdate.Status}:
	üóì ${thisUpdate.Times.Start}
	${((thisUpdate.Status == 'Load Error') ?
	`‚ö†Ô∏è ${(Array.isArray(firstLastDownloadErrorObject) ? firstLastDownloadErrorObject[0] : firstLastDownloadErrorObject).replace('CURL Error: (6) ', '').trim()}` :
	`‚ö†Ô∏è ${lastDownloadErrorsCount} Download Error${((lastDownloadErrorsCount == 1) ? '' : 's')} Occurred`)}`
				}
			} catch (ignoredError) { /* Ignore */ }
		}

if (macIsAwakeAndUnlocked()) { // Skip launch window if asleep or locked (just start checking for updates immediately).
	const autoStartSeconds = 45

	for ( ; ; ) {
		const currentExcludedProducts = getPreference('ExcludeProducts', 'string array') // This returned excluded product will always be sanitized to a valid value by "getPreference()".
		const currentIncludedVersions = getPreference('IncludeVersions', 'int') // This returned version will always be sanitized to a valid value by "getPreference()".

		let currentAutoLaunchScheduleDisplay = createDisplayScheduleFor(parseLaunchAgentSchedule())
		if ((currentAutoLaunchScheduleDisplay != 'Never') && launchAgentIsDisabledOnVenturaOrNewer())
			currentAutoLaunchScheduleDisplay += `
		‚ö†Ô∏è\tManually Disabled in System Settings`

		const currentAutoWakeSchedules = parseAutoWakePowerEventPreferences()
		let currentAutoWakeOnScheduleDisplay = createDisplayScheduleFor(currentAutoWakeSchedules.On)
		if ((currentAutoWakeOnScheduleDisplay != 'Never') && ($.NSUserDefaults.alloc.initWithSuiteName('/Library/Preferences/com.apple.loginwindow').stringForKey('autoLoginUser').js != currentUserName))
			currentAutoWakeOnScheduleDisplay += `
		‚ö†Ô∏è\tAuto-Login Must Be Enabled\n\t\t\tto Auto-Launch on Start Up`

		let currentAutoWakeOffScheduleDisplay = createDisplayScheduleFor(currentAutoWakeSchedules.Off)
		if ((currentAutoWakeOffScheduleDisplay != 'Never') && hasConflictingPowerSchedules(currentAutoWakeSchedules))
			currentAutoWakeOffScheduleDisplay += `
		‚ö†Ô∏è\tShut Down Schedule May Conflict\n\t\t\twith Start Up Schedule`

		app.activate()

		let includedVersionsDisplay = ''

		const iOSincludedVersions = []
		if (!currentExcludedProducts.includes('iPhone') || !currentExcludedProducts.includes('iPod touch'))
			iOSincludedVersions.push('iOS')
		if (!currentExcludedProducts.includes('iPad'))
			iOSincludedVersions.push('iPadOS')
		if (!currentExcludedProducts.includes('Apple TV'))
			iOSincludedVersions.push('tvOS')
		if (iOSincludedVersions.length > 0)
			includedVersionsDisplay += `${iOSincludedVersions.join(' / ')} ${currentIncludedVersions} and Newer`

		if (!currentExcludedProducts.includes('HomePod mini') || !currentExcludedProducts.includes('Apple Vision') || !currentExcludedProducts.includes('T2 Mac (iBridge Firmware)') || !currentExcludedProducts.includes('Apple Silicon Mac')) {
			const otherOSincludedVersions = []
			if (!currentExcludedProducts.includes('HomePod mini'))
				otherOSincludedVersions.push('audioOS')
			if (!currentExcludedProducts.includes('Apple Vision'))
				otherOSincludedVersions.push('visionOS')
			if (!currentExcludedProducts.includes('T2 Mac (iBridge Firmware)'))
				otherOSincludedVersions.push('bridgeOS')
			if (!currentExcludedProducts.includes('Apple Silicon Mac'))
				otherOSincludedVersions.push('macOS')

			if (includedVersionsDisplay) includedVersionsDisplay += '\n\t\t'
			includedVersionsDisplay += `Latest ${((otherOSincludedVersions.length <= 2) ? otherOSincludedVersions.join(' and ') : `${otherOSincludedVersions.slice(0, -1).join(', ')},\n\t\tand ${otherOSincludedVersions.slice(-1)[0]}`)}`
		}

		try {
			const countDownDialogReply = displayAlertOrDialogDependingOnOS(`${appName} will start in ${autoStartSeconds} seconds‚Ä¶`,
				`Version ${appVersion}${lastAppUpdatedNote}


üì≤ Firmware Updates Overview:${lastFirmwareUpdateCheck}${lastErrorSummary.replace(/\n|\r/g, '\n\t')}${lastUpdateSummary.replace(/\n|\r/g, '\n\t')}


‚öôÔ∏è ${settingsOrPreferencesName} Overview:

	üö´ Excluded Product Types:
		${((currentExcludedProducts.length == 0) ? 'None' : currentExcludedProducts.join(', ').replace(', HomePod', ',\n\t\tHomePod').replace(', T2', ',\n\t\tT2').replace(', Apple Silicon', ',\n\t\tApple Silicon'))}

	üçè Included Versions:
		${includedVersionsDisplay}

	üóë Outdated IPSW Files:
		${shouldImmediatelyDeleteOutdatedFirmwares ? 'Immediately Deleted' : 'Trashed'}${shouldDeleteAppleConfiguratorTemporaryFiles ? `
		and Apple Configurator Temporary Files Deleted` : ''}

	‚è∞ Auto-Launch Schedule:
		${currentAutoLaunchScheduleDisplay}

	üîå Power Schedule:
		${((currentAutoWakeOnScheduleDisplay == 'Never') ? 'No Start Up Schedule' : currentAutoWakeOnScheduleDisplay)}${
		((currentAutoWakeOffScheduleDisplay == 'Never') ? '' : `
		${currentAutoWakeOffScheduleDisplay}`)}`,
				appName,
				'note',
				[`Edit ${settingsOrPreferencesName}‚Ä¶`, 'Quit', 'Start Now'],
				2,
				3,
				autoStartSeconds
			)

			if (countDownDialogReply.gaveUp || (countDownDialogReply.buttonReturned == 'Start Now'))
				break
			else if (countDownDialogReply.buttonReturned == `Edit ${settingsOrPreferencesName}‚Ä¶`)
				promptForPreferences()
		} catch (countDownDialogError) {
			if (countDownDialogError.errorNumber === -128)
				cleanUpAndQuitEarly()
			else
				break // Just start if somehow times out or other error
		}
	}
}

wakeMacUp()

const startDate = new Date()

debugLog('Checking Existing IPSW Firmware Files Are in Correct Locations')

Progress.description = `
üîÑ	Checking Existing IPSW Firmware Files Are in Correct Locations`
Progress.additionalDescription = ''
Progress.totalUnitCount = -1
Progress.completedUnitCount = 0

try {
	if (fileManager.fileExistsAtPath(appleConfiguratorFirmwareFolder)) {
		const productTypesToMoveOutOfAppleConfiguratorFirmwareFolder = ['iPhone', 'iPad', 'iPod']
		for (const thisFirmwareFileNameInSoftwareUpdatesFolder of ObjC.deepUnwrap(fileManager.contentsOfDirectoryAtPathError(appleConfiguratorFirmwareFolder, $())))
			for (const thisProductType of productTypesToMoveOutOfAppleConfiguratorFirmwareFolder)
				if (thisFirmwareFileNameInSoftwareUpdatesFolder.startsWith(thisProductType)) {
					const thisIntendedSoftwareUpdatesFolder = `${libraryITunesFolder}/${thisProductType} Software Updates`

					if (fileManager.fileExistsAtPath(`${thisIntendedSoftwareUpdatesFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`))
						try { fileManager.removeItemAtPathError(`${thisIntendedSoftwareUpdatesFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`, $()) } catch (ignoredError) { /* Ignore */ }
					else if (!fileManager.fileExistsAtPath(thisIntendedSoftwareUpdatesFolder))
						fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(thisIntendedSoftwareUpdatesFolder, true, {}, $())

					try { fileManager.moveItemAtPathToPathError(`${appleConfiguratorFirmwareFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`, `${thisIntendedSoftwareUpdatesFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`, $()) } catch (ignoredError) { /* Ignore */ }
				}
	}
} catch (moveOutOfAppleConfiguratorFirmwareFolderError) {
	debugLog('Move iPhone, iPad, and iPod Firmware Out Of Apple Configurator Firmware Folder Error', moveOutOfAppleConfiguratorFirmwareFolderError)

	if (!userDidCancel) userDidCancel = (moveOutOfAppleConfiguratorFirmwareFolderError.errorNumber === -128)
}

try {
	if (fileManager.fileExistsAtPath(libraryITunesFolder)) {
		const productTypesToMoveOutOfLibraryITunesSoftwareUpdatesFolders = ['Apple TV', 'HomePod', 'iBridge', 'Mac']
		// On macOS 14 Sonoma and newer, Finder can restore T2 and Apple Silicon Macs in DFU mode.
		// Their IPSW Firmware files are saved into "~/Library/iTunes/iBridge Software Updates" and "~/Library/iTunes/Mac Software Updates",
		// but Apple Configurator will not find or use them at those locations, so move them into the Apple Configurator Firmware folder.

		for (const thisProductType of productTypesToMoveOutOfLibraryITunesSoftwareUpdatesFolders)
			if (fileManager.fileExistsAtPath(`${libraryITunesFolder}/${thisProductType} Software Updates`)) {
				for (const thisFirmwareFileNameInSoftwareUpdatesFolder of ObjC.deepUnwrap(fileManager.contentsOfDirectoryAtPathError(`${libraryITunesFolder}/${thisProductType} Software Updates`, $()))) {
					if (fileManager.fileExistsAtPath(`${appleConfiguratorFirmwareFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`))
						try { fileManager.removeItemAtPathError(`${appleConfiguratorFirmwareFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`, $()) } catch (ignoredError) { /* Ignore */ }

					try { fileManager.moveItemAtPathToPathError(`${libraryITunesFolder}/${thisProductType} Software Updates/${thisFirmwareFileNameInSoftwareUpdatesFolder}`, `${appleConfiguratorFirmwareFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`, $()) } catch (ignoredError) { /* Ignore */ }
				}

				try { fileManager.removeItemAtPathError(`${libraryITunesFolder}/${thisProductType} Software Updates`, $()) } catch (ignoredError) { /* Ignore */ }
			}
	}
} catch (moveOutOfLibraryITunesSoftwareUpdatesFoldersError) {
	debugLog('Move Apple TV, HomePod, iBridge, and Apple Silicon Mac Firmware Out Of iTunes Software Updates Folders Error', moveOutOfLibraryITunesSoftwareUpdatesFoldersError)

	if (!userDidCancel) userDidCancel = (moveOutOfLibraryITunesSoftwareUpdatesFoldersError.errorNumber === -128)
}

if (shouldDeleteAppleConfiguratorTemporaryFiles) {
	const appleConfiguratorTemporaryRestoreFolder = `${userLibraryFolder}/Containers/com.apple.configurator.xpc.DeviceService/Data/tmp`
	if (fileManager.fileExistsAtPath(appleConfiguratorTemporaryRestoreFolder)) {
		debugLog('Deleting Apple Configurator Temporary Restore Folder')

		try { fileManager.removeItemAtPathError(appleConfiguratorTemporaryRestoreFolder, $()) } catch (ignoredError) { /* Ignore */ }
	}

	const appleConfiguratorTemporaryDownloadFolder = `${userLibraryFolder}/Containers/com.apple.configurator.xpc.InternetService/Data/tmp`
	if (fileManager.fileExistsAtPath(appleConfiguratorTemporaryDownloadFolder)) {
		debugLog('Deleting Apple Configurator Temporary Download Folder')

		try { fileManager.removeItemAtPathError(appleConfiguratorTemporaryDownloadFolder, $()) } catch (ignoredError) { /* Ignore */ }
	}
}

debugLog('Starting to Check for IPSW Firmware Updates')

if (!fileManager.fileExistsAtPath(temporaryFilesFolder))
	fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(temporaryFilesFolder, true, {}, $())

let globalGetFirmwaresErrorMessage = 'UNKNOWN ERROR'
const downloadErrors = {}
let allFirmwareInfo = {}
const allFirmwaresFilePath = `${temporaryFilesFolder}/firmwares.json`
let firmwareProgressOutputFile = `${temporaryFilesFolder}/firmwares.json-progress`
const cachedAllFirmwaresFilePath = `${applicationSupportFolder}/cached-firmwares.json`

const readFirmwaresFileError = $()

try {
	Progress.description = `
üîÑ	Loading Latest IPSW Firmware Information`
	Progress.additionalDescription = ''
	Progress.totalUnitCount = -1
	Progress.completedUnitCount = 0

	setProgressStopButtonEnabled(true)

	app.activate()

	openProgressWindow()

	delay(0.1)

	const firmwaresInfoURLs = ['https://api.ipsw.me/v3/firmwares.json/condensed', 'https://api.ipsw.me/v3/firmwares.json']
	// First try the smaller "condensed" JSON, but if that does not have a "device" array, try the un-condensed version since that seems to get updated faster when IPSW.me is updating firmwares when a new update is released by Apple.

	for (const thisFirmwaresInfoURL of firmwaresInfoURLs) {
		debugLog('Downloading Firmwares JSON', thisFirmwaresInfoURL)

		if (backgroundPIDs.length > 0) {
			try { app.doShellScript(`kill ${backgroundPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }
			backgroundPIDs.splice(0, backgroundPIDs.length)
		}

		const downloadFirmwaresInfoPID = app.doShellScript(`/usr/bin/curl --connect-timeout 5 -fL ${quoteForShell(thisFirmwaresInfoURL)} -o ${quoteForShell(allFirmwaresFilePath)} > ${quoteForShell(firmwareProgressOutputFile)} 2>&1 & echo $!`)
		backgroundPIDs.push(downloadFirmwaresInfoPID)

		try {
			while (app.doShellScript(`kill -0 ${downloadFirmwaresInfoPID}; echo $?`) == 0)
				delay(0.25)
		} catch (waitingForDownloadError) {
			debugLog('Waiting for Download Error', waitingForDownloadError)

			try { app.doShellScript(`kill ${downloadFirmwaresInfoPID}`) } catch (ignoredError) { /* Ignore */ }

			throw waitingForDownloadError
		}

		backgroundPIDs.splice(backgroundPIDs.indexOf(downloadFirmwaresInfoPID), 1)

		setProgressStopButtonEnabled(false)

		allFirmwareInfo = JSON.parse($.NSString.stringWithContentsOfFileEncodingError(allFirmwaresFilePath, $.NSUTF8StringEncoding, readFirmwaresFileError).js)
		// NOTE: NOT using "ObjC.deepUnwrap($.NSJSONSerialization.JSONObjectWithDataOptionsError(...))" since it takes about 3x as long as "JSON.parse" to parse this large JSON file (because of the required "ObjC.deepUnwrap" to get it into the desired JS dict).

		if (allFirmwareInfo.devices) {
			debugLog('Caching Latest Downloaded Firmwares JSON File') // Caching firmwares.json to be loaded when api.ipsw.me is updating was inspired by https://github.com/ninxsoft/mist-cli/issues/110#issuecomment-1296966051

			try { fileManager.removeItemAtPathError(cachedAllFirmwaresFilePath, $()) } catch (ignoredError) { /* Ignore */ } // If successfully loaded the latest firmwares.json, delete the previous cached file...
			try { fileManager.moveItemAtPathToPathError(allFirmwaresFilePath, cachedAllFirmwaresFilePath, $()) } catch (ignoredError) { /* Ignore */ } // and save the new firmwares.json at the cache location to use if needed when loading when api.ipsw.me is being updated.

			break
		} else {
			try { fileManager.removeItemAtPathError(allFirmwaresFilePath, $()) } catch (ignoredError) { /* Ignore */ }

			if (thisFirmwaresInfoURL.endsWith('.json') && allFirmwareInfo.iTunes && fileManager.fileExistsAtPath(cachedAllFirmwaresFilePath)) { // If failed to load the latest firmwares.json because api.ipsw.me is being updated, and have a previously cached firmwares.json file, load it instead.
				debugLog('Loading Cached Firmwares JSON File Since api.ipsw.me Is Updating Firmware Info')

				allFirmwareInfo = JSON.parse($.NSString.stringWithContentsOfFileEncodingError(cachedAllFirmwaresFilePath, $.NSUTF8StringEncoding, readFirmwaresFileError).js)
			}
		}
	}
} catch (getFirmwaresError) {
	setProgressStopButtonEnabled(false)

	if (!userDidCancel) userDidCancel = (getFirmwaresError.errorNumber === -128)

	let getFirmwaresErrorMessage = getFirmwaresError.message
	if (!readFirmwaresFileError.isNil()) getFirmwaresError = readFirmwaresFileError.description.js

	try {
		const progressOutputParts = $.NSString.stringWithContentsOfFileEncodingError(firmwareProgressOutputFile, $.NSUTF8StringEncoding, $()).js.split('curl: ')
		if (progressOutputParts.length > 1)
			getFirmwaresErrorMessage = `CURL Error: ${progressOutputParts.slice(-1)[0].trim()}`
	} catch (ignoredError) { /* Ignore */ }

	globalGetFirmwaresErrorMessage = getFirmwaresErrorMessage.replace(/\n|\r/g, '')

	debugLog(`Error Loading Firmware Info: ${globalGetFirmwaresErrorMessage}`, getFirmwaresError)

	if (!userDidCancel)
		downloadErrors['https://api.ipsw.me/v3/firmwares.json/condensed'] = globalGetFirmwaresErrorMessage
}

setProgressStopButtonEnabled(false)

try { fileManager.removeItemAtPathError(firmwareProgressOutputFile, $()) } catch (ignoredError) { /* Ignore */ }
try { fileManager.removeItemAtPathError(allFirmwaresFilePath, $()) } catch (ignoredError) { /* Ignore */ }

let unsignedFirmwares = []
let uniqueFirmwares = {}

let newManagedFirmware = {}
let uniqueDeviceNamesForFirmwareFileNames = {}

try {
	for (const thisModelID in allFirmwareInfo.devices) {
		if ((thisModelID == 'ADP3,2') || thisModelID.startsWith('VirtualMac')) continue // Ignore Device IDs for "Apple Silicon Developer Transition Kit" (ADP3,2) and "Apple Silicon Virtual Machine" (currently only ever "VirtualMac2,1" but ignoring any possible future numbers as well).
		// The "Apple Silicon Developer Transition Kit" (ADP3,2) device is ignored because it will always be stuck at macOS 11.2.3 Big Sur and the devices should have all been returned to Apple.
		// The "Apple Silicon Virtual Machine" (VirtualMac2,1) device is ignored because it should always be the same version as all the other actual hardware devices, and there's no need to include "Apple Virtual Machine 1" in the "displayDeviceNames" for macOS downloads.

		const thisDeviceObject = allFirmwareInfo.devices[thisModelID]

		const firmwaresForDevice = thisDeviceObject.firmwares.sort((thisFirmware, thatFirmware) => $(thatFirmware.version).compareOptions(thisFirmware.version, $.NSNumericSearch)) // Manually sort firmwares by version (newest to oldest) since the default sort lists macOS 13.6 above macOS 14.0 (presumably because the "uploaddate" for 13.6 is one day after 14.0 for some reason).

		for (let thisFirmwareIndex = 0; thisFirmwareIndex < firmwaresForDevice.length; thisFirmwareIndex ++) {
			const thisFirmware = firmwaresForDevice[thisFirmwareIndex]
			const thisFirmwareFileName = decodeURIComponent(thisFirmware.filename)

			if ((thisFirmwareIndex == 0) && thisFirmware.signed) {
				const thisFirmwareURL = thisFirmware.url.replace('http://updates-http.cdn-apple.com/', 'https://updates.cdn-apple.com/') // Always download from HTTPS URL even if HTTP URL is listed.
				if (thisFirmwareURL.startsWith('http://appldnld.apple.com/') || thisFirmwareURL.startsWith('https://secure-appldnld.apple.com/') || thisFirmwareURL.startsWith('https://updates.cdn-apple.com/')) { // Only trust known Apple URLs.
					if (!uniqueFirmwares[thisFirmwareFileName]) {
						uniqueFirmwares[thisFirmwareFileName] = {}

						uniqueFirmwares[thisFirmwareFileName].url = thisFirmwareURL
						uniqueFirmwares[thisFirmwareFileName].size = thisFirmware.size
						uniqueFirmwares[thisFirmwareFileName].sha1sum = thisFirmware.sha1sum
						uniqueFirmwares[thisFirmwareFileName].version = thisFirmware.version
					}

					if (!uniqueFirmwares[thisFirmwareFileName].modelIdentifiers)
						uniqueFirmwares[thisFirmwareFileName].modelIdentifiers = []
					uniqueFirmwares[thisFirmwareFileName].modelIdentifiers.push(thisModelID)
					uniqueFirmwares[thisFirmwareFileName].modelIdentifiers.sort()

					if (!uniqueFirmwares[thisFirmwareFileName].deviceNames)
						uniqueFirmwares[thisFirmwareFileName].deviceNames = []
					if (!uniqueFirmwares[thisFirmwareFileName].deviceNames.includes(thisDeviceObject.name)) {
						uniqueFirmwares[thisFirmwareFileName].deviceNames.push(thisDeviceObject.name)
						uniqueFirmwares[thisFirmwareFileName].deviceNames.sort((thisDeviceNameElement, thatDeviceNameElement) => $(thisDeviceNameElement).compareOptions(thatDeviceNameElement, $.NSCaseInsensitiveSearch))
					}

					if (!uniqueFirmwares[thisFirmwareFileName].baseDeviceNames)
						uniqueFirmwares[thisFirmwareFileName].baseDeviceNames = []
					let deviceNameParts = thisDeviceObject.name.split(' (')
					if (deviceNameParts.length == 1) deviceNameParts = thisDeviceObject.name.split(',')
					const baseDeviceName = (deviceNameParts[0].startsWith('iMac ') ? 'iMac' : deviceNameParts[0]) // So that all Apple Silicon iMac models (such as "iMac 24-inch") are grouped into the "iMac" base name.
					const baseDeviceNameLower = baseDeviceName.toLowerCase()
					if (!uniqueFirmwares[thisFirmwareFileName].baseDeviceNames.some(thisBaseDeviceNameElement => thisBaseDeviceNameElement.toLowerCase() === baseDeviceNameLower))
						uniqueFirmwares[thisFirmwareFileName].baseDeviceNames.push(baseDeviceName)
					uniqueFirmwares[thisFirmwareFileName].baseDeviceNames.sort((thisBaseDeviceNameElement, thatBaseDeviceNameElement) => $(thisBaseDeviceNameElement).compareOptions(thatBaseDeviceNameElement, $.NSCaseInsensitiveSearch))
				} else
					debugLog('Invalid IPSW URL', thisFirmwareURL)
			} else if (!thisFirmware.signed && !unsignedFirmwares.includes(thisFirmwareFileName))
				unsignedFirmwares.push(thisFirmwareFileName)
		}
	}

	for (const thisFirmwareFileName in uniqueFirmwares) {
		let thisDisplayDeviceNames = ((uniqueFirmwares[thisFirmwareFileName].deviceNames.length == 1) ? uniqueFirmwares[thisFirmwareFileName].deviceNames[0] : uniqueFirmwares[thisFirmwareFileName].baseDeviceNames.join(', '))
		for (const thatFirmwareFileName in uniqueFirmwares)
			if (thisFirmwareFileName != thatFirmwareFileName) {
				const thatDisplayDeviceNames = uniqueFirmwares[thatFirmwareFileName].baseDeviceNames.join(', ')
				if ((thisDisplayDeviceNames == ((uniqueFirmwares[thatFirmwareFileName].deviceNames.length == 1) ? uniqueFirmwares[thatFirmwareFileName].deviceNames[0] : thatDisplayDeviceNames)) || (thisDisplayDeviceNames == thatDisplayDeviceNames)) {
					thisDisplayDeviceNames = uniqueFirmwares[thisFirmwareFileName].deviceNames.join(', ')
					break
				}
			}

		if (thisDisplayDeviceNames == 'iBridge2') thisDisplayDeviceNames = 'iBridge (for T2 Macs)'
		else if (thisDisplayDeviceNames.includes('Mac')) thisDisplayDeviceNames = `Apple Silicon ${thisDisplayDeviceNames}`

		uniqueFirmwares[thisFirmwareFileName].displayDeviceNames = thisDisplayDeviceNames
		uniqueDeviceNamesForFirmwareFileNames[thisDisplayDeviceNames] = thisFirmwareFileName

		uniqueFirmwares[thisFirmwareFileName].productType = 'Unknown'
		uniqueFirmwares[thisFirmwareFileName].productSoftwareUpdatesFolder = 'Unknown Software Updates'

		for (const thisProductType of everyProductType)
			if (thisDisplayDeviceNames.includes(thisProductType) || (thisDisplayDeviceNames.startsWith('iBridge') && thisProductType.includes('iBridge')) || (thisDisplayDeviceNames.includes('Mac') && thisProductType.includes('Silicon'))) {
				uniqueFirmwares[thisFirmwareFileName].productType = thisProductType

				const thisProductSoftwareUpdatesFolder = ((thisProductType.startsWith('iP')) ? `${libraryITunesFolder}/${thisProductType.replace(' touch', '')} Software Updates` : appleConfiguratorFirmwareFolder)
				uniqueFirmwares[thisFirmwareFileName].productSoftwareUpdatesFolder = thisProductSoftwareUpdatesFolder

				if (fileManager.fileExistsAtPath(`${thisProductSoftwareUpdatesFolder}/${thisFirmwareFileName}`))
					newManagedFirmware[thisFirmwareFileName] = thisDisplayDeviceNames

				break
			}
	}
} catch (parseFirmwaresError) {
	debugLog('Error Parsing Firmwares', parseFirmwaresError)

	unsignedFirmwares = []
	uniqueFirmwares = {}

	newManagedFirmware = {}
	uniqueDeviceNamesForFirmwareFileNames = {}
}

//debugDialog(uniqueFirmwares)
//debugDialog(unsignedFirmwares)

let oldManagedFirmware = getPreference('ManagedFirmwares', 'dict')
if (!(oldManagedFirmware instanceof Object) || Array.isArray(oldManagedFirmware))
	oldManagedFirmware = {}

const sortedUniqueDeviceNames = Object.keys(uniqueDeviceNamesForFirmwareFileNames).sort((thisUniqueDeviceNameElement, thatUniqueDeviceNameElement) => $(thisUniqueDeviceNameElement).compareOptions(thatUniqueDeviceNameElement, $.NSCaseInsensitiveSearch))
const sortedUniqueFirmwareFileNames = Object.keys(uniqueFirmwares).sort()
const uniqueFirmwaresCount = sortedUniqueFirmwareFileNames.length
const excludedProducts = getPreference('ExcludeProducts', 'string array') // This returned excluded product will always be sanitized to a valid value by "getPreference()".
const includedVersions = getPreference('IncludeVersions', 'int') // This returned version will always be sanitized to a valid value by "getPreference()".
let firmwaresNeedingUpdate = {}
let totalFirmwaresToUpdateSize = 0

//debugDialog(uniqueDeviceNamesForFirmwareFileNames)
//debugDialog(sortedUniqueDeviceNames)
//debugDialog(sortedUniqueFirmwareFileNames)

if (uniqueFirmwaresCount > 0) {
	try {
		wakeMacUp()

		Progress.totalUnitCount = uniqueFirmwaresCount
		Progress.completedUnitCount = 0
		Progress.description = `‚öñÔ∏è	Verifying IPSW Firmware Files & Checking for Updates`
		Progress.additionalDescription = `
üîç Checking 0 of ${uniqueFirmwaresCount}: Preparing to Check IPSW Firmware Files‚Ä¶

üì≤ 0 Available Updates Found for IPSW Firmware Files So Far‚Ä¶`

		if (isTahoeOrNewer && progressWindowProgressBar) {
			// There is a bug in macOS 26 Tahoe where switching from indeterminate to determinate progress does not always update properly and will continue animating as indeterminate progress.
			// To workaround this, switching the NSProgressIndicator style from Bar to Spinning and then to Bar seems to force the progress to refresh to it's intended determinate state properly.
			// Everything else I tried didn't work (such as manually setting "progressWindowProgressBar.setIndeterminate(false)"), but for some reason this works reliable.
			// Hiding the progress bar before the change and unhiding afterward does not make a difference to this workaround,
			// it's just that sometimes the Spinning style may show momentarily and momentarily hiding instead looks better.

			progressWindowProgressBar.setHidden(true)
			progressWindowProgressBar.setStyle($.NSProgressIndicatorStyleSpinning)
			progressWindowProgressBar.setStyle($.NSProgressIndicatorStyleBar)
			progressWindowProgressBar.setHidden(false)
		}

		delay(0.25)

		setProgressStopButtonEnabled(true)

		for (let firmwareIndex = 0; firmwareIndex < uniqueFirmwaresCount; firmwareIndex ++) {
			const thisFirmwareFileName = ((uniqueFirmwaresCount == sortedUniqueDeviceNames.length) ? uniqueDeviceNamesForFirmwareFileNames[sortedUniqueDeviceNames[firmwareIndex]] : sortedUniqueFirmwareFileNames[firmwareIndex])
			Progress.completedUnitCount ++

			const firmwaresNeedingUpdateSoFarCount = Object.keys(firmwaresNeedingUpdate).length

			const thisDisplayDeviceNames = uniqueFirmwares[thisFirmwareFileName].displayDeviceNames
			const thisDisplayDeviceNamesTruncated = ((thisDisplayDeviceNames.length > 81) ? `${thisDisplayDeviceNames.slice(0, 40)}‚Ä¶${thisDisplayDeviceNames.slice(thisDisplayDeviceNames.length - 40)}` : thisDisplayDeviceNames)

			Progress.additionalDescription = `
Ô∏èüîç Checking ${Progress.completedUnitCount} of ${uniqueFirmwaresCount}: ${thisDisplayDeviceNamesTruncated}

üì≤ ${firmwaresNeedingUpdateSoFarCount} Available Update${((firmwaresNeedingUpdateSoFarCount == 1) ? '' : 's')} Found for IPSW Firmware Files So Far‚Ä¶`

			const thisProductType = uniqueFirmwares[thisFirmwareFileName].productType
			const thisITunesSoftwareUpdatesFilePath = `${uniqueFirmwares[thisFirmwareFileName].productSoftwareUpdatesFolder}/${thisFirmwareFileName}`
			if (thisProductType != 'Unknown' && !excludedProducts.includes(thisProductType) &&
				(thisProductType.includes('HomePod') || thisProductType.includes('Vision') || thisProductType.includes('Mac') || ($(uniqueFirmwares[thisFirmwareFileName].version).compareOptions(includedVersions.toString(), $.NSNumericSearch) >= 0)) &&
				(
					!fileManager.fileExistsAtPath(thisITunesSoftwareUpdatesFilePath) ||
					(uniqueFirmwares[thisFirmwareFileName].size != fileManager.attributesOfItemAtPathError(thisITunesSoftwareUpdatesFilePath, $()).objectForKey('NSFileSize').js) ||
					(uniqueFirmwares[thisFirmwareFileName].sha1sum != calculateChecksumForFile(thisITunesSoftwareUpdatesFilePath))
				)) {
					firmwaresNeedingUpdate[thisFirmwareFileName] = uniqueFirmwares[thisFirmwareFileName]
					totalFirmwaresToUpdateSize += firmwaresNeedingUpdate[thisFirmwareFileName].size
			}

			if (isTahoeOrNewer && progressWindowProgressBar) {
				// There is a bug in macOS 26 Tahoe where determinate progress does not always update properly.
				// To (somewhat) workaround this (it still sometimes stutters back and forth), force the NSProgressIndicator to display after each progress update.

				progressWindowProgressBar.display

				if ((Progress.completedUnitCount % 10 == 0) || (Progress.completedUnitCount == 1) || (Progress.completedUnitCount == Progress.totalUnitCount)) {
					// Also, add an extra delay after every 10 progress steps (or the first step or when completed) to allow extra display update time.
					// This does not seem to always be necessary, but can help when progress moves rapidly without enough sleep time for the progress bar to update.

					delay(0.5)
				}
			}

			delay(0.1)
		}

		setProgressStopButtonEnabled(false)
	} catch (verifyFirmwareAndCheckForUpdatesError) {
		setProgressStopButtonEnabled(false)

		debugLog('Error Verifying Firmware & Checking for Updates', verifyFirmwareAndCheckForUpdatesError)

		if (verifyFirmwareAndCheckForUpdatesError.errorNumber === -128) {
			userDidCancel = true
			firmwaresNeedingUpdate = {}
		}
	}

	Progress.completedUnitCount = uniqueFirmwaresCount

	if (isTahoeOrNewer && progressWindowProgressBar) {
		// There is a bug in macOS 26 Tahoe where determinate progress does not always update properly.
		// To (somewhat) workaround this (it still sometimes stutters back and forth), force the NSProgressIndicator to display after each progress update.

		progressWindowProgressBar.display
	}
}

setProgressStopButtonEnabled(false)

//debugDialog(firmwaresNeedingUpdate)

const trashedOutdatedFiles = {}
const downloadedFiles = {}
let totalDownloadedSize = 0
const firmwaresNeedingUpdateCount = Object.keys(firmwaresNeedingUpdate).length
let actualProgressCount = 0
let skippedCount = 0

if (allFirmwareInfo.devices && !userDidCancel) {
	setPreference('LastFirmwareUpdateCheck', startDate, 'date')
	setPreference('FirmwareUpdatesAvailable', firmwaresNeedingUpdateCount, 'int')
	if (firmwaresNeedingUpdateCount > 0) setProgressStopButtonToSkip()
}

if (firmwaresNeedingUpdateCount > 0) {
	Progress.totalUnitCount = (totalFirmwaresToUpdateSize / 100)
	Progress.completedUnitCount = 0

	if (isTahoeOrNewer && progressWindowProgressBar) {
		// There is a bug in macOS 26 Tahoe where determinate progress does not always update properly.
		// To (somewhat) workaround this (it still sometimes stutters back and forth), force the NSProgressIndicator to display after each progress update.

		progressWindowProgressBar.display
	}
}

for (const thisFirmwareFileName in firmwaresNeedingUpdate) {
	const thisDisplayDeviceNames = firmwaresNeedingUpdate[thisFirmwareFileName].displayDeviceNames
	const thisDisplayDeviceNamesTruncated = ((thisDisplayDeviceNames.length > 81) ? `${thisDisplayDeviceNames.slice(0, 40)}‚Ä¶${thisDisplayDeviceNames.slice(thisDisplayDeviceNames.length - 40)}` : thisDisplayDeviceNames)

	try {
		setProgressStopButtonEnabled(false)

		if (backgroundPIDs.length > 0) {
			try { app.doShellScript(`kill ${backgroundPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }
			backgroundPIDs.splice(0, backgroundPIDs.length)
		}

		actualProgressCount ++
		const progressBeforeDownload = Progress.completedUnitCount

		const thisProductSoftwareUpdatesFolder = firmwaresNeedingUpdate[thisFirmwareFileName].productSoftwareUpdatesFolder
		const iTunesSoftwareUpdatesFilePath = `${thisProductSoftwareUpdatesFolder}/${thisFirmwareFileName}`

		const thisFirmwareFileNameDisplay = ((thisFirmwareFileName.length > 81) ? `${thisFirmwareFileName.slice(0, 40)}‚Ä¶${thisFirmwareFileName.slice(thisFirmwareFileName.length - 40)}` : thisFirmwareFileName)

		const intendedFirmwareFileSize = firmwaresNeedingUpdate[thisFirmwareFileName].size
		const intendedFirmwareFileSizeDisplay = formatBytes(intendedFirmwareFileSize)

		const intendedFirmwareSHA1Sum = firmwaresNeedingUpdate[thisFirmwareFileName].sha1sum

		wakeMacUp()

		Progress.description = `${actualProgressCount} of ${firmwaresNeedingUpdateCount}: ${thisDisplayDeviceNamesTruncated}`
		Progress.additionalDescription = `
üì≤ Downloading: ${thisFirmwareFileNameDisplay}

üîÑ Initializing ${intendedFirmwareFileSizeDisplay} Download‚Ä¶`

		delay(0.1)

		setProgressStopButtonEnabled(true)

		if (!fileManager.fileExistsAtPath(iTunesSoftwareUpdatesFilePath) || (intendedFirmwareFileSize != fileManager.attributesOfItemAtPathError(iTunesSoftwareUpdatesFilePath, $()).objectForKey('NSFileSize').js) || (intendedFirmwareSHA1Sum != calculateChecksumForFile(iTunesSoftwareUpdatesFilePath))) {
			const downloadFirmwareFilePath = `${temporaryFilesFolder}/${thisFirmwareFileName}-download`
			firmwareProgressOutputFile = `${temporaryFilesFolder}/${thisFirmwareFileName}-progress`

			let maxDownloadAttempts = 3
			for (let downloadAttempt = 1; downloadAttempt <= maxDownloadAttempts; downloadAttempt ++) {
				setProgressStopButtonEnabled(true)

				if (downloadAttempt > 1)
					Progress.additionalDescription = `
üì≤ Downloading: ${thisFirmwareFileNameDisplay}

üîÑ Re-initializing ${intendedFirmwareFileSizeDisplay} Download‚Ä¶`

				Progress.completedUnitCount = progressBeforeDownload

				if (isTahoeOrNewer && progressWindowProgressBar) {
					// There is a bug in macOS 26 Tahoe where determinate progress does not always update properly.
					// To (somewhat) workaround this (it still sometimes stutters back and forth), force the NSProgressIndicator to display after each progress update.

					progressWindowProgressBar.display
				}

				try {
					let hasFreeSpaceToDownloadFile = true

					try {
						// "NSURLVolumeAvailableCapacityForImportantUsageKey" is the *real* free space to check and should always be available, but still get "NSURLVolumeAvailableCapacityKey" as a fallback since I have seen
						// that "NSURLVolumeAvailableCapacityForImportantUsageKey" can return "0" when run when no users are logged in or when run as another user (even though that should never be the case for a GUI app like this).
						// NOTE: The "$.NSURLVolumeAvailableCapacityForImportantUsageKey" and "$.NSURLVolumeAvailableCapacityKey" constants are not bridged in JXA on macOS 10.13 High Sierra (but are bridged on macOS 10.14 Mojave and newer), so use the string values instead which work on all versions of macOS.

						const availableCapacities = ObjC.deepUnwrap($.NSURL.fileURLWithPath(temporaryFilesFolder).resourceValuesForKeysError(['NSURLVolumeAvailableCapacityForImportantUsageKey', 'NSURLVolumeAvailableCapacityKey'], $()))
						const freeSpaceWithPadding = ((availableCapacities.NSURLVolumeAvailableCapacityForImportantUsageKey || availableCapacities.NSURLVolumeAvailableCapacityKey) - 10000000000) // Always leave at least 10 GB available on the system.
						hasFreeSpaceToDownloadFile = (freeSpaceWithPadding >= intendedFirmwareFileSize)
					} catch (ignoredError) {
						hasFreeSpaceToDownloadFile = true
					}

					if (!hasFreeSpaceToDownloadFile) {
						maxDownloadAttempts = 1
						throw new Error(`Not Enough Free Space to Download ${intendedFirmwareFileSizeDisplay} IPSW Firmware File`)
					}

					try {
						if (backgroundPIDs.length > 0) {
							try { app.doShellScript(`kill ${backgroundPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }
							backgroundPIDs.splice(0, backgroundPIDs.length)
						}

						const downloadFirmwarePID = app.doShellScript(`/usr/bin/curl --connect-timeout 5 -C - -fL ${quoteForShell(firmwaresNeedingUpdate[thisFirmwareFileName].url)} -o ${quoteForShell(downloadFirmwareFilePath)} > ${quoteForShell(firmwareProgressOutputFile)} 2>&1 & echo $!`)
						// NOTE: Downloads will be attempted 3 times, and the "curl" option "-C -" allows failed downloads from a previous to be resumed without losing previous attempt progress (this is assuming a previous attempt failed in some way that did not cause corruption, but if there is corruption the file will not pass the checksum verification and will not be used).

						backgroundPIDs.push(downloadFirmwarePID)
						debugLog(`Download ${thisFirmwareFileName} - CURL PID`, downloadFirmwarePID)

						try { app.doShellScript(`/usr/bin/caffeinate -dimsuw ${downloadFirmwarePID} > /dev/null 2>&1 &`) } catch (ignoredError) { /* Ignore */ } // Prevent this Mac from Sleeping while CURL is running.

						delay(1)

						for (let delaySeconds = 0; delaySeconds < 5; delaySeconds ++)
							if (!fileManager.fileExistsAtPath(firmwareProgressOutputFile))
								delay(1)
							else
								break

						let tickTock = true
						while (app.doShellScript(`kill -0 ${downloadFirmwarePID}; echo $?`) == 0) {
							let rawProgressSpeed = '0'
							try {
								rawProgressSpeed = $.NSString.stringWithContentsOfFileEncodingError(firmwareProgressOutputFile, $.NSUTF8StringEncoding, $()).js.split(/\n|\r/).slice(-1)[0].split(' ').slice(-1)[0]
							} catch (readProgressError) {
								if (readProgressError.errorNumber === -128)
									throw readProgressError
							}

							const downloadedFileSize = (fileManager.fileExistsAtPath(downloadFirmwareFilePath) ? fileManager.attributesOfItemAtPathError(downloadFirmwareFilePath, $()).objectForKey('NSFileSize').js : 0)

							let progressSpeedNumber = 0
							const lastSpeedChar = rawProgressSpeed.charAt(rawProgressSpeed.length - 1)
							if (lastSpeedChar == 'k') {
								rawProgressSpeed.slice(-1)
								progressSpeedNumber = (parseInt(rawProgressSpeed) * 1000)
							} else if (lastSpeedChar == 'M') {
								rawProgressSpeed.slice(-1)
								progressSpeedNumber = (parseFloat(rawProgressSpeed) * 1000000)
							} else
								progressSpeedNumber = parseInt(rawProgressSpeed)

							if (isNaN(progressSpeedNumber)) progressSpeedNumber = 0
							const progressSpeedString = `${formatBytes(progressSpeedNumber, 1)}/sec`
							Progress.completedUnitCount = (progressBeforeDownload + (downloadedFileSize / 100))

							if (isTahoeOrNewer && progressWindowProgressBar) {
								// There is a bug in macOS 26 Tahoe where determinate progress does not always update properly.
								// To (somewhat) workaround this (it still sometimes stutters back and forth), force the NSProgressIndicator to display after each progress update.

								progressWindowProgressBar.display
							}

							const hourGlass = (tickTock ? '‚è≥' : '‚åõÔ∏è')
							tickTock = !tickTock

							const progressPercentage = ((downloadedFileSize / intendedFirmwareFileSize) * 100).toFixed(1).replace('.0', '')

							Progress.additionalDescription = `
üì≤ Downloading: ${thisFirmwareFileNameDisplay}

${hourGlass} ${progressPercentage}% Downloaded: ${formatBytes(downloadedFileSize)} of ${intendedFirmwareFileSizeDisplay} @ ${progressSpeedString}`

							delay(1)
						}

						backgroundPIDs.splice(backgroundPIDs.indexOf(downloadFirmwarePID), 1)
					} catch (waitingForDownloadError) {
						setProgressStopButtonEnabled(false)

						debugLog('Waiting for Download Error', waitingForDownloadError)

						if (backgroundPIDs.length > 0) {
							try { app.doShellScript(`kill ${backgroundPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }
							backgroundPIDs.splice(0, backgroundPIDs.length)
						}

						throw waitingForDownloadError
					}

					if (!fileManager.fileExistsAtPath(downloadFirmwareFilePath))
						throw new Error('No IPSW Firmware File Downloaded')

					const downloadedFileSize = fileManager.attributesOfItemAtPathError(downloadFirmwareFilePath, $()).objectForKey('NSFileSize').js

					setProgressStopButtonEnabled(false)

					Progress.completedUnitCount = progressBeforeDownload + (downloadedFileSize / 100)

					if (isTahoeOrNewer && progressWindowProgressBar) {
						// There is a bug in macOS 26 Tahoe where determinate progress does not always update properly.
						// To (somewhat) workaround this (it still sometimes stutters back and forth), force the NSProgressIndicator to display after each progress update.

						progressWindowProgressBar.display
					}

					Progress.additionalDescription = `
üì≤ Downloaded: ${thisFirmwareFileNameDisplay}

üîç Verifying and Moving IPSW Firmware File‚Ä¶`

					delay(0.25)

					if (intendedFirmwareFileSize != downloadedFileSize)
						throw new Error(`Downloaded File Size (${downloadedFileSize}) != Intended Size (${intendedFirmwareFileSize})`)

					const downloadedFileSHA1Sum = calculateChecksumForFile(downloadFirmwareFilePath)
					if (intendedFirmwareSHA1Sum != downloadedFileSHA1Sum)
						throw new Error(`Downloaded File Checksum (${downloadedFileSHA1Sum}) != Intended Checksum (${intendedFirmwareSHA1Sum})`)

					if (fileManager.fileExistsAtPath(iTunesSoftwareUpdatesFilePath))
						try { fileManager.removeItemAtPathError(iTunesSoftwareUpdatesFilePath, $()) } catch (ignoredError) { /* Ignore */ }
					else if (!fileManager.fileExistsAtPath(thisProductSoftwareUpdatesFolder))
						fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(thisProductSoftwareUpdatesFolder, true, {}, $())

					try { fileManager.moveItemAtPathToPathError(downloadFirmwareFilePath, iTunesSoftwareUpdatesFilePath, $()) } catch (ignoredError) { /* Ignore */ }

					if (!fileManager.fileExistsAtPath(iTunesSoftwareUpdatesFilePath))
						throw new Error(`Failed to Move IPSW Firmware File to ${thisProductSoftwareUpdatesFolder}`)

					totalDownloadedSize += downloadedFileSize

					downloadedFiles[thisFirmwareFileName] = {
						Devices: thisDisplayDeviceNames,
						Version: firmwaresNeedingUpdate[thisFirmwareFileName].version,
						Size: formatBytes(downloadedFileSize)
					}

					break
				} catch (firmwareDownloadError) {
					setProgressStopButtonEnabled(false)

					if (backgroundPIDs.length > 0) {
						try { app.doShellScript(`kill ${backgroundPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }
						backgroundPIDs.splice(0, backgroundPIDs.length)
					}

					if (!userDidCancel) userDidCancel = (firmwareDownloadError.errorNumber === -128)

					let firmwareDownloadErrorMessage = firmwareDownloadError.message

					try {
						const progressOutputParts = $.NSString.stringWithContentsOfFileEncodingError(firmwareProgressOutputFile, $.NSUTF8StringEncoding, $()).js.split('curl: ')
						if (progressOutputParts.length > 1)
							firmwareDownloadErrorMessage = `CURL Error: ${progressOutputParts.slice(-1)[0].trim()}`
					} catch (ignoredError) { /* Ignore */ }

					firmwareDownloadErrorMessage = firmwareDownloadErrorMessage.replace(/\n|\r/g, '')

					debugLog(`Error Downloading Firmware (${thisFirmwareFileName}) Attempt ${downloadAttempt} of ${maxDownloadAttempts}: ${firmwareDownloadErrorMessage}`, firmwareDownloadError)

					if ((downloadAttempt == maxDownloadAttempts) || !firmwareDownloadError.message.includes('!= Intended Size'))
						try { fileManager.removeItemAtPathError(downloadFirmwareFilePath, $()) } catch (ignoredError) { /* Ignore */ }
					else
						debugLog('NOT Deleting Incomplete Firmware Download to Allow Next Attempt to Resume')

					if (userDidCancel) break // Break before errors get saved in Updates Log when user canceled.

					if (!downloadErrors[thisFirmwareFileName]) downloadErrors[thisFirmwareFileName] = {}
					downloadErrors[thisFirmwareFileName][`Attempt ${downloadAttempt} of ${maxDownloadAttempts}`] = firmwareDownloadErrorMessage
				}
			}

			try { fileManager.removeItemAtPathError(firmwareProgressOutputFile, $()) } catch (ignoredError) { /* Ignore */ }
		}

		setProgressStopButtonEnabled(false)

		if (fileManager.fileExistsAtPath(iTunesSoftwareUpdatesFilePath) && (intendedFirmwareFileSize == fileManager.attributesOfItemAtPathError(iTunesSoftwareUpdatesFilePath, $()).objectForKey('NSFileSize').js) && (intendedFirmwareSHA1Sum == calculateChecksumForFile(iTunesSoftwareUpdatesFilePath))) {
			newManagedFirmware[thisFirmwareFileName] = thisDisplayDeviceNames
			for (const thisOldManagedFirmwareFileName in oldManagedFirmware)
				if ((thisOldManagedFirmwareFileName != thisFirmwareFileName) && (oldManagedFirmware[thisOldManagedFirmwareFileName] == thisDisplayDeviceNames)) {
					const thisOldManagedFirmwarePath = `${thisProductSoftwareUpdatesFolder}/${thisOldManagedFirmwareFileName}`

					try {
						if (fileManager.fileExistsAtPath(thisOldManagedFirmwarePath)) {
							if (trashOrDeleteOutdatedFirmware(thisOldManagedFirmwarePath))
								trashedOutdatedFiles[thisOldManagedFirmwareFileName] = {
									Devices: thisDisplayDeviceNames,
									Reason: 'Downloaded Update'
								}
						} else if (fileManager.fileExistsAtPath(`${userTrashPath}/${thisOldManagedFirmwareFileName}`)) {
							trashedOutdatedFiles[thisOldManagedFirmwareFileName] = {
								Devices: thisDisplayDeviceNames,
								Reason: 'Downloaded Update (File Already in Trash)'
							}
						}
					} catch (cleanUpAfterDownloadError) {
						debugLog('Clean Up After Download Error', cleanUpAfterDownloadError)

						if (!userDidCancel) userDidCancel = (cleanUpAfterDownloadError.errorNumber === -128)
					}

					break
				}
		}

		Progress.completedUnitCount = progressBeforeDownload + (intendedFirmwareFileSize / 100)

		if (isTahoeOrNewer && progressWindowProgressBar) {
			// There is a bug in macOS 26 Tahoe where determinate progress does not always update properly.
			// To (somewhat) workaround this (it still sometimes stutters back and forth), force the NSProgressIndicator to display after each progress update.

			progressWindowProgressBar.display
		}

		if (userDidCancel) {
			Progress.additionalDescription = `

‚è≠Ô∏è Skipped: ${thisFirmwareFileNameDisplay}
`
			throw new Error('Skipped Download Because User Canceled')
		}

		delay(0.25)
	} catch (updatingError) {
		setProgressStopButtonEnabled(false)

		debugLog('Updating Error', updatingError)

		if (backgroundPIDs.length > 0) {
			try { app.doShellScript(`kill ${backgroundPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }
			backgroundPIDs.splice(0, backgroundPIDs.length)
		}

		if (userDidCancel || (updatingError.errorNumber === -128)) {
			skippedCount ++

			if (firmwaresNeedingUpdateCount > actualProgressCount) {
				try {
					app.activate()
					app.displayAlert('Are you sure you want to skip all remaining updates?',
						{
							message: 'Remaining updates will be skipped in 30 seconds‚Ä¶',
							as: 'critical',
							buttons: [`Just Skip ‚Äú${thisDisplayDeviceNamesTruncated}‚Äù`, 'Skip Remaining Updates'],
							cancelButton: 1,
							defaultButton: 2,
							givingUpAfter: 30
						}
					)

					userDidCancel = true // If gaveUp or defaultButton, then really cancel and skip all.
				} catch (confirmCancelError) {
					if (confirmCancelError.errorNumber === -128) // This time, -128 is the user selecting "cancelButton" which is choosing to just skip one, not all.
						userDidCancel = false // So, undo previously set "userDidCancel" to keep going after just skipping one.
					else
						debugLog('Confirm Cancel Error', updatingError)
				}

				if (userDidCancel) {
					skippedCount += (firmwaresNeedingUpdateCount - actualProgressCount)
					Progress.additionalDescription = `

‚è≠Ô∏è Skipped Remaining Updates‚Ä¶
`
					break
				}
			} else {
				userDidCancel = true
				break
			}
		}
	}
}

for ( ; ; ) {
	try {
		if (backgroundPIDs.length > 0) {
			try { app.doShellScript(`kill ${backgroundPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }
			backgroundPIDs.splice(0, backgroundPIDs.length)
		}

		setProgressStopButtonEnabled(false)
		setProgressSkipButtonToStop()

		Progress.totalUnitCount = 1
		Progress.completedUnitCount = 1

		if (isTahoeOrNewer && progressWindowProgressBar) {
			// There is a bug in macOS 26 Tahoe where determinate progress does not always update properly.
			// To (somewhat) workaround this (it still sometimes stutters back and forth), force the NSProgressIndicator to display after each progress update.

			progressWindowProgressBar.display
		}

		delay(0.1)

		let isInitialDownloads = false
		const failedToLoadFirmwareInfo = (!allFirmwareInfo.devices && !allFirmwareInfo.iTunes && !userDidCancel)
		const ipswMeUpdatingFirmwareInfo = (!allFirmwareInfo.devices && allFirmwareInfo.iTunes && !userDidCancel) // When new firmwares are released and ipsw.me is updating, the "iTunes" object will exist, but the "devices" object will be null.
		const isUpToDate = (!userDidCancel && (firmwaresNeedingUpdateCount == 0))
		const downloadedFilesCount = Object.keys(downloadedFiles).length
		const downloadErrorsCount = Object.keys(downloadErrors).length
		const failedToDownloadAnyUpdates = (allFirmwareInfo.devices && !userDidCancel && !isUpToDate && (downloadedFilesCount == 0))
		const downloadedAllUpdates = (firmwaresNeedingUpdateCount == downloadedFilesCount)

		setPreference('FirmwareUpdatesAvailable', (firmwaresNeedingUpdateCount - downloadedFilesCount), 'int')

		if (downloadedFilesCount > 0) {
			lastUpdateSummary = ''
			lastErrorSummary = ''

			isInitialDownloads = true

			if (updatesLog.length > 0)
				for (let updateIndex = (updatesLog.length - 1); updateIndex >= 0; updateIndex --) {
					const thisUpdate = updatesLog[updateIndex]
					if (thisUpdate.Status && (thisUpdate.Status.includes('Updated') || thisUpdate.Status.includes('Initial'))) {
						isInitialDownloads = false
						break
					}
				}
		} else if (downloadErrorsCount > 0)
			lastErrorSummary = ''

		wakeMacUp()

		Progress.description = `
üóë	Cleaning Up After ${(failedToLoadFirmwareInfo ?
			'Error Loading Firmware Information' :
			(ipswMeUpdatingFirmwareInfo ?
				'Detecting That ipsw.me Is Updating Firmware Info' :
				(failedToDownloadAnyUpdates ?
					'Error Updating Any IPSW Firmware Files' :
					(isUpToDate ?
						'Checking for Updates' :
						(userDidCancel ?
							((skippedCount > 0) ?
								((downloadedFilesCount > 0) ?
									'Updating and Skipping' :
									'Skipping'
								) :
								'Stopping'
							) :
							(isInitialDownloads ?
								'Initial IPSW Firmware Downloads' :
								'Updating IPSW Firmware Files'
							)
						)
					)
				)
			)
		)}`
		Progress.additionalDescription = ''

		delay(0.5)

		try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }

		//debugDialog(newManagedFirmware)

		if (!failedToLoadFirmwareInfo && !ipswMeUpdatingFirmwareInfo) {
			Progress.totalUnitCount = Object.keys(oldManagedFirmware).length + 2
			Progress.completedUnitCount = Progress.totalUnitCount

			if (isTahoeOrNewer && progressWindowProgressBar) {
				// There is a bug in macOS 26 Tahoe where determinate progress does not always update properly.
				// To (somewhat) workaround this (it still sometimes stutters back and forth), force the NSProgressIndicator to display after each progress update.

				progressWindowProgressBar.display
			}

			const checkedSoftwareUpdatesFolderForUnsignedFirmware = []

			for (const thisProductType of everyProductType)
				if (!excludedProducts.includes(thisProductType)) {
					const thisProductSoftwareUpdatesFolder = ((thisProductType.startsWith('iP')) ? `${libraryITunesFolder}/${thisProductType.replace(' touch', '')} Software Updates` : appleConfiguratorFirmwareFolder)

					if (!checkedSoftwareUpdatesFolderForUnsignedFirmware.includes(thisProductSoftwareUpdatesFolder)) {
						try {
							if (fileManager.fileExistsAtPath(thisProductSoftwareUpdatesFolder)) {
								for (const thisFirmwareFileNameInSoftwareUpdatesFolder of ObjC.deepUnwrap(fileManager.contentsOfDirectoryAtPathError(thisProductSoftwareUpdatesFolder, $())))
									if (!newManagedFirmware[thisFirmwareFileNameInSoftwareUpdatesFolder] && unsignedFirmwares.includes(thisFirmwareFileNameInSoftwareUpdatesFolder) && trashOrDeleteOutdatedFirmware(`${thisProductSoftwareUpdatesFolder}/${thisFirmwareFileNameInSoftwareUpdatesFolder}`))
										trashedOutdatedFiles[thisFirmwareFileNameInSoftwareUpdatesFolder] = {Reason: 'No Longer Signed by Apple'}
							}

							checkedSoftwareUpdatesFolderForUnsignedFirmware.push(thisProductSoftwareUpdatesFolder)
						} catch (trashUnsignedFirmwareError) {
							debugLog('Trash Unsigned Firmware Error', trashUnsignedFirmwareError)

							if (!userDidCancel) userDidCancel = (trashUnsignedFirmwareError.errorNumber === -128)
						}
					}
				}

			Progress.completedUnitCount --

			if (isTahoeOrNewer && progressWindowProgressBar) {
				// There is a bug in macOS 26 Tahoe where determinate progress does not always update properly.
				// To (somewhat) workaround this (it still sometimes stutters back and forth), force the NSProgressIndicator to display after each progress update.

				progressWindowProgressBar.display
			}

			delay(0.01)

			for (const thisOldManagedFirmwareFileName in oldManagedFirmware) {
				try {
					if (!newManagedFirmware[thisOldManagedFirmwareFileName]) {
						const thisOldManagedFirmwareDisplayDeviceNames = oldManagedFirmware[thisOldManagedFirmwareFileName]

						if (!userDidCancel && downloadedAllUpdates) {
							for (const thisProductType of everyProductType)
								if (thisOldManagedFirmwareDisplayDeviceNames.includes(thisProductType) || (thisOldManagedFirmwareDisplayDeviceNames.startsWith('iBridge') && thisProductType.includes('iBridge')) || (thisOldManagedFirmwareDisplayDeviceNames.includes('Mac') && thisProductType.includes('Silicon'))) {
									const thisOldManagedFirmwarePath = `${((thisProductType.startsWith('iP')) ? `${libraryITunesFolder}/${thisProductType.replace(' touch', '')} Software Updates` : appleConfiguratorFirmwareFolder)}/${thisOldManagedFirmwareFileName}`

									if (fileManager.fileExistsAtPath(thisOldManagedFirmwarePath)) {
										if (excludedProducts.includes(thisProductType))
											newManagedFirmware[thisOldManagedFirmwareFileName] = thisOldManagedFirmwareDisplayDeviceNames
										else if (trashOrDeleteOutdatedFirmware(thisOldManagedFirmwarePath))
											trashedOutdatedFiles[thisOldManagedFirmwareFileName] = {Reason: 'Not Associated with Any Current Device'}
									} else if (!trashedOutdatedFiles[thisOldManagedFirmwareFileName] && fileManager.fileExistsAtPath(`${userTrashPath}/${thisOldManagedFirmwareFileName}`))
										trashedOutdatedFiles[thisOldManagedFirmwareFileName] = {
											Devices: thisOldManagedFirmwareDisplayDeviceNames,
											Reason: 'Not Associated with Any Current Device (File Already in Trash)'
										}

									break
								}
						} else
							newManagedFirmware[thisOldManagedFirmwareFileName] = thisOldManagedFirmwareDisplayDeviceNames
					}
				} catch (cleanUpAfterUpdateError) {
					debugLog('Clean Up After Update Error', cleanUpAfterUpdateError)

					if (!userDidCancel) userDidCancel = (cleanUpAfterUpdateError.errorNumber === -128)
				}

				Progress.completedUnitCount --

				if (isTahoeOrNewer && progressWindowProgressBar) {
					// There is a bug in macOS 26 Tahoe where determinate progress does not always update properly.
					// To (somewhat) workaround this (it still sometimes stutters back and forth), force the NSProgressIndicator to display after each progress update.

					progressWindowProgressBar.display
				}

				delay(0.01)
			}

			if (JSON.stringify(oldManagedFirmware) != JSON.stringify(newManagedFirmware))
				setPreference('ManagedFirmwares', newManagedFirmware, 'dict')

			Progress.completedUnitCount = 0

			if (isTahoeOrNewer && progressWindowProgressBar) {
				// There is a bug in macOS 26 Tahoe where determinate progress does not always update properly.
				// To (somewhat) workaround this (it still sometimes stutters back and forth), force the NSProgressIndicator to display after each progress update.

				progressWindowProgressBar.display
			}

			delay(1.5) // Sleep a moment to show completed (reverse) progress.
		}

		const trashedOutdatedFilesCount = Object.keys(trashedOutdatedFiles).length

		const endDate = new Date()

		const logStatus = `${(failedToLoadFirmwareInfo ?
			'Load Error' :
			(ipswMeUpdatingFirmwareInfo ?
				'ipsw.me Updating Firmware Info' :
				(failedToDownloadAnyUpdates ?
					'Update Error' :
					(isUpToDate ?
						'Up-to-Date' :
						(userDidCancel ?
							((skippedCount > 0) ?
								((downloadedFilesCount > 0) ?
									'Updated + Skipped' :
									'Skipped'
								) :
								'Stopped'
							) :
							(isInitialDownloads ?
								'Initial Downloads' :
								'Updated'
							)
						)
					)
				)
			)
		)}${((!failedToLoadFirmwareInfo && !ipswMeUpdatingFirmwareInfo && !failedToDownloadAnyUpdates && (downloadErrorsCount > 0)) ? ' + Errors' : '')}`

		debugLog('Finished Checking for IPSW Firmware Updates', logStatus)

		const startDateDisplay = `${startDate.toLocaleDateString('en-US', dateFormatOptions)} @ ${startDate.toLocaleTimeString('en-US')}`

		let updatedUpdatesLog = false
		if ((downloadedFilesCount > 0) || (downloadErrorsCount > 0) || (trashedOutdatedFilesCount > 0)) {
			if ((downloadedFilesCount > 0) || (downloadErrorsCount > 0))
				setPreference('AcknowledgedSignificantResults', false, 'bool')

			updatesLog.unshift({
				Status: logStatus,
				Times: {
					Start: startDateDisplay,
					End: `${endDate.toLocaleDateString('en-US', dateFormatOptions)} @ ${endDate.toLocaleTimeString('en-US')}`,
					Duration: durationConversion(endDate.getTime() - startDate.getTime())
				},
				Downloaded: {
					'Total Size': formatBytes(totalDownloadedSize),
					Files: downloadedFiles,
					Skipped: skippedCount
				},
				Trashed: {
					'Outdated Files': trashedOutdatedFiles
				},
				Errors: downloadErrors
			})

			updatedUpdatesLog = true

			//debugDialog(updatesLog)

			try {
				const writeUpdateLogFileError = $()
				if (!$(JSON.stringify(updatesLog, null, 4)).writeToFileAtomicallyEncodingError(updatesLogPath, true, $.NSUTF8StringEncoding, writeUpdateLogFileError)) { // NOTE: NOT using "$.NSString.alloc.initWithDataEncoding($.NSJSONSerialization.dataWithJSONObjectOptionsError(...), ...).writeToFileAtomicallyEncodingError(...)" to write this JSON to the file since it alters the order of the keys within dicts, which should be preserved since it's the desired dispay order of this human readable "Updates Log.json" file.
					if (!writeUpdateLogFileError.isNil()) throw new Error(writeUpdateLogFileError.description.js)
					throw new Error('Write Updates Log JSON Failed')
				}
			} catch (writeUpdatedLogError) {
				debugLog('Write "Updates Log.json" Error', writeUpdatedLogError)
			}
		}

		wakeMacUp()

		let dialogTimedOutEarly = false
		do {
			try {
				let trashedFilesDisplay = ''
				if (trashedOutdatedFilesCount > 0) {
					trashedFilesDisplay = `

üóë ${shouldImmediatelyDeleteOutdatedFirmwares ? 'Deleted' : 'Trashed'} ${trashedOutdatedFilesCount} Outdated IPSW File${((trashedOutdatedFilesCount == 1) ? '' : 's')}${shouldImmediatelyDeleteOutdatedFirmwares ? '' : `
	üëâ ‚ÄúEmpty Trash‚Äù in Finder to Delete File${((trashedOutdatedFilesCount == 1) ? '' : 's')}`}`
				}

				let downloadErrorsDisplay = ''
				if (!failedToLoadFirmwareInfo && !ipswMeUpdatingFirmwareInfo && (downloadErrorsCount > 0))
					downloadErrorsDisplay = `

‚ö†Ô∏è ${downloadErrorsCount} Download Error${((downloadErrorsCount == 1) ? '' : 's')} Occurred`

				const appUpdateAvailable = getPreference('AppUpdateAvailable', 'bool')
				const resultsDialogButtons = [(appUpdateAvailable ? 'Update App‚Ä¶' : 'Quit')]

				let openUpdatesLogDisplay = ''
				if ((updatedUpdatesLog && !failedToLoadFirmwareInfo && !ipswMeUpdatingFirmwareInfo) || lastUpdateSummary || lastErrorSummary) {
					resultsDialogButtons.unshift('View ‚ÄúUpdates Log‚Äù File')
					openUpdatesLogDisplay = `

üìù View the ‚ÄúUpdates Log‚Äù file for full details.`
				}

				if (failedToLoadFirmwareInfo || ipswMeUpdatingFirmwareInfo)
					resultsDialogButtons.unshift('Visit ipsw.me')

				while (resultsDialogButtons.length > 3)
					resultsDialogButtons.shift()

				const autoLaunchSchedule = parseLaunchAgentSchedule()
				const didAcknowledgeSignificantResultsAndUpToDate = (getPreference('AcknowledgedSignificantResults', 'bool') && !appUpdateAvailable)

				const nowDate = new Date()

				let giveUpDate = new Date(nowDate)
				if (didAcknowledgeSignificantResultsAndUpToDate)
					giveUpDate.setMinutes(giveUpDate.getMinutes() + 30)
				else
					giveUpDate.setMonth(giveUpDate.getMonth() + 1)

				if (autoLaunchSchedule.days.length > 0) {
					const everyDayOfTheWeekStartingWithSunday = everyDayOfTheWeek.slice(-1).concat(everyDayOfTheWeek.slice(0, -1))

					const todayIndex = nowDate.getDay()
					const thisDayOfWeek = everyDayOfTheWeekStartingWithSunday[todayIndex]

					let nextAutoLaunchDayIndex = -1

					for (const autoLaunchDayOfWeek of autoLaunchSchedule.days) {
						let autoLaunchDayIndex = everyDayOfTheWeekStartingWithSunday.indexOf(autoLaunchDayOfWeek)

						if (autoLaunchDayIndex > todayIndex) {
							nextAutoLaunchDayIndex = autoLaunchDayIndex
							break
						} else if ((nextAutoLaunchDayIndex == -1) || (autoLaunchDayIndex < nextAutoLaunchDayIndex))
							nextAutoLaunchDayIndex = autoLaunchDayIndex
					}

					if (nextAutoLaunchDayIndex > -1) {
						const daysUntilNextAutoLaunchDay = ((nextAutoLaunchDayIndex < todayIndex) ? (7 - todayIndex + nextAutoLaunchDayIndex) : (nextAutoLaunchDayIndex - todayIndex))

						const autoLaunchGiveUpDate = new Date(nowDate.getFullYear(), nowDate.getMonth(), (nowDate.getDate() + (((nowDate.getHours() < autoLaunchSchedule.hour) && autoLaunchSchedule.days.includes(thisDayOfWeek)) ? 0 : daysUntilNextAutoLaunchDay)), autoLaunchSchedule.hour, autoLaunchSchedule.minute - 10)

						if (autoLaunchGiveUpDate.getTime() < giveUpDate.getTime())
							giveUpDate = autoLaunchGiveUpDate
					}
				}

				let giveUpAfterSeconds = -1

				const resultsSummary = (failedToLoadFirmwareInfo ?
					`‚ùå Error Loading IPSW Firmware Information

‚ö†Ô∏è ${globalGetFirmwaresErrorMessage}

üö´ ipsw.me is down or you're not connected to the internet.` :
					(ipswMeUpdatingFirmwareInfo ?
						`üîÑ ipsw.me Is Currently Updating Firmware Information

‚è±Ô∏è This may take a few hours, please try again later today.` :
						`${(failedToDownloadAnyUpdates ?
							`‚ùå Error Updating ${firmwaresNeedingUpdateCount} IPSW Firmware File${((firmwaresNeedingUpdateCount == 1) ? '' : 's')}` :
							(isUpToDate ?
								`üëç All IPSW Firmware Files are Up-to-Date as of
üóì ${startDateDisplay}` :
								((downloadedFilesCount > 0) ?
									`‚úÖ ${(isInitialDownloads ? 'Initial Download of' : 'Updated')} ${downloadedFilesCount} IPSW File${((downloadedFilesCount == 1) ? '' : 's')} (${formatBytes(totalDownloadedSize)})` :
									((userDidCancel && (skippedCount == 0)) ? 'üõë Stopped' : '')
								)
							)
						)}${createVersionsDownloadedSummary(downloadedFiles)}${((skippedCount > 0) ? `${(failedToDownloadAnyUpdates || (downloadedFilesCount > 0)) ? `

` : ''}‚è≠Ô∏è Skipped ${skippedCount} Update${((skippedCount == 1) ? '' : 's')}` : '')}${downloadErrorsDisplay}

‚è±Ô∏è Finished in ${durationConversion(endDate.getTime() - startDate.getTime())}.${trashedFilesDisplay}`
					)
				)

				for ( ; ; ) {
					giveUpAfterSeconds = Math.round((giveUpDate.getTime() - new Date().getTime()) / 1000)

					if (giveUpAfterSeconds <= 0) {
						debugLog(`Auto-Quitting: Hit Give Up Time BEFORE Showing ${didAcknowledgeSignificantResultsAndUpToDate ? 'Insignificant' : 'Significant'} Results`)
						cleanUpAndQuitEarly()
					}

					if (!macIsAwakeAndUnlocked()) { // AppleScript dialogs will timeout early if Mac is asleep when it's displayed, but progress can be displayed properly. So, wait until Mac is awake to display the dialog.
						if (Progress.description != resultsSummary) {
							Progress.description = resultsSummary
							Progress.additionalDescription = `
üí§ Waiting until Mac wakes up to show full results‚Ä¶`
							Progress.totalUnitCount = -1
							Progress.completedUnitCount = 0

							if (isBigSurOrNewer && progressWindowProgressBar) {
								// There is a bug in macOS 11 Big Sur where setting indeterminate progress AFTER determinate progress has been shown just displays 0 progress.
								// To workaround this, startAnimation on the NSProgressIndicator directly.

								progressWindowProgressBar.startAnimation(null)
							}
						}

						delay(15)
					} else
						break
				}

				if (failedToLoadFirmwareInfo || ipswMeUpdatingFirmwareInfo || failedToDownloadAnyUpdates || userDidCancel || !isUpToDate) {
					try {
						$.NSSound.soundNamed((failedToLoadFirmwareInfo || ipswMeUpdatingFirmwareInfo || failedToDownloadAnyUpdates || userDidCancel) ? 'Basso' : 'Glass').play
					} catch (ignoredError) {
						app.beep()
					}
				}

				dialogTimedOutEarly = false

				closeProgressWindow()

				debugLog(`Showing ${didAcknowledgeSignificantResultsAndUpToDate ? 'Insignificant' : 'Significant'} Results with Give Up Seconds`, giveUpAfterSeconds)

				app.activate()

				const fullResultsSummary = `${lastErrorSummary}${lastUpdateSummary}${openUpdatesLogDisplay}${(appUpdateAvailable ? `

‚§¥Ô∏è An App Update is Available!` : '')}`

				const resultsDialogReply = app.displayDialog(`${resultsSummary}${fullResultsSummary ? `
${fullResultsSummary}` : ''}`,
					{
						withTitle: `${appName}  ‚Äî  ${logStatus}`,
						withIcon: ((failedToLoadFirmwareInfo || ipswMeUpdatingFirmwareInfo || failedToDownloadAnyUpdates) ? 'caution' : 'note'),
						buttons: resultsDialogButtons,
						// Decided cancelButton is not wanted here and would also be more complex because dialog could be displayed with only a single button.
						defaultButton: resultsDialogButtons.length,
						givingUpAfter: giveUpAfterSeconds
					},
					{timeout: (giveUpAfterSeconds + 30)}
				) // Set dialog to timeout after give up time, but it will still timeout early if Mac is asleep when it's displayed.

				if (resultsDialogReply.gaveUp)
					debugLog(`Auto-Quitting: Hit Give Up Time WHILE Showing ${didAcknowledgeSignificantResultsAndUpToDate ? 'Insignificant' : 'Significant'} Results`)
				else {
					setPreference('AcknowledgedSignificantResults', true, 'bool')

					if (resultsDialogReply.buttonReturned == 'View ‚ÄúUpdates Log‚Äù File')
						sharedWorkspace.openURL($.NSURL.fileURLWithPath(updatesLogPath))
					else if (resultsDialogReply.buttonReturned == 'Visit ipsw.me')
						sharedWorkspace.openURL($.NSURL.URLWithString('https://ipsw.me'))
				}
			} catch (displayResultsError) {
				debugLog('Display Results Error', displayResultsError)
				if (displayResultsError.errorNumber === -1712) { // https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_error_codes.html#//apple_ref/doc/uid/TP40000983-CH220-SW6
					dialogTimedOutEarly = true
					delay(15)
				}
			}
		} while (dialogTimedOutEarly)

		break
	} catch (showResultsError) {
		if (showResultsError.errorNumber !== -128)
			break
	}
}

if (getPreference('AppUpdateAvailable', 'bool'))
	checkAndInstallAppUpdates()

function displayAlertOrDialogDependingOnOS(titleText, messageText, windowTitle, icon, buttons, cancelButton, defaultButton, givingUpAfter) {
	// On macOS 10.15 Catalina and older, the alert window size is very similar to the dialog window size in that is it wide with left aligned text and look good for the long detailed messages displayed by IPSW Updater.
	// On macOS 11 Big Sur and macOS 12 Monterey, alerts will only ever be a "compact" layout with a narrow window and centered text (and long text could need to be scrolled).
	// This style looks very bad for the long detailed messages displayed by IPSW Updater, so a dialog will be used instead on those versions of macOS.
	// On macOS 13 Ventura and newer, alerts with long text will be displayed in a new "expanded" layout with a wide and tall window (https://developer.apple.com/videos/play/wwdc2022/10074/?time=728)
	// which is similar to the older macOS 10.15 Catalina and older alert style and doesn't have centered text (and is not scrollable).
	// macOS 13 Ventura and newer will still use the "compact" layout for short alerts and will automatically switch to the "expanded" layout when the text is long.
	// The exact parameters of when the "expanded" layout is triggered is not totally obvious since it could either be some number of lines, or just the total amount of text.
	// This "expanded" layout looks good and is usable for the long detailed messages displayed by IPSW Updater so it will be used for certain long messages where approriate.

	const dialogOrAlertProperties = {}
	if (buttons) dialogOrAlertProperties.buttons = buttons
	if (cancelButton) dialogOrAlertProperties.cancelButton = cancelButton
	if (defaultButton) dialogOrAlertProperties.defaultButton = defaultButton
	if (givingUpAfter) dialogOrAlertProperties.givingUpAfter = givingUpAfter

	if (!getPreference('ForceDialogWindowStyle', 'bool') && (!isBigSurOrNewer || isVenturaOrNewer)) {
		if (isVenturaOrNewer) {
			// NOTE: One BIG catch with the macOS 11 Big Sur and newer alert style is that all leading whitespace for each line will be trimmed.
			// This makes sense so that centered text always looks decent, but that leading whitespace will STILL be trimmed when the new
			// "extended" alert style is used on macOS 13 Ventura and newer, which is not necessary since the text will be left aligned.
			// Since the messages displayed by IPSW Updater rely on tab indented formatting to look correct, this trimming behavior is worked around by replacing the first
			// TAB on each line with NUL+TAB so that the line will no longer start with whitespace (since it will start with a NUL char instead) and therefore will NOT be trimmed.

			if (titleText.includes('\t')) titleText = titleText.replace(/^\t/gm, '\0\t')
			if (messageText.includes('\t')) messageText = messageText.replace(/^\t/gm, '\0\t')
		}

		if (messageText) dialogOrAlertProperties.message = messageText
		if ((icon == 'caution') || (icon == 'stop') || (icon == 'critical') || (icon == 'warning')) dialogOrAlertProperties.as = 'critical'
		// Do not need to explicitly set "as" to "informational" if "note" is specified since it is the default.

		return app.displayAlert(titleText, dialogOrAlertProperties)
	} else {
		if (windowTitle) dialogOrAlertProperties.withTitle = windowTitle
		if (icon == 'informational') icon = 'note'
		if ((icon == 'critical') || (icon == 'warning')) icon = 'caution'
		if (icon) dialogOrAlertProperties.withIcon = icon

		return app.displayDialog(`${titleText}${((titleText && messageText) ? '\n\n' : '')}${messageText}`, dialogOrAlertProperties)
	}
}

function createVersionsDownloadedSummary(downloadedFiles, indentLevel = 0) {
	let versionsDownloadedDisplay = ''

	const versionsDownloadedForEachOS = {}
	for (const thisDownloadedFirmwareFileName in downloadedFiles) {
		let thisOSname = ''
		if (thisDownloadedFirmwareFileName.startsWith('iPhone') || thisDownloadedFirmwareFileName.startsWith('iPod')) thisOSname = 'iOS'
		else if (thisDownloadedFirmwareFileName.startsWith('iPad')) thisOSname = 'iPadOS'
		else if (thisDownloadedFirmwareFileName.startsWith('AppleTV')) thisOSname = 'tvOS'
		else if (thisDownloadedFirmwareFileName.startsWith('Audio')) thisOSname = 'audioOS'
		else if (thisDownloadedFirmwareFileName.startsWith('Apple_Vision')) thisOSname = 'visionOS'
		else if (thisDownloadedFirmwareFileName.startsWith('iBridge')) thisOSname = 'bridgeOS'
		else if (thisDownloadedFirmwareFileName.startsWith('UniversalMac')) thisOSname = 'macOS'

		if (thisOSname) {
			if (!versionsDownloadedForEachOS[thisOSname]) versionsDownloadedForEachOS[thisOSname] = []
			const thisDownloadedVersion = downloadedFiles[thisDownloadedFirmwareFileName].Version
			if (!versionsDownloadedForEachOS[thisOSname].includes(thisDownloadedVersion)) versionsDownloadedForEachOS[thisOSname].push(thisDownloadedVersion)
		}
	}

	let downloadedVersionsCount = 0
	for (const thisVersionsForOS in versionsDownloadedForEachOS) {
		downloadedVersionsCount += versionsDownloadedForEachOS[thisVersionsForOS].length
		versionsDownloadedForEachOS[thisVersionsForOS].sort((thisVersion, thatVersion) => $(thatVersion).compareOptions(thisVersion, $.NSNumericSearch))
	}

	if (downloadedVersionsCount > 0) {
		let indentTabs = ''
		for (let thisIndentIndex = 0; thisIndentIndex < indentLevel; thisIndentIndex ++)
			indentTabs += '\t'

		const onlyOneVersionDownloaded = (downloadedVersionsCount == 1)
		versionsDownloadedDisplay = `
${indentTabs}üçè Version${(onlyOneVersionDownloaded ? '' : 's')} Downloaded:`

		if (onlyOneVersionDownloaded) {
			const downloadedOSname = Object.keys(versionsDownloadedForEachOS)[0]
			versionsDownloadedDisplay += ` ${downloadedOSname} ${versionsDownloadedForEachOS[downloadedOSname][0]}`
		} else {
			// DON'T do this in a loop so that it's always displayed in this exact desired order.
			if (versionsDownloadedForEachOS.iOS) versionsDownloadedDisplay += `\n\t${indentTabs}iOS ${versionsDownloadedForEachOS.iOS.join(', ')}`
			if (versionsDownloadedForEachOS.iPadOS) versionsDownloadedDisplay += `\n\t${indentTabs}iPadOS ${versionsDownloadedForEachOS.iPadOS.join(', ')}`
			if (versionsDownloadedForEachOS.tvOS) versionsDownloadedDisplay += `\n\t${indentTabs}tvOS ${versionsDownloadedForEachOS.tvOS.join(', ')}`
			if (versionsDownloadedForEachOS.audioOS) versionsDownloadedDisplay += `\n\t${indentTabs}audioOS ${versionsDownloadedForEachOS.audioOS.join(', ')}`
			if (versionsDownloadedForEachOS.visionOS) versionsDownloadedDisplay += `\n\t${indentTabs}visionOS ${versionsDownloadedForEachOS.visionOS.join(', ')}`
			if (versionsDownloadedForEachOS.bridgeOS) versionsDownloadedDisplay += `\n\t${indentTabs}bridgeOS ${versionsDownloadedForEachOS.bridgeOS.join(', ')}`
			if (versionsDownloadedForEachOS.macOS) versionsDownloadedDisplay += `\n\t${indentTabs}macOS ${versionsDownloadedForEachOS.macOS.join(', ')}`
		}
	}

	return versionsDownloadedDisplay
}

function trashOrDeleteOutdatedFirmware(ipswFilePathToTrashOrDelete) {
	try {
		if (fileManager.fileExistsAtPath(ipswFilePathToTrashOrDelete)) {
			if (shouldImmediatelyDeleteOutdatedFirmwares)
				return fileManager.removeItemAtPathError(ipswFilePathToTrashOrDelete, $())
			else
				return fileManager.trashItemAtURLResultingItemURLError($.NSURL.fileURLWithPath(ipswFilePathToTrashOrDelete), $(), $())
		}

		return true
	} catch (ignoredError) {
		return false
	}
}

function wakeMacUp() {
	try { app.doShellScript('/usr/bin/caffeinate -ut 1 > /dev/null 2>&1 &') } catch (ignoredError) { /* Ignore */ }
}

function macIsAwakeAndUnlocked() {
	// AppleScript alerts and dialogs will timeout early if Mac is asleep when it's displayed (ie. the screen is not available to draw on).
	// So this function is used to determine if it's safe to display an alert or dialog, or if should skip it or wait instead.

	// NOTE: The previous way that I detected if a Mac is awake (by checking if the following command return "4") no longer works on Apple Silicon Macs, but using "$.CGDisplayIsActive($.CGMainDisplayID())" works properly on all Macs models and macOS versions.
	// /usr/libexec/PlistBuddy -c "Print :0:IOPowerManagement:CurrentPowerState" /dev/stdin <<< "$(ioreg -arc IODisplayWrangler -k IOPowerManagement -d 1)"
	// ALSO NOTE: I was curious what would be returned by "$.CGMainDisplayID()" and "$.CGDisplayIsActive($.CGMainDisplayID())" when NO screen was connected, and from my testing it seems that on headless Macs there is always a virtual internal screen.
	// When testing on a 2010 through 2018 Mac mini's with NO screen connected, "$.CGMainDisplayID()" still returned a value which always either "1104977154" or "1104977153" and "$.CGDisplayIsBuiltin($.CGMainDisplayID())" returned "1" which
	// means that when no screen is connected, headless Macs still have a virtual internal screen. And, "$.CGDisplayIsActive($.CGMainDisplayID())" still returned "1" when the computer itself was actually awake, so it is always safe to use.

	// Screen Lock Check Based On: https://stackoverflow.com/questions/11505255/osx-check-if-the-screen-is-locked

	return (($.CGDisplayIsActive($.CGMainDisplayID()) == 1) && (ObjC.deepUnwrap(castRefToObjectIfNeeded($.CGSessionCopyCurrentDictionary())).CGSSessionScreenIsLocked !== true))
}

function castRefToObjectIfNeeded(refToCastToObject) {
	// Some automatic CF-NS bridging broke in JXA in Mojave and then more broke in Catalina.
	// This "ObjC.castRefToObject" workaround solves the issue to convert the CF references to NS objects,
	// but cannot be used indiscriminately on older versions of macOS that don't need the workaround as it
	// will throw an error "Ref has no type" unless the input is an actual CF reference that needs to be converted.
	// So, this function will attempt conversion, and if it fails the original object will be returned.
	// This way, this function can be called with any objects that may or may not need to be converted
	// on any version of macOS and will always return an NS object whether or not conversion was needed.

	// NOTE: This other "CFMakeCollectable" workaround (https://github.com/JXA-Cookbook/JXA-Cookbook/issues/13#issuecomment-174820487)
	// was previously used (https://github.com/freegeek-pdx/IPSW-Updater/blob/8de604850714bb1526f166932fc7d05235646923/IPSW%20Updater.jxa#L2241-L2255)
	// but I've since found this built-in "ObjC.castRefToObject" method (the name popped out to me in the list of method of the "ObjC" class
	// which I was checking out for unrelated reasons) and testing showed it does the exact same conversion as the "CFMakeCollectable" workaround.

	try { return ObjC.castRefToObject(refToCastToObject) } catch (castRefToObjectError) { return refToCastToObject }
}

function calculateChecksumForFile(filePath, algorithm = 1) {
	if (typeof algorithm != 'number') algorithm = parseInt(algorithm)
	if ((algorithm != 1) && (algorithm != 224) && (algorithm != 256) && (algorithm != 384) && (algorithm != 512)) algorithm = 1

	if (fileManager.fileExistsAtPath(filePath)) {
		let returnChecksum = `SHA${algorithm}SUM-UNKOWN-ERROR`
		const checksumOutputFile = `${temporaryFilesFolder}/${$(filePath).lastPathComponent.js}-checksum`
		const calculateChecksumPID = app.doShellScript(`/usr/bin/openssl dgst -sha${algorithm} ${quoteForShell(filePath)} > ${quoteForShell(checksumOutputFile)} 2>&1 & echo $!`)

		try {
			while (app.doShellScript(`kill -0 ${calculateChecksumPID}; echo $?`) == 0)
				delay(0.25)

			returnChecksum = $.NSString.stringWithContentsOfFileEncodingError(checksumOutputFile, $.NSUTF8StringEncoding, $()).js.substring(`SHA${algorithm}(${filePath})= `.length).trim() // Need to "trim()" to remove trailing linebreak.
		} catch (calculateChecksumError) {
			debugLog(`Calculate SHA${algorithm} Checksum Error`, calculateChecksumError)

			try { app.doShellScript(`kill ${calculateChecksumPID}`) } catch (ignoredError) { /* Ignore */ }

			try { fileManager.removeItemAtPathError(checksumOutputFile, $()) } catch (ignoredError) { /* Ignore */ }

			if (calculateChecksumError.errorNumber === -128) {
				setProgressStopButtonEnabled(false)
				throw calculateChecksumError
			}
		}

		try { fileManager.removeItemAtPathError(checksumOutputFile, $()) } catch (ignoredError) { /* Ignore */ }

		return returnChecksum
	} else
		return `SHA${algorithm}SUM-FILE-DNE`
}

// From: https://stackoverflow.com/questions/15900485/correct-way-to-convert-size-in-bytes-to-kb-mb-gb-in-javascript/18650828#18650828
function formatBytes(bytes, decimals = 2) {
	if (!+bytes) return '0 bytes'
	const k = 1000
	const sizes = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
	const i = Math.floor(Math.log(bytes) / Math.log(k))
	return `${parseFloat((bytes / Math.pow(k, i)).toFixed(decimals < 0 ? 0 : decimals))} ${sizes[i]}`
}

// From: https://stackoverflow.com/questions/19700283/how-to-convert-time-milliseconds-to-hours-min-sec-format-in-javascript32180863#32180863
function durationConversion(millisec) {
	const seconds = +(millisec / 1000).toFixed(1).replace('.0', '')
	const minutes = +(millisec / (1000 * 60)).toFixed(1).replace('.0', '')
	const hours = +(millisec / (1000 * 60 * 60)).toFixed(1).replace('.0', '')
	const days = +(millisec / (1000 * 60 * 60 * 24)).toFixed(1).replace('.0', '')

	if (seconds < 60)
		return `${seconds} second${((seconds == 1) ? '' : 's')}`
	else if (minutes < 60)
		return `${minutes} minute${((minutes == 1) ? '' : 's')}`
	else if (hours < 24)
		return `${hours} hour${((hours == 1) ? '' : 's')}`
	else
		return `${days} day${((days == 1) ? '' : 's')}`
}

function setProgressStopButtonEnabled(setEnabled) {
	if (progressWindow)
		for (const thisSubview of progressWindow.contentView.subviews.js)
			if (($.NSStringFromClass(thisSubview.class).js == 'NSButton') && ((thisSubview.title.js == 'Stop') || (thisSubview.title.js == 'Skip'))) {
				thisSubview.enabled = setEnabled
				break
			}
}

function setProgressStopButtonToSkip() {
	if (progressWindow)
		for (const thisSubview of progressWindow.contentView.subviews.js)
			if (($.NSStringFromClass(thisSubview.class).js == 'NSButton') && (thisSubview.title.js == 'Stop')) {
				thisSubview.title = 'Skip'
				break
			}
}

function setProgressSkipButtonToStop() {
	if (progressWindow)
		for (const thisSubview of progressWindow.contentView.subviews.js)
			if (($.NSStringFromClass(thisSubview.class).js == 'NSButton') && (thisSubview.title.js == 'Skip')) {
				thisSubview.title = 'Stop'
				break
			}
}

function closeProgressWindow() {
	if (progressWindow) {
		progressWindow.animationBehavior = $.NSWindowAnimationBehaviorUtilityWindow
		progressWindow.isVisible = false
		progressWindow.center
	}
}

function openProgressWindow() {
	if (progressWindow) {
		if (!progressWindow.isVisible) {
			progressWindow.center
			progressWindow.animationBehavior = $.NSWindowAnimationBehaviorDocumentWindow
		}

		progressWindow.makeKeyAndOrderFront($.NSApp)
	}
}

function validateCodeSignatureForAppAtPath(validateAppPath) {
	const validateAppBundle = $.NSBundle.bundleWithPath(validateAppPath)
	if (validateAppBundle.isNil())
		throw new Error(`Code Signature Validation Failed

‚Äú${validateAppPath}‚Äù is not a valid application bundle.`)

	const validateAppVersion = validateAppBundle.objectForInfoDictionaryKey('CFBundleShortVersionString').js // DO NOT use the "appVersion" variable of the running app since this function may be validating an app update and not the running app.
	if (!validateAppVersion)
		throw new Error(`Code Signature Validation Failed

‚Äú${validateAppPath}‚Äù does not have a valid ‚ÄúCFBundleShortVersionString‚Äù.`)

	const verifyNotarization = (!validateAppVersion.endsWith('-0') && isMojaveOrNewer) // DO NOT verify notarization for testing builds (with versions ending in "-0") since they will only be signed and not notarized, and see comments below about how notarization CANNOT be verified on macOS 10.13 High Sierra.

	const intendedCodeSignatureTeamID = 'YRW6NUGA63'
	const validCSReqString = `${verifyNotarization ? 'notarized and ' : ''}identifier "${bundleIdentifier}" and anchor apple generic and certificate 1[field.1.2.840.113635.100.6.2.6] exists and certificate leaf[field.1.2.840.113635.100.6.1.13] exists and certificate leaf[subject.OU] = "${intendedCodeSignatureTeamID}"`
	// Explanation of Code Signing Requirements: https://developer.apple.com/documentation/technotes/tn3127-inside-code-signing-requirements
	// The specified CSReqs string is verifying the correct Bundle ID, Team ID, and that it is signed with a Developer ID certificate, and starting on macOS 10.14 Mojave,
	// there is a "notarized" token which can be included in the CSReq string to confirm the app is notarized, so notarization is also verified when that token is available and it not a testing build (discovered this wasn't supported/available on macOS 10.13 High Sierra through testing).
	// This "notarized" token can be seen in the output of "spctl --list" on macOS 10.14 Mojave and newer and can also be seen here: https://gregoryszorc.com/docs/apple-codesign/stable/apple_codesign_gatekeeper.html
	// And using this "notarized" token to verify notarization can be seen here: https://developer.apple.com/forums/thread/128683?answerId=404727022#404727022 & https://developer.apple.com/forums/thread/130560
	// This other "generate_csreq_hex_for_tcc_db.jxa" script also contains information about CSReqs and the "Security" framework functions to retrieve them via JXA (which are used below): https://github.com/freegeek-pdx/macOS-Testing-and-Deployment-Scripts/blob/main/Other%20Scripts/generate_csreq_hex_for_tcc_db.jxa

	// This first check is done using native C functions of the "Security" framework (such as https://developer.apple.com/documentation/security/1395784-secstaticcodecheckvalidity?language=objc).
	// This checking using native C function may be a bit overzealous, but the basic code was already written for "mkuser" (https://mkuser.sh) where it was important to run code signature checks using native
	// functions so the result could not be spoofed by a MITM type attack on the "codesign" or "spctl" commands: https://github.com/freegeek-pdx/mkuser/blob/c5c1642912ca1551197b9490339b0a8303a45071/mkuser.sh#L4072-L4165

	const staticCodeRef = $()
	const actualCSReqRef = $()
	const actualCSReqStringRef = $()
	const validCSReqRef = $()
	let csReqValidityErrorCode = -1
	const csReqValidityPassed = (($.SecStaticCodeCreateWithPath($.NSURL.fileURLWithPath(validateAppPath), $.kSecCSDefaultFlags, staticCodeRef) === 0) && !staticCodeRef.isNil() &&
		($.SecCodeCopyDesignatedRequirement(staticCodeRef, $.kSecCSDefaultFlags, actualCSReqRef) === 0) && !actualCSReqRef.isNil() &&
		($.SecRequirementCopyString(actualCSReqRef, $.kSecCSDefaultFlags, actualCSReqStringRef) === 0) && !actualCSReqStringRef.isNil() && // Only retrieving actual CSReqs string for display if there is an error. DO NOT compare it litarally like "(validCSReqString === actualCSReqStringRef.js)" since it WILL NOT contain the "notarized" token, and comparing literal CSReq strings to each other is not technically reliable/correct since conditions can be specified in different orders and still be valid/equal. The following "SecStaticCodeCheckValidity" function properly evaluates the conditions in the "validCSReqString" against the "staticCodeRef" of the app.
		($.SecRequirementCreateWithString($.CFStringCreateWithCString($.kCFAllocatorDefault, validCSReqString, $.kCFStringEncodingUTF8), $.kSecCSDefaultFlags, validCSReqRef) === 0) &&
		!validCSReqRef.isNil() && // First check that "validCSReqRef" is NOT nil/NULL to be sure the valid requirement string itself is a proper CSReqs string (since if not, nil/NULL would be passed to "SecStaticCodeCheckValidity" which would just verify against the binaries internal requirements).
		((csReqValidityErrorCode = $.SecStaticCodeCheckValidity(staticCodeRef, $.kSecCSCheckAllArchitectures, validCSReqRef)) === 0)) // I also tried using "$.SecCodeCheckValidity(staticCodeRef, $.kSecCSDefaultFlags, validCSReqRef)" but it always returned error code "-67071" (errSecCSInvalidObjectRef = Invalid API object reference) while "SecStaticCodeCheckValidity" seems to properly check the CSReq string and return "0" when sucessfully matched.

	// The "SecStaticCodeCheckValidity" function above does basically the same thing as the following "codesign -v ..." command, but still double-check it succeeds to be extra thorough and show useful output if anything fails.
	let codesignVerifyPassed = false
	let codesignVerifyErrorCode = -1
	let codesignVerifyOutput = 'UNKNOWN CODESIGN VERIFY ERROR'
	try {
		codesignVerifyOutput = app.doShellScript(`/usr/bin/codesign -vv --deep --strict -R ${quoteForShell(`=${validCSReqString}`)} ${quoteForShell(validateAppPath)} 2>&1`)
		codesignVerifyPassed = true

		// Information about using "--deep" and "--strict" options during "codesign" verification:
			// https://developer.apple.com/documentation/security/notarizing_macos_software_before_distribution/resolving_common_notarization_issues#3087735
			// https://developer.apple.com/library/archive/technotes/tn2206/_index.html#//apple_ref/doc/uid/DTS40007919-CH1-TNTAG211
			// https://developer.apple.com/library/archive/technotes/tn2206/_index.html#//apple_ref/doc/uid/DTS40007919-CH1-TNTAG404
		// The "--deep" option is DEPRECATED in macOS 13 Ventura for SIGNING but I don't think it's deprecated for VERIFYING since verification is where it was always really intended to be used (as explained in the note in the last link in the list above).
	} catch (codesignVerifyError) {
		codesignVerifyErrorCode = codesignVerifyError.errorNumber
		codesignVerifyOutput = codesignVerifyError.message
	}

	// The "SecStaticCodeCheckValidity" function AND "codesign -v ..." command above already confirm the app is signed by the intended Team ID (and notarized, when possible on macOS 10.14 Mojave or newer)
	// but still triple-check by running "spctl -avv" and confirm it succeeds AND contains specific output to be extra thorough and show useful output if anything fails.
	let spctlAssessPassed = false
	let spctlAssessErrorCode = -1
	let spctlAssessDict = {ERROR: 'UNKNOWN SPCTL ASSESS ERROR'}
	try {
		const spctlAssessOutput = app.doShellScript(`/usr/sbin/spctl -avv --raw ${quoteForShell(validateAppPath)} 2>&1; echo "spctl Exit Code: $?"`)
		// IMPORTANT: Capture both stdout and stderr as well as "echo" the "spctl" the exit code (the "echo" command always exits 0 so this command will never throw an error itself) and then manually extract the plist output.
		// This is done for multiple reasons, one of which is that we DO NOT want to rely on the exit code of the "spctl" assessment to determine success or failure (since "doShellScript" would throw and error when the final command exits non-zero),
		// and ALSO DO NOT want to check the "assessment:verdict" in the output dictionary in the checks below because if macOS is set to only allow Mac App Store apps to run the "spctl" assessment will always fail even if the app is notarized.
		// BUT, if the app got this far to be able to run and load at all it means that a user manually allowed the app regardless of the Mac App Store apps only setting.
		// When the app is manually allowed to run in this case the "spctl" assessment still fails. When this happens, it would be silly for the app itself to refuse to run after a user explicitly allowed it to run.
		// So, will only verify that the "spctl" assessment output shows that the app is properly notarized with the correct identity and not worry about whether or not "spctl" assessment was actually "accepted" or "rejected".
		// The other reason is that for some errors (such as if the "_CodeSignature" folder is removed) there will be no plist output, and if we don't capture the output in this way to extract and check for plist output then
		// for those errors the plist parsing would error with "The data couldn't be read because it isn't in the correct format." which is not relevant to "spctl" but is just the result of failing to parse non-existant plist.
		// This way, if there is no plist, we can just throw the raw combined stdout and stderr output from "spctl" as an error (which will include the extra exit code line) to be able to extract and present the "spctl" exit code and actual error.

		const spctlAssessPlistStartIndex = spctlAssessOutput.indexOf('<?xml')
		const spctlAssessPlistEndIndex = spctlAssessOutput.indexOf('</plist>')
		if ((spctlAssessPlistStartIndex > -1) && (spctlAssessPlistEndIndex > -1)) {
			const spctlAssessPlist = spctlAssessOutput.substring(spctlAssessPlistStartIndex, spctlAssessPlistEndIndex + 8)

			const spctlAssessPlistParseError = $()
			spctlAssessDict = ObjC.deepUnwrap($.NSPropertyListSerialization.propertyListWithDataOptionsFormatError($(spctlAssessPlist).dataUsingEncoding($.NSUTF8StringEncoding), $.NSPropertyListImmutable, null, spctlAssessPlistParseError))

			if (!spctlAssessPlistParseError.isNil()) throw spctlAssessPlistParseError
			spctlAssessPassed = ((spctlAssessDict['assessment:authority']['assessment:authority:source'] == `${verifyNotarization ? 'Notarized ' : ''}Developer ID`) && (spctlAssessDict['assessment:originator'] == `Developer ID Application: Pico Mitchell (${intendedCodeSignatureTeamID})`)) // The "spctl -avv" output on macOS 10.13 High Sierra will only ever specify a source of "Developer ID" even if it's actually notarized while macOS 10.14 Mojave and newer will specify a source of "Notarized Developer ID".
		} else
			throw new Error(spctlAssessOutput) // As explained above, if there is no plist in the "spctl", throw combined raw combined stdout and stderr output as an error (which will include the extra exit code line).
	} catch (spctlAssessError) {
		let spctlAssessErrorMessage = (spctlAssessError.message || spctlAssessError.localizedDescription.js)
		spctlAssessErrorCode = (spctlAssessError.errorNumber || spctlAssessError.code) // There should never be an "errorNumber" from the "spctl" "doShellScript" command throwing an error because of explicitly exiting 0 as described above, but keep the checks just in case since it doesn't hurt anything.

		const spctlAssessExitCodeIndex = spctlAssessErrorMessage.indexOf('spctl Exit Code: ')
		if (spctlAssessExitCodeIndex > -1) {
			const spctlAssessExitCode = spctlAssessErrorMessage.substring(spctlAssessExitCodeIndex + 17)
			spctlAssessErrorMessage = spctlAssessErrorMessage.substring(0, spctlAssessExitCodeIndex).trim()
			spctlAssessErrorCode = ((spctlAssessErrorCode === undefined) ? spctlAssessExitCode : `${spctlAssessErrorCode} + ${spctlAssessExitCode}`)
		}

		spctlAssessDict = {ERROR: spctlAssessErrorMessage}
	}

	if (!csReqValidityPassed || !codesignVerifyPassed || !spctlAssessPassed)
		throw new Error(`Code Signature Validation Failed for App at Path:
${validateAppPath}

Code Signature Verification: ${codesignVerifyPassed ? 'PASSED' : `FAILED (${codesignVerifyErrorCode})`}
${codesignVerifyOutput.replace(/^.*\.app: /gm, '')}

Security Assessment: ${spctlAssessPassed ? 'PASSED' : `FAILED (${spctlAssessErrorCode})`}
${JSON.stringify(spctlAssessDict)}

Code Signing Requirements: ${csReqValidityPassed ? 'PASSED' : `FAILED (${csReqValidityErrorCode})`}
${actualCSReqStringRef.isNil() ? 'NO CSREQS' : actualCSReqStringRef.js}`) // Show "Code Signing Requirements" last since it's the most cryptic output and the other output has more understandable error messages.
}

function checkAndInstallAppUpdates() {
	setProgressStopButtonEnabled(false)

	Progress.description = `
üîÑ	Checking for App Updates`
	Progress.additionalDescription = ''
	Progress.totalUnitCount = -1
	Progress.completedUnitCount = 0

	if (isBigSurOrNewer && progressWindowProgressBar) {
		// There is a bug in macOS 11 Big Sur where setting indeterminate progress AFTER determinate progress has been shown just displays 0 progress.
		// To workaround this, startAnimation on the NSProgressIndicator directly.

		progressWindowProgressBar.startAnimation(null)
	}

	wakeMacUp()

	app.activate()

	openProgressWindow()

	const latestAppUpdateJsonFilePath = `${temporaryFilesFolder}/latest-app-update.json`
	let appUpdateProgressOutputFile = `${temporaryFilesFolder}/latest-app-update.json-progress`
	let userCanceledUpdate = false

	const readLatestAppUpdateFileError = $()

	try {
		if (!fileManager.fileExistsAtPath(temporaryFilesFolder))
			fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(temporaryFilesFolder, true, {}, $())

		if (backgroundPIDs.length > 0) {
			try { app.doShellScript(`kill ${backgroundPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }
			backgroundPIDs.splice(0, backgroundPIDs.length)
		}

		const downloadLatestAppUpdateJsonPID = app.doShellScript(`/usr/bin/curl --connect-timeout 5 -fL ${quoteForShell(`${appUpdatesJsonURL}&latest`)} -o ${quoteForShell(latestAppUpdateJsonFilePath)} > ${quoteForShell(appUpdateProgressOutputFile)} 2>&1 & echo $!`)
		backgroundPIDs.push(downloadLatestAppUpdateJsonPID)

		try {
			while (app.doShellScript(`kill -0 ${downloadLatestAppUpdateJsonPID}; echo $?`) == 0)
				delay(0.25)
		} catch (waitingForLatestAppUpdateJsonError) {
			debugLog('Waiting for App Updates JSON Error', waitingForLatestAppUpdateJsonError)

			try { app.doShellScript(`kill ${downloadLatestAppUpdateJsonPID}`) } catch (ignoredError) { /* Ignore */ }

			throw waitingForLatestAppUpdateJsonError
		}

		backgroundPIDs.splice(backgroundPIDs.indexOf(downloadLatestAppUpdateJsonPID), 1)

		const latestAppUpdateInfo = JSON.parse($.NSString.stringWithContentsOfFileEncodingError(latestAppUpdateJsonFilePath, $.NSUTF8StringEncoding, readLatestAppUpdateFileError).js)
		// NOTE: NOT using "ObjC.deepUnwrap($.NSJSONSerialization.JSONObjectWithDataOptionsError(...))" for consistency with other JSON parsing which don't use it for other reasons which aren't really important here (this JSON parse really would be fine with either technique).

		if (latestAppUpdateInfo instanceof Object) {
			try { fileManager.removeItemAtPathError(appUpdateProgressOutputFile, $()) } catch (ignoredError) { /* Ignore */ }
			try { fileManager.removeItemAtPathError(latestAppUpdateJsonFilePath, $()) } catch (ignoredError) { /* Ignore */ }

			setPreference('LastAppUpdateCheck', new Date(), 'date')

			if (latestAppUpdateInfo.version && latestAppUpdateInfo.sha512sum && latestAppUpdateInfo.url &&
				($(latestAppUpdateInfo.version).compareOptions(appVersion, $.NSNumericSearch) == 1)) {
				setPreference('AppUpdateAvailable', true, 'bool')

				closeProgressWindow()

				const displayReleaseDate = (latestAppUpdateInfo.releasedate ? new Date(latestAppUpdateInfo.releasedate).toLocaleDateString('en-US', dateFormatOptions) : 'UNKNOWN')

				const appPathIsWritableRef = $()
				try { $.NSURL.fileURLWithPath(appPath).getResourceValueForKeyError(appPathIsWritableRef, $.NSURLIsWritableKey, $()) } catch (ignoredError) { /* Ignore */ }

				const parentDirectoryToMeIsWritableRef = $()
				try { $.NSURL.fileURLWithPath(parentDirectoryToMe).getResourceValueForKeyError(parentDirectoryToMeIsWritableRef, $.NSURLIsWritableKey, $()) } catch (ignoredError) { /* Ignore */ }

				const autoInstallUpdate = (appPathIsWritableRef.js && parentDirectoryToMeIsWritableRef.js)
				let shouldInstallUpdate = autoInstallUpdate
				let userClickedInstall = false

				if (macIsAwakeAndUnlocked()) { // If Mac is asleep or locked, the update will be automatically installed without prompting if "autoInstallUpdate" is true.
					for ( ; ; ) {
						app.activate()
						const appUpdateAvailableReply = displayAlertOrDialogDependingOnOS(`${appName} Version ${latestAppUpdateInfo.version} is Now Available!`,
							`Released: ${displayReleaseDate}

Version ${latestAppUpdateInfo.version} Release Notes:

${latestAppUpdateInfo.releasenotes ? latestAppUpdateInfo.releasenotes : '	No Release Notes'}

Version ${appVersion} is currently installed.
In 60 seconds, ${(autoInstallUpdate ? `version ${latestAppUpdateInfo.version} will automatically be installed‚Ä¶` :
'this update will be skipped until the next run‚Ä¶')}`,
							`${appName}  ‚Äî  Update Available`,
							'note',
							['View All Release Notes', 'Update Later', `Update to ${latestAppUpdateInfo.version}`],
							2,
							3,
							60
						)

						if (appUpdateAvailableReply.buttonReturned == 'View All Release Notes') {
							sharedWorkspace.openURL($.NSURL.URLWithString(releaseNotesURL))
						} else {
							userClickedInstall = appUpdateAvailableReply.buttonReturned.includes(latestAppUpdateInfo.version)
							shouldInstallUpdate = ((appUpdateAvailableReply.gaveUp && autoInstallUpdate) || userClickedInstall)
							break
						}
					}
				}

				if (shouldInstallUpdate) {
					Progress.description = `üîÑ	Downloading ${appName} Version ${latestAppUpdateInfo.version}`
					Progress.additionalDescription = `
üóì Released: ${displayReleaseDate}

üìè Size: ${(latestAppUpdateInfo.size ? `${formatBytes(latestAppUpdateInfo.size)} (${latestAppUpdateInfo.size} bytes)` : 'UNKNOWN')}`

					setProgressStopButtonEnabled(true)
					openProgressWindow()

					const appUpdateZipFileName = $(latestAppUpdateInfo.url).lastPathComponent.js
					const appUpdateZipFilePath = `${temporaryFilesFolder}/${appUpdateZipFileName}`
					appUpdateProgressOutputFile = `${temporaryFilesFolder}/${appUpdateZipFileName}-progress`

					if (backgroundPIDs.length > 0) {
						try { app.doShellScript(`kill ${backgroundPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }
						backgroundPIDs.splice(0, backgroundPIDs.length)
					}

					const downloadAppUpdatePID = app.doShellScript(`/usr/bin/curl --connect-timeout 5 -fL ${quoteForShell(latestAppUpdateInfo.url)} -o ${quoteForShell(appUpdateZipFilePath)} > ${quoteForShell(appUpdateProgressOutputFile)} 2>&1 & echo $!`)
					backgroundPIDs.push(downloadAppUpdatePID)

					try {
						while (app.doShellScript(`kill -0 ${downloadAppUpdatePID}; echo $?`) == 0)
							delay(0.25)
					} catch (waitingForAppUpdateDownloadError) {
						debugLog('Waiting for App Update Download Error', waitingForAppUpdateDownloadError)

						try { app.doShellScript(`kill ${downloadAppUpdatePID}`) } catch (ignoredError) { /* Ignore */ }

						throw waitingForAppUpdateDownloadError
					}

					backgroundPIDs.splice(backgroundPIDs.indexOf(downloadAppUpdatePID), 1)

					setProgressStopButtonEnabled(false)

					if (!fileManager.fileExistsAtPath(appUpdateZipFilePath))
						throw new Error('App Update ZIP File Not Downloaded')

					const appUpdateZipFileSize = fileManager.attributesOfItemAtPathError(appUpdateZipFilePath, $()).objectForKey('NSFileSize').js
					if (latestAppUpdateInfo.size && (latestAppUpdateInfo.size != appUpdateZipFileSize))
						throw new Error(`App Update ZIP File Is Invalid

Intended ZIP Size:
${formatBytes(latestAppUpdateInfo.size)} (${latestAppUpdateInfo.size} bytes)

Downloaded ZIP Size:
${formatBytes(appUpdateZipFileSize)} (${appUpdateZipFileSize} bytes)`)

					const appUpdateZipFileSHA512Sum = calculateChecksumForFile(appUpdateZipFilePath, 512)
					if (latestAppUpdateInfo.sha512sum != appUpdateZipFileSHA512Sum)
						throw new Error(`App Update ZIP File Is Invalid

Intended ZIP Checksum:
${latestAppUpdateInfo.sha512sum}

Downloaded ZIP Checksum:
${appUpdateZipFileSHA512Sum}`)

					Progress.description = `
üîÑ	Installing & Launching ${appName} Version ${latestAppUpdateInfo.version}`
					Progress.additionalDescription = ''
					delay(0.25)

					const appUpdateTempFilePath = app.doShellScript(`/usr/bin/ditto -xkV --noqtn ${quoteForShell(appUpdateZipFilePath)} ${quoteForShell(temporaryFilesFolder)} 2>&1`).match(/copying file (.+?)\.app\/Contents\/Info\.plist \.\.\. /)[0].replace('copying file ', `${temporaryFilesFolder}/`).replace('/Contents/Info.plist ... ', '')

					try { fileManager.removeItemAtPathError(appUpdateZipFilePath, $()) } catch (ignoredError) { /* Ignore */ }

					if (!fileManager.fileExistsAtPath(appUpdateTempFilePath))
						throw new Error('App Update Not Found After Unzipping Download')

					try { fileManager.removeItemAtPathError(appUpdateProgressOutputFile, $()) } catch (ignoredError) { /* Ignore */ }

					// IMPORTANT: Before installing the updated app, confirm that it is properly signed (and notarized, when possible on macOS 10.14 Mojave and newer).
					// See comments in the "validateCodeSignatureForAppAtPath" function for more information.
					validateCodeSignatureForAppAtPath(appUpdateTempFilePath) // NOTE: This function with "throw" an error if validation fails which will be caught and displayed below.

					setPreference('AppJustAutoUpdated', true, 'bool')

					try { fileManager.setAttributesOfItemAtPathError($.NSDictionary.dictionaryWithObjectForKey($.NSDate.date, $.NSFileModificationDate), appUpdateTempFilePath, $()) } catch (ignoredError) { /* Ignore */ } // "touch" unzipped app.

					delay(0.25)

					const globalApplicationsFolderIsWritableRef = $()
					try { $.NSURL.fileURLWithPath('/Applications').getResourceValueForKeyError(globalApplicationsFolderIsWritableRef, $.NSURLIsWritableKey, $()) } catch (ignoredError) { /* Ignore */ }
					const globalApplicationsFolderIsWritable = globalApplicationsFolderIsWritableRef.js

					const updatedAppFileName = $(appUpdateTempFilePath).lastPathComponent.js

					const installAppUpdateScript = `/usr/bin/osascript -e ${quoteForShell(`
use AppleScript version "2.7"
use scripting additions
use framework "Foundation"

set currentAppFilePath to ${quoteForAppleScript(appPath)}

delay 0.5
repeat while (application currentAppFilePath is running)
	delay 0.5
end repeat

set versionedAppFilePath to ${quoteForAppleScript(`${parentDirectoryToMe}/${appName} (${appVersion}).app`)}
set appUpdateTempFilePath to ${quoteForAppleScript(appUpdateTempFilePath)}
set appInstallFilePath to ${quoteForAppleScript(`${parentDirectoryToMe}/${updatedAppFileName}`)}
set actualInstallFilePath to appInstallFilePath

set systemApplicationsFolder to (POSIX path of (path to applications folder from system domain))
set appInSystemApplicationsFolder to (systemApplicationsFolder & ${quoteForAppleScript(updatedAppFileName)})

set userApplicationsFolder to (POSIX path of (path to applications folder from user domain))
set appInUserApplicationsFolder to (userApplicationsFolder & ${quoteForAppleScript(updatedAppFileName)})

set userDownloadsFolder to (POSIX path of (path to downloads folder from user domain))
set appInUserDownloadsFolder to (userDownloadsFolder & ${quoteForAppleScript(updatedAppFileName)})

set adminPermissionPrompt to "‚Äú${quoteForAppleScript(appName, true)}‚Äù requires Admin Permission to update itself to version ${quoteForAppleScript(latestAppUpdateInfo.version, true)}."

try
	set fileManager to (defaultManager of NSFileManager of current application)

	try
		if (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) then
			moveItemAtPath_toPath_error_(currentAppFilePath, versionedAppFilePath, missing value) of fileManager
		end if
	end try

	try
		if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (fileExistsAtPath_(versionedAppFilePath) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(versionedAppFilePath) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(versionedAppFilePath) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of versionedAppFilePath) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (fileExistsAtPath_(currentAppFilePath) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(currentAppFilePath) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(currentAppFilePath) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of currentAppFilePath) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((currentAppFilePath is not equal to appInstallFilePath) and (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (fileExistsAtPath_(appInstallFilePath) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInstallFilePath) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInstallFilePath) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInstallFilePath) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try
${((userClickedInstall || globalApplicationsFolderIsWritable) ? `
	try
		if ((currentAppFilePath is not equal to appInSystemApplicationsFolder) and (appInstallFilePath is not equal to appInSystemApplicationsFolder) and (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInSystemApplicationsFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInSystemApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try
` : '')}
	try
		if ((currentAppFilePath is not equal to appInUserApplicationsFolder) and (appInstallFilePath is not equal to appInUserApplicationsFolder) and (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInUserApplicationsFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInUserApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	try
		if ((currentAppFilePath is not equal to appInUserDownloadsFolder) and (appInstallFilePath is not equal to appInUserDownloadsFolder) and (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager)) then
			trashItemAtURL_resultingItemURL_error_((fileURLWithPath_(appInUserDownloadsFolder) of NSURL of current application), missing value, missing value) of fileManager
			if (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager) then do shell script "/bin/rm -rf " & (quoted form of appInUserDownloadsFolder) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try

	set appUpdateTempFileStructure to ""
	try
		set appUpdateTempFileStructure to (do shell script ("cd " & (quoted form of appUpdateTempFilePath) & " && /bin/ls -Rsk"))
	end try

	try
		if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInstallFilePath) of fileManager))) then
			moveItemAtPath_toPath_error_(appUpdateTempFilePath, appInstallFilePath, missing value) of fileManager
			if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInstallFilePath) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appUpdateTempFilePath) & " " & (quoted form of appInstallFilePath) with prompt adminPermissionPrompt with administrator privileges
		end if
	end try
${((userClickedInstall || globalApplicationsFolderIsWritable) ? `
	try
		if ((appInstallFilePath is not equal to appInSystemApplicationsFolder) and (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager))) then
			moveItemAtPath_toPath_error_(appUpdateTempFilePath, appInSystemApplicationsFolder, missing value) of fileManager
			if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInSystemApplicationsFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appUpdateTempFilePath) & " " & (quoted form of appInSystemApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
			set actualInstallFilePath to appInSystemApplicationsFolder
		end if
	end try
` : '')}
	try
		if ((appInstallFilePath is not equal to appInUserApplicationsFolder) and (fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager))) then
			moveItemAtPath_toPath_error_(appUpdateTempFilePath, appInUserApplicationsFolder, missing value) of fileManager
			if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInUserApplicationsFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appUpdateTempFilePath) & " " & (quoted form of appInUserApplicationsFolder) with prompt adminPermissionPrompt with administrator privileges
			set actualInstallFilePath to appInUserApplicationsFolder
		end if
	end try

	if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager))) then
		moveItemAtPath_toPath_error_(appUpdateTempFilePath, appInUserDownloadsFolder, missing value) of fileManager
		if ((fileExistsAtPath_(appUpdateTempFilePath) of fileManager) and (not (fileExistsAtPath_(appInUserDownloadsFolder) of fileManager))) then do shell script "/bin/mv -f " & (quoted form of appUpdateTempFilePath) & " " & (quoted form of appInUserDownloadsFolder) with prompt adminPermissionPrompt with administrator privileges
		set actualInstallFilePath to appInUserDownloadsFolder
	end if

	setBool_forKey_(false, "AppUpdateAvailable") of initWithSuiteName_(${quoteForAppleScript(bundleIdentifier)}) of alloc of NSUserDefaults of current application

	if (fileExistsAtPath_(actualInstallFilePath) of fileManager) then
		-- When working auto-updating for MacLand Scripts, Catalina seems to fail to launch if done too quickly after a move (with an "executable not found" error).
		-- Generating the install path file structure alone seems to delay enough to avoid the issue, but this loop makes it extra safe.

		repeat 30 times
			try
				set installAppFileStructure to ""
				try
					set installAppFileStructure to (do shell script ("cd " & (quoted form of actualInstallFilePath) & " && /bin/ls -Rsk"))
				on error
					try
						set installAppFileStructure to (do shell script ("cd " & (quoted form of actualInstallFilePath) & " && /bin/ls -Rsk") with prompt adminPermissionPrompt with administrator privileges)
					on error
						exit repeat
					end try
				end try
				if (appUpdateTempFileStructure is equal to installAppFileStructure) then exit repeat
			end try
			delay 0.5
		end repeat
	end if
on error installError
	activate
	beep
	display alert "Error Installing ‚Äú${quoteForAppleScript(appName, true)}‚Äù After Update" message installError as critical
end try

try
	do shell script "/usr/bin/open -na " & (quoted form of actualInstallFilePath)
on error
	try
		do shell script "/usr/bin/open -na " & (quoted form of ${quoteForAppleScript(`${parentDirectoryToMe}/${appName}.app`)})
	on error
		try
			do shell script "/usr/bin/open -na " & (quoted form of currentAppFilePath)
		on error
			try
				do shell script "/usr/bin/open -nb ${bundleIdentifier}"
			on error launchError
				activate
				beep
				display alert "Error Launching ‚Äú${quoteForAppleScript(appName, true)}‚Äù After Update" message launchError buttons {"Quit", "Re-Download ‚Äú${quoteForAppleScript(appName, true)}‚Äù"} cancel button 1 default button 2 as critical
				do shell script "/usr/bin/open 'https://ipsw.app/download/'"
			end try
		end try
	end try
end try
`)} > /dev/null 2>&1 &`

					//debugDialog(installAppUpdateScript.replace(/\/usr\/bin\/osascript -e '|' > \/dev\/null 2>&1 &/g, '').replace(/'\\''/g, "'").trim())
					//debugDialog(app.doShellScript(installAppUpdateScript.replace('/usr/bin/osascript -e ', "printf '%s' ").replace(' > /dev/null 2>&1 &', '')).trim())

					app.doShellScript(installAppUpdateScript)

					app.quit()
				}
			} else
				setPreference('AppUpdateAvailable', false, 'bool')

			try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }

			closeProgressWindow()
		} else
			throw new Error('App Updates Info Is Empty or Is Not an Array')
	} catch (appUpdateError) {
		if (!userCanceledUpdate) userCanceledUpdate = (appUpdateError.errorNumber === -128)

		let appUpdateErrorMessage = appUpdateError.message
		if (!readLatestAppUpdateFileError.isNil()) appUpdateError = readLatestAppUpdateFileError.description.js

		try {
			const progressOutputParts = $.NSString.stringWithContentsOfFileEncodingError(appUpdateProgressOutputFile, $.NSUTF8StringEncoding, $()).js.split('curl: ')
			if (progressOutputParts.length > 1)
				appUpdateErrorMessage = `CURL Error: ${progressOutputParts.slice(-1)[0].trim()}`
		} catch (ignoredError) { /* Ignore */ }

		try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }

		debugLog(`App Update Error: ${appUpdateErrorMessage}`, appUpdateError)

		closeProgressWindow()

		if (!userCanceledUpdate && macIsAwakeAndUnlocked()) {
			const appUpdateErrorAlertMessage = `${appUpdateErrorMessage.replace('CURL Error: (6) ', '')}${(appUpdateErrorMessage.startsWith('CURL Error:') || appUpdateErrorMessage.startsWith('App Update ') || appUpdateErrorMessage.startsWith('Code Signature Validation ')) ? '' : `

${((appUpdateError instanceof Object) ? JSON.stringify(appUpdateError, Object.getOwnPropertyNames(appUpdateError)) : appUpdateError)}`}` // Do NOT display detailed error message (such as failing to read or parse file) if the actual error was because of a CURL download failure since it may just confuse the actual issue, and do not show "appUpdateError" dict for "App Update" or "Code Signature" error messages since the custom message itself contains all the relevant info.

			app.activate()
			if (getPreference('AppUpdateAvailable', 'bool'))
				try {
					const appUpdateErrorAlertReply = app.displayAlert(`${appName}: App Update Error`,
						{
							message: appUpdateErrorAlertMessage,
							as: 'critical',
							buttons: ['Continue With Outdated Version', 'Manually Download Update & Quit'],
							cancelButton: 1,
							defaultButton: 2,
							givingUpAfter: 30
						}
					)

					if (!appUpdateErrorAlertReply.gaveUp) {
						app.doShellScript('/usr/bin/open https://ipsw.app/download/')
						app.quit()
					}
				} catch (ignoredError) { /* Ignore */ }
			else
				app.displayAlert(`${appName}: App Update Error`,
					{
						message: appUpdateErrorAlertMessage,
						as: 'critical',
						givingUpAfter: 30
					}
				)
		}
	}
}

function needsFullDiskAccess() {
	if (isSequoiaOrNewer) { // On macOS 15 Sequoia, there is a new "would like to access data from other apps" prompt that comes up when accessing the Apple Configurator Group Container each run unless the app has Full Disk Access.
		const tccDatabaseIsReadableRef = $()
		try { $.NSURL.fileURLWithPath('/Library/Application Support/com.apple.TCC/TCC.db').getResourceValueForKeyError(tccDatabaseIsReadableRef, $.NSURLIsReadableKey, $()) } catch (ignoredError) { /* Ignore */ }
		// NOTE: The global TCC.db file is only readable if the app has Full Disk Access.

		return !tccDatabaseIsReadableRef.js
	}

	return false
}

function promptForFullDiskAccessIfNeeded() {
	if (isSequoiaOrNewer) { // On macOS 15 Sequoia, there is a new "would like to access data from other apps" prompt that comes up when accessing the Apple Configurator Group Container each run unless the app has Full Disk Access.
		let promptedForFullDiskAccess = false
		let justRevealedAppAndSettings = false

		for ( ; ; ) {
			if (justRevealedAppAndSettings) {
				justRevealedAppAndSettings = false

				delay(5)
			}

			if (needsFullDiskAccess()) {
				while (!macIsAwakeAndUnlocked()) // AppleScript dialogs will timeout early if Mac is asleep when it's displayed. So, wait until Mac is awake to display the dialog.
					delay(15)

				app.activate()

				try {
					const revealButtonTitle = `Reveal ${appName} & Full Disk Access Settings`
					const reCheckButtonTitle = 'Re-Check Full Disk Access'

					const needsFullDiskAccessAlertReply = app.displayAlert(`Full Disk Access Must Be Granted to ${appName}

On macOS 15 Sequoia and newer, ${appName} requires Full Disk Access to be able to save IPSW Firmware files into the Apple Configurator Firmware folder.`,
						{
							message: `You can grant ${appName} Full Disk Access in ‚Äú${systemPreferencesOrSettingsName}‚Äù by selecting ‚ÄúPrivacy & Security‚Äù in the list on the left, and then selecting ‚ÄúFull Disk Access‚Äù in the list on the right. Or, you can use the button below to go straight to the Full Disk Access section in ${systemPreferencesOrSettingsName}.

Then, drag-and-drop the ‚Äú${appName}‚Äù app from Finder into the ‚ÄúFull Disk Access‚Äù list on the right and authenticate the action if needed. Or, click the ‚Äú+‚Äù button at the bottom of the list, authenticate if needed, and then locate and select the app. Confirm the toggle switch to the right of ‚Äú${appName}‚Äù is enabled after the app has been added.

After ‚Äú${appName}‚Äù is enabled in the ‚ÄúFull Disk Access‚Äù list, re-check Full Disk Access using the button below, or quit and relaunch ${appName}.`,
							as: 'critical',
							buttons: [(promptedForFullDiskAccess ? revealButtonTitle : reCheckButtonTitle), 'Quit', (promptedForFullDiskAccess ? reCheckButtonTitle : revealButtonTitle)],
							cancelButton: 2,
							defaultButton: 3,
							givingUpAfter: 60
						}
					)

					promptedForFullDiskAccess = true

					if (needsFullDiskAccessAlertReply.buttonReturned == revealButtonTitle) {
						sharedWorkspace.openURL($.NSURL.URLWithString('x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles'))

						try { sharedWorkspace.activateFileViewerSelectingURLs($.NSArray.arrayWithObject($.NSURL.fileURLWithPath(appPath))) } catch (ignoredError) { app.beep() }

						justRevealedAppAndSettings = true
					}
				} catch (ignoredError) {
					cleanUpAndQuitEarly()
				}
			} else {
				if (promptedForFullDiskAccess) {
					while (!macIsAwakeAndUnlocked()) // AppleScript dialogs will timeout early if Mac is asleep when it's displayed. So, wait until Mac is awake to display the dialog.
						delay(15)

					$.NSSound.soundNamed('Glass').play

					const tabOrLinebreaks = (isTahoeOrNewer ? '\t' : '\n\n')
					const indentedLinebreakOrOnlyLinebreak = (isTahoeOrNewer ? '\n\0\t' : '\n')

					app.activate()
					app.displayAlert(`‚úÖ${tabOrLinebreaks}${appName}${indentedLinebreakOrOnlyLinebreak}Successfully Granted${indentedLinebreakOrOnlyLinebreak}Full Disk Access`,
						{
							buttons: ['Continue'],
							defaultButton: 1,
							givingUpAfter: 5
						}
					)
				}

				break
			}
		}
	}
}

function promptForPreferences() {
	while (!macIsAwakeAndUnlocked()) // AppleScript dialogs will timeout early if Mac is asleep when it's displayed. So, wait until Mac is awake to display the dialog.
		delay(15)

	const listDisplayPadding = '\t\t\t\t\t\t\t'

	const previousExcludedProducts = getPreference('ExcludeProducts', 'string array') // This returned excluded product will always be sanitized to a valid value by "getPreference()".
	const previousExcludedProductsWithListDisplayPadding = []
	for (const thisPreviousExcludedProduct of previousExcludedProducts)
		previousExcludedProductsWithListDisplayPadding.push(`${listDisplayPadding}${thisPreviousExcludedProduct}`)

	const productsListWithListDisplayPadding = []
	for (const thisProductType of everyProductType)
		productsListWithListDisplayPadding.push(`${listDisplayPadding}${thisProductType}`)

	let excludeProductsArray = []
	for ( ; ; ) {
		app.activate()
		const excludeProductsChooseReply = app.chooseFromList(productsListWithListDisplayPadding,
			{
				withTitle: `${appName} ${settingsOrPreferencesName}  ‚Äî  Exclude Product Types`,
				withPrompt: `üö´\tWould you like to EXCLUDE any types of products?

Select Multiple: Click+Drag, Shift+Click, Command+Click`,
				defaultItems: previousExcludedProductsWithListDisplayPadding,
				okButtonName: 'Save Excluded Product Types Selection',
				cancelButtonName: `Don't Exclude Any Product Types`,
				multipleSelectionsAllowed: true,
				emptySelectionAllowed: true
			}
		)

		if (Array.isArray(excludeProductsChooseReply))
			for (const thisChosenExcludedProduct of excludeProductsChooseReply)
				excludeProductsArray.push(thisChosenExcludedProduct.trim())

		if (excludeProductsArray.length >= productsListWithListDisplayPadding.length) {
			app.activate()
			app.displayAlert(`${appName} won't have any IPSW Firmware files to download if you exclude everything!`,
				{
					message: 'You must include at least one type of product.',
					as: 'critical'
				}
			)

			excludeProductsArray = []
		} else
			break
	}

	setPreference('ExcludeProducts', excludeProductsArray, 'string array')

	if (!excludeProductsArray.includes('iPhone') || !excludeProductsArray.includes('iPad') || !excludeProductsArray.includes('iPod touch') || !excludeProductsArray.includes('Apple TV')) {
		const versionDescriptions = [
			'iOS 26 / iPadOS 26 / tvOS 26 and Newer',
			'iOS 18 and Newer	(iPhone XS & XR, iPad 7)',
			'iOS 17 and Newer	(iPad 6, iPad Pro 10.5-inch & 2nd Gen 12.9-inch)',
			'iOS 16 and Newer	(iPhone 8 - X, iPad 5, iPad Pro 9.7-inch & 1st Gen 12.9-inch)',
			'iOS 15 and Newer	(iPhone 6s - 7, iPad Air 2, iPad mini 4, iPod touch 7)',
			'iOS 12 and Newer	(iPhone 5s - 6, iPad Air, iPad mini 2 - 3, iPod touch 6)',
			'iOS 10 and Newer	(iPhone 5 - 5c, iPad 4)',
			'iOS 9 and Newer	(iPhone 4s, iPad 2 - 3, iPad mini 1, iPod touch 5)',
			'iOS 8 and Newer	(Apple TV 3)',
			'iOS 7 and Newer	(iPhone 4, Apple TV 2)',
			'iOS 6 and Newer	(iPhone 3GS, iPod touch 4)',
			'iOS 5 and Newer	(iPad 1, iPod touch 3)',
			'iOS 4 and Newer	(iPhone 3G, iPod touch 2)'
		]

		const versionsKeys = []
		for (const thisVersionDescription of versionDescriptions)
			versionsKeys.push(parseInt(thisVersionDescription.slice(4, 6)))

		app.activate()
		const includeVersionsChooseReply = app.chooseFromList(versionDescriptions,
			{
				withTitle: `${appName} ${settingsOrPreferencesName}  ‚Äî  Include iOS / iPadOS / tvOS Versions`,
				withPrompt: `üçè\tWhich iOS / iPadOS / tvOS versions would you like to include?

üëâ\tWhen HomePod mini (audioOS), Apple Vision (visionOS), T2 Mac (bridgeOS),
\tor Apple Silicon Mac (macOS) are NOT EXCLUDED, their latest IPSW Firmware files
\twill always be downloaded regardless of the included iOS / iPadOS / tvOS version
\tselection chosen here since there is only a single latest version available for
\teach one of those OSes.

‚ö†Ô∏è\tApple Configurator 2 only supports iOS 7 and newer. Restore older versions using ${isCatalinaOrNewer ? 'Finder' : 'iTunes'}.
\tAlso, older versions of iOS for iPhone 2G (1st Gen) and iPod touch 1 are no longer signed.`,
				defaultItems: versionDescriptions[versionsKeys.indexOf(getPreference('IncludeVersions', 'int'))], // This returned version will always be sanitized to a valid value by "getPreference()".
				okButtonName: 'Save iOS / iPadOS / tvOS Version Selection',
				cancelButtonName: 'Include Every iOS / iPadOS / tvOS Version',
				multipleSelectionsAllowed: false,
				emptySelectionAllowed: false
			}
		)

		let newIncludedVersions = 1
		if (Array.isArray(includeVersionsChooseReply) && (includeVersionsChooseReply.length == 1))
			newIncludedVersions = versionsKeys[versionDescriptions.indexOf(includeVersionsChooseReply[0])]

		setPreference('IncludeVersions', newIncludedVersions, 'int')
	}

	app.activate()
	try {
		const trashOrDeleteDialogButtons = ['Immediately Delete Outdated Files', 'Trash Outdated Files']
		if (shouldImmediatelyDeleteOutdatedFirmwares) trashOrDeleteDialogButtons.reverse()
		app.displayDialog(`üóë\tWould you like outdated IPSW Firmware files to be trashed\n\tor immediately deleted when ${appName} successfully\n\tdownloads updated IPSW Firmware files?

When outdated IPSW Firmware files are set to be trashed, you will need to manually ‚ÄúEmpty Trash‚Äù in Finder to delete the files and reclaim the disk space, which could be quite a few GBs when lots of IPSW Firmware files are updated.

But, when outdated IPSW Firmware files are set to be deleted immediately, the disk space usage should stay pretty level since each outdated IPSW Firmware file will be deleted automatically when the updated IPSW Firwmare file is downloaded.

Outdated IPSW Firmware files are currently set to be ${shouldImmediatelyDeleteOutdatedFirmwares ? 'immediately deleted' : 'trashed'}.`,
			{
				withTitle: `${appName} ${settingsOrPreferencesName}  ‚Äî  Trash or Delete Outdated Files`,
				withIcon: 'note',
				buttons: trashOrDeleteDialogButtons,
				cancelButton: 1,
				defaultButton: 2
			}
		)
	} catch (ignoredError) {
		shouldImmediatelyDeleteOutdatedFirmwares = !shouldImmediatelyDeleteOutdatedFirmwares
		setPreference('ImmediatelyDeleteOutdatedFirmwares', shouldImmediatelyDeleteOutdatedFirmwares, 'bool')
	}

	app.activate()
	try {
		const deleteAppleConfiguratorTemporaryFilesDialogButtons = ['Delete Apple Configurator Temporary Files', 'Leave Apple Configurator Temporary Files Alone']
		if (shouldDeleteAppleConfiguratorTemporaryFiles) deleteAppleConfiguratorTemporaryFilesDialogButtons.reverse()
		app.displayDialog(`üóë\tWould you like to delete Apple Configurator temporary files at the beginning of each run?

When Apple Configurator performs a restore, the IPSW Firmware file is extracted into a temporary location and sometimes those temporary files can get left behind.

Over time, those temporary files could potentially accumulate and fill up the free space on your internal drive. To avoid this issue, ${appName} can delete these Apple Configurator temporary files at the beginning of each run.

Apple Configurator temporary files that ${shouldDeleteAppleConfiguratorTemporaryFiles ? 'will' : 'can'} be deleted are stored at the following locations:
‚Ä¢ ${userLibraryFolder}/Containers/com.apple.configurator.xpc.DeviceService/Data/tmp
‚Ä¢ ${userLibraryFolder}/Containers/com.apple.configurator.xpc.InternetService/Data/tmp

Apple Configurator temporary files are currently set to be ${shouldDeleteAppleConfiguratorTemporaryFiles ? 'deleted' : 'left alone'}.`,
			{
				withTitle: `${appName} ${settingsOrPreferencesName}  ‚Äî  Apple Configurator Temporary Files`,
				withIcon: 'note',
				buttons: deleteAppleConfiguratorTemporaryFilesDialogButtons,
				cancelButton: 1,
				defaultButton: 2
			}
		)
	} catch (ignoredError) {
		shouldDeleteAppleConfiguratorTemporaryFiles = !shouldDeleteAppleConfiguratorTemporaryFiles
		setPreference('DeleteAppleConfiguratorTemporaryFiles', shouldDeleteAppleConfiguratorTemporaryFiles, 'bool')
	}

	let setAutoLaunchDialogTitle = `‚è∞\tWould you like ${appName} to run\n\tautomatically at a scheduled time?`
	let setAutoLaunchDialogMessage = `If you choose to setup Auto-Launch, you will be prompted to set the days of the week and the time that you would like to run ${appName} automatically.`
	let setAutoLaunchDialogButtons = [`Don't Auto-Launch`, 'Setup Auto-Launch‚Ä¶']

	const previousAutoLaunchSchedule = parseLaunchAgentSchedule()

	if (previousAutoLaunchSchedule.days.length > 0) {
		const previousAutoWakeSchedules = parseAutoWakePowerEventPreferences()
		const hasStartUpSchedule = (previousAutoWakeSchedules.On && (previousAutoWakeSchedules.On.type == 'wakepoweron') && (previousAutoWakeSchedules.On.minute == (defaultAutoLaunchMinute - 15)))

		const displayAutoLaunchSchedule = createDisplayScheduleFor(previousAutoLaunchSchedule)

		setAutoLaunchDialogTitle = `‚è∞\tWould you like to keep the current Auto-Launch Schedule for ${appName}?`
		setAutoLaunchDialogMessage = `The following Auto-Launch Schedule is currently set:

	${displayAutoLaunchSchedule}${hasStartUpSchedule ? `

If you choose to remove the Auto-Launch schedule, you will be prompted to remove the current Start Up Schedule.` : ''}

If you choose to change the Auto-Launch schedule, you will be prompted to set new days of the week and time.`
		setAutoLaunchDialogButtons = ['Change Auto-Launch‚Ä¶', `Remove Auto-Launch${hasStartUpSchedule ? '‚Ä¶' : ''}`, 'Keep Current Auto-Launch']
	}

	let newAutoLaunchDaysArray = []
	let newAutoLaunchHour = previousAutoLaunchSchedule.hour

	app.activate()
	try {
		const setAutoLaunchDialogReply = app.displayDialog(`${setAutoLaunchDialogTitle}

${setAutoLaunchDialogMessage}`,
			{
				withTitle: `${appName} ${settingsOrPreferencesName}  ‚Äî  Auto-Launch`,
				withIcon: 'note',
				buttons: setAutoLaunchDialogButtons,
				cancelButton: (setAutoLaunchDialogButtons.length - 1),
				defaultButton: setAutoLaunchDialogButtons.length
			}
		)

		if (setAutoLaunchDialogReply.buttonReturned == 'Keep Current Auto-Launch')
			newAutoLaunchDaysArray = previousAutoLaunchSchedule.days
		else if ((setAutoLaunchDialogReply.buttonReturned == 'Setup Auto-Launch‚Ä¶') || (setAutoLaunchDialogReply.buttonReturned == 'Change Auto-Launch‚Ä¶')) {
			if (previousAutoLaunchSchedule.days.length == 0) previousAutoLaunchSchedule.days = everyDayOfTheWeek
			const previousAutoLaunchDaysWithListDisplayPadding = []
			for (const thisPreviousAutoLaunchScheduleDay of previousAutoLaunchSchedule.days)
				previousAutoLaunchDaysWithListDisplayPadding.push(`${listDisplayPadding}${thisPreviousAutoLaunchScheduleDay}`)

			const everyDayOfTheWeekWithListDisplayPadding = []
			for (const thisDayOfWeek of everyDayOfTheWeek)
				everyDayOfTheWeekWithListDisplayPadding.push(`${listDisplayPadding}${thisDayOfWeek}`)

			app.activate()
			const autoLaunchDaysChooseReply = app.chooseFromList(everyDayOfTheWeekWithListDisplayPadding,
				{
					withTitle: `${appName} ${settingsOrPreferencesName}  ‚Äî  Auto-Launch Days`,
					withPrompt: `‚è∞\tWhat days of the week would you like to Auto-Launch?

Next, you will be prompted to set the time that you'd like to Auto-Launch.

Select Multiple: Click+Drag, Shift+Click, Command+Click`,
					defaultItems: previousAutoLaunchDaysWithListDisplayPadding,
					okButtonName: 'Save Auto-Launch Days Selection',
					cancelButtonName: 'Cancel Auto-Launch',
					multipleSelectionsAllowed: true,
					emptySelectionAllowed: false
				}
			)

			if (Array.isArray(autoLaunchDaysChooseReply))
				for (const thisChosenAutoLaunchDay of autoLaunchDaysChooseReply)
					newAutoLaunchDaysArray.push(thisChosenAutoLaunchDay.trim())

			if (newAutoLaunchDaysArray.length > 0) {
				const autoLaunch24HourTimes = []
				const autoLaunchAMPMTimes = []
				for (let hour = 0; hour <= 23; hour ++) {
					autoLaunch24HourTimes.push(`${hour}:${defaultAutoLaunchMinute}`)
					autoLaunchAMPMTimes.push(`${listDisplayPadding}${((hour == 0) ? 12 : ((hour > 12) ? (hour - 12) : hour))}:${defaultAutoLaunchMinute} ${((hour < 12) ? 'A' : 'P')}M`)
				}

				let defaultAutoLaunchTime = autoLaunchAMPMTimes[autoLaunch24HourTimes.indexOf(`${defaultAutoLaunchHour}:${defaultAutoLaunchMinute}`)]
				const defaultAutoLaunchTimeIndex = autoLaunch24HourTimes.indexOf(`${previousAutoLaunchSchedule.hour}:${defaultAutoLaunchMinute}`)
				if (defaultAutoLaunchTimeIndex != -1) defaultAutoLaunchTime = autoLaunchAMPMTimes[defaultAutoLaunchTimeIndex]

				app.activate()
				const autoLaunchTimeChooseReply = app.chooseFromList(autoLaunchAMPMTimes,
					{
						withTitle: `${appName} ${settingsOrPreferencesName}  ‚Äî  Auto-Launch Time`,
						withPrompt: `‚è∞\tWhat time ${createDisplayScheduleFor({days: newAutoLaunchDaysArray})} would you like to Auto-Launch?
`,
						defaultItems: [defaultAutoLaunchTime],
						okButtonName: 'Save Auto-Launch Time Selection',
						cancelButtonName: 'Cancel Auto-Launch',
						multipleSelectionsAllowed: false,
						emptySelectionAllowed: false
					}
				)

				if (Array.isArray(autoLaunchTimeChooseReply)) {
					const selectedAutoLaunchTimeIndex = autoLaunchAMPMTimes.indexOf(autoLaunchTimeChooseReply[0])
					if (selectedAutoLaunchTimeIndex != -1) {
						const selectedAutoLaunchTimeParts = autoLaunch24HourTimes[selectedAutoLaunchTimeIndex].split(':')
						if (selectedAutoLaunchTimeParts.length == 2) {
							newAutoLaunchHour = parseInt(selectedAutoLaunchTimeParts[0])
							if (newAutoLaunchHour < 0) newAutoLaunchHour = 0
							else if (newAutoLaunchHour > 23) newAutoLaunchHour = 23
						}
					}

					if (newAutoLaunchHour == -1) {
						app.beep()
						newAutoLaunchDaysArray = []
					}
				} else
					newAutoLaunchDaysArray = []
			}
		}
	} catch (ignoredError) {
		// Don't Auto-Launch OR Remove Auto-Launch
	}

	createLaunchAgentWithDaysAndHour(newAutoLaunchDaysArray, newAutoLaunchHour) // This function will create, update, or remove the LaunchAgent as needed based on the input and any existing LaunchAgent.

	if (newAutoLaunchDaysArray.length == 0) {
		const currentAutoWakeSchedules = parseAutoWakePowerEventPreferences()
		if (currentAutoWakeSchedules.On && (currentAutoWakeSchedules.On.type == 'wakepoweron') && (currentAutoWakeSchedules.On.minute == (defaultAutoLaunchMinute - 15)))
			promptToRemovePowerSchedule()
	} else {
		if ((createDisplayScheduleFor(parseLaunchAgentSchedule()) != 'Never') && launchAgentIsDisabledOnVenturaOrNewer())
			for ( ; ; ) {
				if ((createDisplayScheduleFor(parseLaunchAgentSchedule()) == 'Never') || !launchAgentIsDisabledOnVenturaOrNewer()) break

				app.activate()
				try {
					app.displayDialog(`‚è∞\tAuto-Launch for ${appName} has been\n\tmanually disabled in ${systemPreferencesOrSettingsName}.

Until Auto-Launch has been manually re-enable in ${systemPreferencesOrSettingsName}, ${appName} WILL NOT be able to automatically launch at the scheduled time (${createDisplayScheduleFor(parseLaunchAgentSchedule())}).

You can manually re-enable Auto-Launch for ${appName} in ‚Äú${systemPreferencesOrSettingsName}‚Äù by selecting ‚ÄúGeneral‚Äù in the list on the left, and then selecting ‚ÄúLogin Items‚Äù in the list on the right, or you can use the button below to go straight to the Login Items in the General ${systemPreferencesOrSettingsName}.

Then, in the ‚ÄúAllow in the Background‚Äù list in the lower portion of the window, enable the toggle switch to the right of ‚Äú${appName}‚Äù.`,
						{
							withTitle: `${appName} ${settingsOrPreferencesName}  ‚Äî  Auto-Launch Manually Disabled`,
							withIcon: 'caution',
							buttons: [`Reveal Login Items in General ${systemPreferencesOrSettingsName}`, 'Understood'],
							cancelButton: 1,
							defaultButton: 2
						}
					)

					break
				} catch (ignoredError) {
					try {
						$.SMAppService.openSystemSettingsLoginItems // https://developer.apple.com/documentation/servicemanagement/smappservice/4013547-opensystemsettingsloginitems?language=objc
					} catch (ignoredError) {
						app.beep()
					}
				}
			}

		const autoLaunchSchedule = parseLaunchAgentSchedule()

		if (autoLaunchSchedule.days && Array.isArray(autoLaunchSchedule.days) && (autoLaunchSchedule.days.length > 0)) {
			const energySaverOrBatteryPaneName = ((isBigSurOrNewer && macHasBattery()) ? 'Battery' : 'Energy Saver') // On macOS 11 Big Sur and newer, separate "Battery" or "Energy Saver" preferences panes exist for laptops (with batteries) vs desktops.
			let shouldShowAutoLoginDialog = false
			let currentAutoWakeSchedules = {}

			const manualPowerScheduleManagementNotes = `${isVenturaOrNewer ?
	`Although, as of macOS 13 Ventura, the interface to manage the Power Schedule has been removed from ‚Äú${systemPreferencesOrSettingsName}‚Äù and can now only be modified via the ‚Äúpmset‚Äù command line tool, which is how ${appName} has always modified the Power Schedule when you choose to let it do so through these prompts.

Now that there is no longer an interface in ‚Äú${systemPreferencesOrSettingsName}‚Äù for you to change the Power Schedule, you must use the ‚Äúpmset‚Äù command line tool if you want to make any manual changes. To learn how to do that, see the Apple documentation at ‚Äúhttps://support.apple.com/guide/mac-help/schedule-your-mac-to-turn-on-or-off-mchl40376151/13.0/mac/13.0‚Äù as well as the ‚Äúpmset‚Äù manual by running ‚Äúman pmset‚Äù in Terminal (specifically the ‚Äúpmset repeat‚Äù and ‚ÄúSCHEDULED EVENT ARGUMENTS‚Äù sections). Or, you can use the button below to open both the Apple documentation in your default web browser and the ‚Äúpmset‚Äù manual in Terminal.` :
	`The Power Schedule can be manually managed in the ‚Äú${energySaverOrBatteryPaneName}‚Äù section of ‚Äú${systemPreferencesOrSettingsName}‚Äù by clicking ${(isMontereyOrNewer || (isBigSurOrNewer && (energySaverOrBatteryPaneName == 'Battery'))) ? '‚ÄúSchedule‚Äù in the list on the left of the window' : 'the ‚ÄúSchedule‚Ä¶‚Äù button in the bottom right corner of the window'}. You can use the button below to go straight to the Power Schedule in the ${energySaverOrBatteryPaneName} ${systemPreferencesOrSettingsName}.`}`

			for ( ; ; ) {
				const powerScheduleDict = {type: 'wakepoweron', hour: autoLaunchSchedule.hour, minute: (autoLaunchSchedule.minute - 15), days: autoLaunchSchedule.days}
				const displayPowerSchedule = createDisplayScheduleFor(powerScheduleDict)

				currentAutoWakeSchedules = parseAutoWakePowerEventPreferences()

				const proposedSchedulesConflict = hasConflictingPowerSchedules({On: powerScheduleDict, Off: currentAutoWakeSchedules.Off})

				let setPowerScheduleDialogTitle = `üîå\tWould you like to set a Power Schedule to Start Up this Mac 15 minutes before Auto-Launching ${appName}?

This Mac must be turned on and logged in for ${appName} to be able to run at the scheduled time.`

				let setPowerScheduleDialogMessage = `If this Mac gets shut down regularly, it's highly recommended that you set the proposed Start Up Schedule.

It's not an issue if this Mac is set to sleep when inactive since ${appName} will always wake this Mac up when it launches.

You can allow ${appName} to set the following Start Up Schedule for you:

	${displayPowerSchedule}${(currentAutoWakeSchedules.Off ? `

The following ${autoWakeTypeTranslation[currentAutoWakeSchedules.Off.type]} Schedule is currently set and will be preserved:

	${createDisplayScheduleFor(currentAutoWakeSchedules.Off)}${proposedSchedulesConflict ? `
	‚ö†Ô∏è Current ${autoWakeTypeTranslation[currentAutoWakeSchedules.Off.type]} Schedule May Conflict with Proposed Start Up Schedule ‚ö†Ô∏è` : ''}` : '')}

If you choose to have ${appName} set the Start Up Schedule for you, you will be prompted for Administrator Permission. Or, you can manually manage the Power Schedule yourself.

${manualPowerScheduleManagementNotes}`

				let setPowerScheduleDialogButtons = [(isVenturaOrNewer ? 'Open Apple Documentation & ‚Äúpmset‚Äù Manual' : `Reveal Schedule in ${energySaverOrBatteryPaneName} ${systemPreferencesOrSettingsName}`), `Don't Set Start Up Schedule`, 'Set Start Up Schedule‚Ä¶']
				// The Power Schedule GUI has been REMOVED from the new System Settings in macOS 13 Ventura, so do not include a button to reveal a section that will not exist. Instead, include a button to open directly to the Apple documentation about this and the "pmset" man page.

				let onScheduleName = 'Power Schedule'
				if (currentAutoWakeSchedules.On) {
					const currentSchedulesConflict = hasConflictingPowerSchedules(currentAutoWakeSchedules)

					if (JSON.stringify(currentAutoWakeSchedules.On) == JSON.stringify(powerScheduleDict)) {
						onScheduleName = `${autoWakeTypeTranslation[currentAutoWakeSchedules.On.type]} Schedule`

						setPowerScheduleDialogTitle = `üîå\tWould you like to keep the current Power Schedule to Start Up\n\tthis Mac 15 minutes before Auto-Launching ${appName}?

This Mac must be turned on and logged in for ${appName} to be able to run at the scheduled time.`

						setPowerScheduleDialogMessage = `If this Mac gets shut down regularly, it's highly recommended that you keep the current Start Up Schedule.

It's not an issue if this Mac is set to sleep when inactive since ${appName} will always wake this Mac up when it launches.

This Mac currently has the following Power Schedule set:

	${createDisplayScheduleFor(currentAutoWakeSchedules.On)}${(currentAutoWakeSchedules.Off ? `
	${createDisplayScheduleFor(currentAutoWakeSchedules.Off)} üìå Preserved, but not originally created by ${appName}${currentSchedulesConflict ? `
	‚ö†Ô∏è Current ${autoWakeTypeTranslation[currentAutoWakeSchedules.Off.type]} Schedule May Conflict with Current Start Up Schedule ‚ö†Ô∏è` : ''}` : '')}

If you choose to remove the ${onScheduleName}, you will be prompted for final confirmation. Or, you can manually manage the Power Schedule yourself.

${manualPowerScheduleManagementNotes}`

						setPowerScheduleDialogButtons = [(isVenturaOrNewer ? 'Open Apple Documentation & ‚Äúpmset‚Äù Manual' : `Reveal Schedule in ${energySaverOrBatteryPaneName} ${systemPreferencesOrSettingsName}`), `Remove ${onScheduleName}‚Ä¶`, `Keep Current ${onScheduleName}`]
						// The Power Schedule GUI has been REMOVED from the new System Settings in macOS 13 Ventura, so do not include a button to reveal a section that will not exist. Instead, include a button to open directly to the Apple documentation about this and the "pmset" man page.
					} else {
						const powerOffDisplaySchedule = (currentAutoWakeSchedules.Off ? `
	${createDisplayScheduleFor(currentAutoWakeSchedules.Off)}` : '')

						setPowerScheduleDialogTitle = `üîå\tWould you like to replace the current Power Schedule with one that will\n\tStart Up this Mac 15 minutes before Auto-Launching ${appName}?

This Mac must be turned on and logged in for ${appName} to be able to run at the scheduled time.`

						setPowerScheduleDialogMessage = `If this Mac gets shut down regularly, it's highly recommended that you set the proposed Start Up Schedule.

It's not an issue if this Mac is set to sleep when inactive since ${appName} will always wake this Mac up when it launches.

Current Power Schedule:

	${createDisplayScheduleFor(currentAutoWakeSchedules.On)}${powerOffDisplaySchedule}${currentSchedulesConflict ? `
	‚ö†Ô∏è Current ${autoWakeTypeTranslation[currentAutoWakeSchedules.Off.type]} Schedule May Conflict with Current Start Up Schedule ‚ö†Ô∏è` : ''}

Proposed Power Schedule:

	${displayPowerSchedule}${(powerOffDisplaySchedule ? `${powerOffDisplaySchedule} üìå Preserved, but not originally created by ${appName}${proposedSchedulesConflict ? `
	‚ö†Ô∏è Current ${autoWakeTypeTranslation[currentAutoWakeSchedules.Off.type]} Schedule May Conflict with Proposed Start Up Schedule ‚ö†Ô∏è` : ''}` : '')}

If you choose to replace the current Power Schedule with the proposed Start Up Schedule, you will be prompted for Administrator Permission. Or, you can manually manage the Power Schedule yourself.

${manualPowerScheduleManagementNotes}`

						setPowerScheduleDialogButtons = [(isVenturaOrNewer ? 'Open Apple Documentation & ‚Äúpmset‚Äù Manual' : `Reveal Schedule in ${energySaverOrBatteryPaneName} ${systemPreferencesOrSettingsName}`), `Don't Replace Power Schedule`, 'Replace Power Schedule‚Ä¶']
						// The Power Schedule GUI has been REMOVED from the new System Settings in macOS 13 Ventura, so do not include a button to reveal a section that will not exist. Instead, include a button to open directly to the Apple documentation about this and the "pmset" man page.
					}
				}

				app.activate()
				try {
					const setPowerScheduleDialogReply = app.displayDialog(`${setPowerScheduleDialogTitle}

${setPowerScheduleDialogMessage}`,
						{
							withTitle: `${appName} ${settingsOrPreferencesName}  ‚Äî  Power Schedule`,
							withIcon: 'note',
							buttons: setPowerScheduleDialogButtons,
							cancelButton: (setPowerScheduleDialogButtons.length - 1),
							defaultButton: setPowerScheduleDialogButtons.length
						}
					)

					if (setPowerScheduleDialogReply.buttonReturned == `Keep Current ${onScheduleName}`) {
						shouldShowAutoLoginDialog = true

						break
					} else if ((setPowerScheduleDialogReply.buttonReturned == `Reveal Schedule in ${energySaverOrBatteryPaneName} ${systemPreferencesOrSettingsName}`) || (setPowerScheduleDialogReply.buttonReturned == 'Open Apple Documentation & ‚Äúpmset‚Äù Manual')) {
						revealPowerScheduleInSystemPreferences() // This will open Apple documentation and the "pmset" man page when on macOS 13 Ventura.
					} else if ((setPowerScheduleDialogReply.buttonReturned == 'Set Start Up Schedule‚Ä¶') || (setPowerScheduleDialogReply.buttonReturned == 'Replace Power Schedule‚Ä¶')) {
						try {
							let onDaysForPMSet = ''
							for (const thisPowerScheduleDay of powerScheduleDict.days)
								onDaysForPMSet += daysAsLettersForPMSet[everyDayOfTheWeek.indexOf(thisPowerScheduleDay)]

							const newOnPowerSchedule = `${((powerScheduleDict.type == 'wakepoweron') ? 'wakeorpoweron' : powerScheduleDict.type)} ${onDaysForPMSet} ${powerScheduleDict.hour}:${(powerScheduleDict.minute)}:00`

							const latestAutoWakeSchedules = parseAutoWakePowerEventPreferences()
							let existingOffPowerSchedule = ''
							if (latestAutoWakeSchedules.Off) {
								let offDaysForPMSet = ''
								for (const thisLatestAutoWakeScheduleOffDay of latestAutoWakeSchedules.Off.days)
									offDaysForPMSet += daysAsLettersForPMSet[everyDayOfTheWeek.indexOf(thisLatestAutoWakeScheduleOffDay)]

								existingOffPowerSchedule = ` ${latestAutoWakeSchedules.Off.type} ${offDaysForPMSet} ${latestAutoWakeSchedules.Off.hour}:${(latestAutoWakeSchedules.Off.minute)}:00`
							}

							app.doShellScript(`/usr/bin/pmset repeat ${newOnPowerSchedule}${existingOffPowerSchedule}`,
								{
									administratorPrivileges: true,
									withPrompt: `‚Äú${appName}‚Äù requires Admin Permission to set the following Start Up Schedule:

${displayPowerSchedule}${(latestAutoWakeSchedules.Off ? `


The following ${autoWakeTypeTranslation[latestAutoWakeSchedules.Off.type]} Schedule will be preserved:

${createDisplayScheduleFor(latestAutoWakeSchedules.Off)}` : '')}` // Always include "appName" in admin prompt since the requesting app name IS NOT included in the prompt on macOS 11 Big Sur and older (but it is included in the prompt on macOS 12 Monterey and newer).
								}
							)

							shouldShowAutoLoginDialog = true

							break
						} catch (setPowerScheduleError) {
							debugLog(`Set ${onScheduleName} Error`, setPowerScheduleError)

							if ((setPowerScheduleError.errorNumber !== -128) && (setPowerScheduleError.errorNumber !== -60006)) { // https://developer.apple.com/documentation/security/1540004-authorization_services_result_co/errauthorizationcanceled?language=objc
								app.activate()
								app.displayAlert(`${appName}: Failed to Set ${onScheduleName}`,
									{
										message: `${setPowerScheduleError.message}

${JSON.stringify(setPowerScheduleError, Object.getOwnPropertyNames(setPowerScheduleError))}`,
										as: 'critical'
									}
								)
							}
						}
					} else {
						app.beep()
						break
					}
				} catch (setPowerScheduleDialogError) {
					if ((setPowerScheduleDialogError.errorNumber === -128) && currentAutoWakeSchedules.On && (JSON.stringify(currentAutoWakeSchedules.On) == JSON.stringify(powerScheduleDict)))
						promptToRemovePowerSchedule()

					break
				}
			}

			if (shouldShowAutoLoginDialog && (createDisplayScheduleFor(parseAutoWakePowerEventPreferences().On) != 'Never') && ($.NSUserDefaults.alloc.initWithSuiteName('/Library/Preferences/com.apple.loginwindow').stringForKey('autoLoginUser').js != currentUserName))
				for ( ; ; ) {
					if ((createDisplayScheduleFor(parseAutoWakePowerEventPreferences().On) == 'Never') || ($.NSUserDefaults.alloc.initWithSuiteName('/Library/Preferences/com.apple.loginwindow').stringForKey('autoLoginUser').js == currentUserName)) break

					let shouldRevealLoginOptions = false

					const autoLoginNoteDialogButtons = [`Reveal${isVenturaOrNewer ? '' : ' Login Options in'} Users & Groups ${systemPreferencesOrSettingsName}`, 'Understood']

					currentAutoWakeSchedules = parseAutoWakePowerEventPreferences()
					let removeScheduleName = ''
					if (currentAutoWakeSchedules.On) {
						removeScheduleName = `${autoWakeTypeTranslation[currentAutoWakeSchedules.On.type]} Schedule`
						autoLoginNoteDialogButtons.splice(1, 0, `Remove ${removeScheduleName}‚Ä¶`)
					}

					app.activate()
					try {
						const autoLoginNoteDialogReply = app.displayDialog(`üë§\tMake sure Automatic Login is enabled for ‚Äú${$.NSFullUserName().js}‚Äù\n\tso that ${appName} can always run at the scheduled time.

If Automatic Login is disabled, ${appName} won't be able to Auto-Launch when this Mac is turned on by a Start Up Schedule.

You can enable Automatic Login in the ‚ÄúUsers & Groups‚Äù section of ‚Äú${systemPreferencesOrSettingsName}‚Äù${isVenturaOrNewer ? '' : ' by clicking the ‚ÄúLogin Options‚Äù at the bottom of the users list'}, or you can use the button below to go straight to the ${isVenturaOrNewer ? '' : ' Login Options in'} Users & Groups ${systemPreferencesOrSettingsName}.

PLEASE NOTE:
If this Mac has FileVault turned on or an account uses an iCloud password, then Automatic Login cannot be enabled.${(removeScheduleName ? `

If you choose to remove the ${removeScheduleName}, you will be prompted for final confirmation.` : '')}`,
							{
								withTitle: `${appName} ${settingsOrPreferencesName}  ‚Äî  Automatic Login Disabled`,
								withIcon: 'caution',
								buttons: autoLoginNoteDialogButtons,
								cancelButton: (autoLoginNoteDialogButtons.length - 1),
								defaultButton: autoLoginNoteDialogButtons.length
							}
						)

						if (autoLoginNoteDialogReply.buttonReturned == `Reveal${isVenturaOrNewer ? '' : ' Login Options in'} Users & Groups ${systemPreferencesOrSettingsName}`)
							shouldRevealLoginOptions = true
						else
							break
					} catch (autoLoginNoteDialogError) {
						if (autoLoginNoteDialogError.errorNumber === -128) {
							if (currentAutoWakeSchedules.On) {
								promptToRemovePowerSchedule()

								break
							} else
								shouldRevealLoginOptions = true
						} else {
							app.beep()
							break
						}
					}

					if (shouldRevealLoginOptions) {
						try {
							const systemPreferencesOrSettingsApp = Application('com.apple.systempreferences')
							systemPreferencesOrSettingsApp.activate()

							if (isVenturaOrNewer)
								// AppleScript support was not been implemented for the new System Settings app in macOS 13 Ventura, but most sections that could previously be opened via
								// AppleScript "reveal" using pane IDs and anchors can now be opened via URL Scheme using the same pane IDs and anchors (and some have updated pane IDs as well).
								// These URL Schemes even work for some sections like this one where the the URL Schemes did not work in previous versions of macOS
								// (which is why AppleScript "reveal" must still be used on previous versions of macOS).
								// Also, the automatic login options are now visible in the main view instead of behind another section, so the "loginOptionsPref" anchor no longer exists and is not needed
								// (but could still have been accessed by adding "?loginOptionsPref" to the end of the URL Scheme if it was needed).
								// The old pane ID of "com.apple.preferences.users" still works on macOS 13 Ventura, but use the new ID of "com.apple.Users-Groups-Settings.extension" to make sure this is
								// future-proof if the old pane ID ever stops working in a future version of macOS (https://github.com/bvanpeski/SystemPreferences/blob/main/macos_preferencepanes-Ventura.md#users--groups).

								sharedWorkspace.openURL($.NSURL.URLWithString('x-apple.systempreferences:com.apple.Users-Groups-Settings.extension'))
							else
								systemPreferencesOrSettingsApp.panes.byId('com.apple.preferences.users').anchors.byName('loginOptionsPref').reveal()

							systemPreferencesOrSettingsApp.activate()
						} catch (ignoredError) {
							app.beep()
						}
					}
				}

			for ( ; ; ) {
				const conflictingPowerSchedules = hasConflictingPowerSchedules()
				if (conflictingPowerSchedules) {
					const conflictingOnScheduleName = `${autoWakeTypeTranslation[conflictingPowerSchedules.On.type]} Schedule`
					const conflictingOnDisplaySchedule = createDisplayScheduleFor(conflictingPowerSchedules.On)

					const conflictingOffScheduleName = `${autoWakeTypeTranslation[conflictingPowerSchedules.Off.type]} Schedule`
					const conflictingOffDisplaySchedule = createDisplayScheduleFor(conflictingPowerSchedules.Off)

					app.activate()
					try {
						const conflictingPowerScheduleDialogReply = app.displayDialog(`üîå\tThis Mac's current ${conflictingOffScheduleName} may conflict with the current ${conflictingOnScheduleName}.

This Mac currently has the following Power Schedule set:

	${conflictingOnDisplaySchedule}
	${conflictingOffDisplaySchedule}

This could cause ${appName} to not be able to finish updating your IPSW Firmware files properly when it's Auto-Launched.

To solve this conflict, you can allow ${appName} to completely remove the conflicting ${conflictingOffScheduleName} using the button below. Or, you can manually manage the Power Schedule yourself.

${manualPowerScheduleManagementNotes}`,
							{
								withTitle: `${appName} ${settingsOrPreferencesName}  ‚Äî  Power Schedule Conflict`,
								withIcon: 'caution',
								buttons: [(isVenturaOrNewer ? 'Open Apple Documentation & ‚Äúpmset‚Äù Manual' : `Reveal Schedule in ${energySaverOrBatteryPaneName} ${systemPreferencesOrSettingsName}`), `Leave Conflicting ${conflictingOffScheduleName} Alone`, `Remove Conflicting ${conflictingOffScheduleName}‚Ä¶`], // The Power Schedule GUI has been REMOVED from the new System Settings in macOS 13 Ventura, so do not include a button to reveal a section that will not exist. Instead, include a button to open directly to the Apple documentation about this and the "pmset" man page.
								cancelButton: 2,
								defaultButton: 3
							}
						)

						if (conflictingPowerScheduleDialogReply.buttonReturned == `Remove Conflicting ${conflictingOffScheduleName}‚Ä¶`) {
							if (conflictingPowerSchedules.On) {
								let onDaysForPMSet = ''
								for (const thisConflictingAutoWakeScheduleOnDay of conflictingPowerSchedules.On.days)
									onDaysForPMSet += daysAsLettersForPMSet[everyDayOfTheWeek.indexOf(thisConflictingAutoWakeScheduleOnDay)]

								try {
									app.doShellScript(`/usr/bin/pmset repeat wakeorpoweron ${onDaysForPMSet} ${conflictingPowerSchedules.On.hour}:${(conflictingPowerSchedules.On.minute)}:00`,
										{
											administratorPrivileges: true,
											withPrompt: `‚Äú${appName}‚Äù requires Admin Permission to REMOVE the following CONFLICTING ${conflictingOffScheduleName}:

${conflictingOffDisplaySchedule}


The following ${conflictingOnScheduleName} will be preserved:

${conflictingOnDisplaySchedule}` // Always include "appName" in admin prompt since the requesting app name IS NOT included in the prompt on macOS 11 Big Sur and older (but it is included in the prompt on macOS 12 Monterey and newer).
										}
									)

									break
								} catch (removeConflictingPowerScheduleError) {
									debugLog(`Remove Conflicting ${conflictingOffScheduleName} Error`, removeConflictingPowerScheduleError)

									if ((removeConflictingPowerScheduleError.errorNumber !== -128) && (removeConflictingPowerScheduleError.errorNumber !== -60006)) { // https://developer.apple.com/documentation/security/1540004-authorization_services_result_co/errauthorizationcanceled?language=objc
										app.activate()
										app.displayAlert(`${appName}: Failed to Remove Conflicting ${conflictingOffScheduleName}`,
											{
												message: `${removeConflictingPowerScheduleError.message}

${JSON.stringify(removeConflictingPowerScheduleError, Object.getOwnPropertyNames(removeConflictingPowerScheduleError))}`,
												as: 'critical'
											}
										)
									}
								}
							} else {
								app.beep()
								break
							}
						} else
							revealPowerScheduleInSystemPreferences() // This will open Apple documentation and the "pmset" man page when on macOS 13 Ventura.
					} catch (ignoredError) {
						break // Leave Conflicting Power Schedule Alone
					}
				} else
					break
			}
		} else {
			app.activate()
			app.displayAlert(`${appName}: Failed to Set Auto-Launch Schedule`,
				{
					message: 'Restart your computer and then try again.',
					as: 'critical'
				}
			)
		}
	}
}

function promptToRemovePowerSchedule() {
	for ( ; ; ) {
		const currentAutoWakeSchedules = parseAutoWakePowerEventPreferences()

		if (currentAutoWakeSchedules.On) {
			const removeScheduleName = `${autoWakeTypeTranslation[currentAutoWakeSchedules.On.type]} Schedule`

			app.activate()
			try {
				app.displayDialog(`üîå\tRemove the current ${removeScheduleName} for this Mac?

This Mac currently has the following Power Schedule set:

${createDisplayScheduleFor(currentAutoWakeSchedules.On)}${(currentAutoWakeSchedules.Off ? `
${createDisplayScheduleFor(currentAutoWakeSchedules.Off)}

PLEASE NOTE:
The ${autoWakeTypeTranslation[currentAutoWakeSchedules.Off.type]} Schedule will not be removed if you choose remove the ${removeScheduleName}.` : '')}

If you choose to remove the ${removeScheduleName}, you will be prompted for Administrator Permission.`,
					{
						withTitle: `${appName} ${settingsOrPreferencesName}  ‚Äî  Remove ${removeScheduleName}`,
						withIcon: 'note',
						buttons: [`Keep Current ${removeScheduleName}`, `Remove ${removeScheduleName}‚Ä¶`],
						cancelButton: 1,
						defaultButton: 2
					}
				)

				const latestAutoWakeSchedules = parseAutoWakePowerEventPreferences()
				if (latestAutoWakeSchedules.On) {
					let existingOffPowerSchedule = ''
					if (latestAutoWakeSchedules.Off) {
						let offDaysForPMSet = ''
						for (const thisLatestAutoWakeScheduleOffDay of latestAutoWakeSchedules.Off.days)
							offDaysForPMSet += daysAsLettersForPMSet[everyDayOfTheWeek.indexOf(thisLatestAutoWakeScheduleOffDay)]

						existingOffPowerSchedule = `${latestAutoWakeSchedules.Off.type} ${offDaysForPMSet} ${latestAutoWakeSchedules.Off.hour}:${(latestAutoWakeSchedules.Off.minute)}:00`
					}

					try {
						app.doShellScript(`/usr/bin/pmset repeat ${existingOffPowerSchedule || 'cancel'}`,
							{
								administratorPrivileges: true,
								withPrompt: `‚Äú${appName}‚Äù requires Admin Permission to REMOVE the following ${removeScheduleName}:

${createDisplayScheduleFor(latestAutoWakeSchedules.On)}${(latestAutoWakeSchedules.Off ? `


The following ${autoWakeTypeTranslation[latestAutoWakeSchedules.Off.type]} Schedule will be preserved:

${createDisplayScheduleFor(latestAutoWakeSchedules.Off)}` : '')}` // Always include "appName" in admin prompt since the requesting app name IS NOT included in the prompt on macOS 11 Big Sur and older (but it is included in the prompt on macOS 12 Monterey and newer).
							}
						)

						break
					} catch (removePowerScheduleError) {
						debugLog(`Remove ${removeScheduleName} Error`, removePowerScheduleError)

						if ((removePowerScheduleError.errorNumber !== -128) && (removePowerScheduleError.errorNumber !== -60006)) { // https://developer.apple.com/documentation/security/1540004-authorization_services_result_co/errauthorizationcanceled?language=objc
							app.activate()
							app.displayAlert(`${appName}: Failed to Remove ${removeScheduleName}`,
								{
									message: `${removePowerScheduleError.message}

${JSON.stringify(removePowerScheduleError, Object.getOwnPropertyNames(removePowerScheduleError))}`,
									as: 'critical'
								}
							)
						}
					}
				} else {
					app.beep()
					break
				}
			} catch (ignoredError) {
				break // Keep Current Power Schedule
			}
		} else {
			app.beep()
			break
		}
	}
}

function hasConflictingPowerSchedules(latestAutoWakeSchedules = parseAutoWakePowerEventPreferences()) {
	if (latestAutoWakeSchedules.Off && latestAutoWakeSchedules.On &&
		(typeof latestAutoWakeSchedules.Off.type === 'string') && (typeof latestAutoWakeSchedules.On.type === 'string') &&
		((latestAutoWakeSchedules.Off.type == 'shutdown') || (latestAutoWakeSchedules.Off.type == 'restart')) &&
		(latestAutoWakeSchedules.On.type == 'wakepoweron') &&
		(typeof latestAutoWakeSchedules.On.minute === 'number') &&
		(latestAutoWakeSchedules.On.minute == (defaultAutoLaunchMinute - 15)) &&
		Array.isArray(latestAutoWakeSchedules.Off.days) && (latestAutoWakeSchedules.Off.days.length > 0) &&
		Array.isArray(latestAutoWakeSchedules.On.days) && (latestAutoWakeSchedules.On.days.length > 0))
		for (const thisLatestAutoWakeScheduleOffDay of latestAutoWakeSchedules.Off.days)
			if (latestAutoWakeSchedules.On.days.includes(thisLatestAutoWakeScheduleOffDay) &&
				(typeof latestAutoWakeSchedules.Off.hour === 'number') && (typeof latestAutoWakeSchedules.On.hour === 'number') &&
				(latestAutoWakeSchedules.Off.hour >= latestAutoWakeSchedules.On.hour) &&
				(latestAutoWakeSchedules.Off.hour <= (latestAutoWakeSchedules.On.hour + 2)))
				return latestAutoWakeSchedules

	return undefined
}

function createDisplayScheduleFor(eventDict) {
	if ((eventDict !== undefined) && (eventDict instanceof Object) && Array.isArray(eventDict.days) && (eventDict.days.length > 0)) {
		let displayReturnString = ''

		if ((typeof eventDict.type === 'string')) {
			const eventTypeName = autoWakeTypeTranslation[eventDict.type]
			if (eventTypeName) displayReturnString += `${eventTypeName}: `
		}

		displayReturnString += 'Every '

		const JSONdaysString = JSON.stringify(eventDict.days)

		if (JSONdaysString == JSON.stringify(everyDayOfTheWeek))
			displayReturnString += 'Day'
		else if (JSONdaysString == '["Saturday","Sunday"]')
			displayReturnString += 'Weekend'
		else if (JSONdaysString == '["Monday","Tuesday","Wednesday","Thursday","Friday"]')
			displayReturnString += 'Weekday'
		else if (eventDict.days.length <= 2)
			displayReturnString += eventDict.days.join(' and ')
		else
			displayReturnString += `${eventDict.days.slice(0, -1).join(', ')}, and ${eventDict.days.slice(-1)[0]}`

		if ((typeof eventDict.hour === 'number') && (typeof eventDict.minute === 'number'))
			displayReturnString += ` @ ${((eventDict.hour == 0) ? 12 : ((eventDict.hour > 12) ? (eventDict.hour - 12) : eventDict.hour))}:${eventDict.minute.toString().padStart(2, '0')} ${((eventDict.hour < 12) ? 'A' : 'P')}M`

		return displayReturnString
	}

	return 'Never'
}

function parseLaunchAgentSchedule() {
	/** @type {{hour: number, minute: number, days: string[]}} */
	const returnAutoLaunchSchedule = {hour: defaultAutoLaunchHour, minute: defaultAutoLaunchMinute, days: []}

	if (!fileManager.fileExistsAtPath(launchAgentPlistPath)) return returnAutoLaunchSchedule

	let launchAgentScheduleArray = []
	try {
		const parseLaunchAgentPlistFileError = $()
		const launchAgentPlistDict = $.NSDictionary.dictionaryWithContentsOfURLError($.NSURL.fileURLWithPath(launchAgentPlistPath), parseLaunchAgentPlistFileError)
		if (!parseLaunchAgentPlistFileError.isNil()) throw new Error(parseLaunchAgentPlistFileError.description.js)
		launchAgentScheduleArray = ObjC.deepUnwrap(launchAgentPlistDict.objectForKey('StartCalendarInterval'))
		if (launchAgentScheduleArray === undefined) throw new Error('No "StartCalendarInterval" Specified')
		if (!(launchAgentScheduleArray instanceof Object)) throw new Error('INVALID "StartCalendarInterval" Specified')
	} catch (readLaunchAgentPlistError) {
		debugLog('Read Schedule From LaunchAgent PLIST Error', readLaunchAgentPlistError)

		return returnAutoLaunchSchedule
	}

	if (!Array.isArray(launchAgentScheduleArray)) launchAgentScheduleArray = [launchAgentScheduleArray] // Could be a dict if only one day is specified, so wrap it in an array for consistency for the following code.

	const launchAgentDayInts = []

	for (const thisLaunchAgentScheduleDict of launchAgentScheduleArray)
		if (thisLaunchAgentScheduleDict.hasOwnProperty('Hour') && thisLaunchAgentScheduleDict.hasOwnProperty('Minute')) {
			returnAutoLaunchSchedule.hour = +thisLaunchAgentScheduleDict.Hour
			returnAutoLaunchSchedule.minute = +thisLaunchAgentScheduleDict.Minute

			if (thisLaunchAgentScheduleDict.hasOwnProperty('Weekday')) // Weekday won't be specified if every day of the week is intended.
				launchAgentDayInts.push(+thisLaunchAgentScheduleDict.Weekday)
		}

	if (launchAgentDayInts.length == 0)
		returnAutoLaunchSchedule.days = everyDayOfTheWeek
	else {
		const everyDayOfTheWeekStartingAndEndingWithSunday = everyDayOfTheWeek.slice(-1).concat(everyDayOfTheWeek)

		for (let dayIndex = 0; dayIndex < everyDayOfTheWeekStartingAndEndingWithSunday.length; dayIndex ++) {
			const thisDayOfTheWeek = everyDayOfTheWeekStartingAndEndingWithSunday[dayIndex]
			if (launchAgentDayInts.includes(dayIndex) && !returnAutoLaunchSchedule.days.includes(thisDayOfTheWeek))
				returnAutoLaunchSchedule.days.push(thisDayOfTheWeek)
		}

		if ((returnAutoLaunchSchedule.days.length > 1) && (returnAutoLaunchSchedule.days[0] == 'Sunday')) {
			returnAutoLaunchSchedule.days.shift()
			returnAutoLaunchSchedule.days.push('Sunday')
		}
	}

	return returnAutoLaunchSchedule
}

function createLaunchAgentWithDaysAndHour(newAutoLaunchDaysArray, newAutoLaunchHour) {
	if (newAutoLaunchDaysArray.length > 0) {
		// NOTE: The following LaunchAgent dictionary specifies a "Launch IPSW Updater" script which is created and SIGNED by the "Build IPSW Updater.applescript" script.
		// This script MUST be signed so that the "AssociatedBundleIdentifier" key can be used in macOS 13 Ventura so that the LaunchAgent is properly displayed as being for the "IPSW Updater" app.
		// This is because the executable in the LaunchAgent MUST have a Code Signing Team ID that matches the Team ID of the app Bundle ID specified in the "AssociatedBundleIdentifiers" key (as described in https://developer.apple.com/documentation/servicemanagement/updating_helper_executables_from_earlier_versions_of_macos?language=objc#4065210).
		// DO NOT want to have the LaunchAgent just run the "IPSW Updater" app binary directly because if the app is launched that way via the LaunchAgent and then the LaunchAgent is removed during that execution the app will be terminated immediately when "launchctl bootout" is run.
		// That issue has always been avoided by using the "/usr/bin/open" binary to launch the app instead. But using "/usr/bin/open" directly in the LaunchAgent on macOS 13 Ventura makes it show as just running "open" from an unidentified developer in the new Login Items list, which may seem suspicious or confusing.
		// Making this simple SIGNED "Launch IPSW Updater" script which just runs "/usr/bin/open" with the path to the app and then using the "AssociatedBundleIdentifiers" allows the LaunchAgent to be properly displayed as being for the "IPSW Updater" app.
		// When on macOS 12 Monterey and older, the "AssociatedBundleIdentifiers" will just be ignored and the "Launch IPSW Updater" will function the same as if "/usr/bin/open" was directly specified with the path to the app in the LaunchAgent.
		// Search for "AssociatedBundleIdentifiers" in the "Build IPSW Updater.applescript" script to see the "Launch IPSW Updater" script creation and signing code.

		// ALSO NOTE: Manually creating the LaunchAgent plist in this way is considered to be a "Legacy LaunchAgent" as of macOS 13 Ventura: https://developer.apple.com/documentation/servicemanagement/updating_helper_executables_from_earlier_versions_of_macos?language=objc
		// But, the new modern LaunchAgent and LaunchDaemon setup requires that the plist be pre-made and included within the app contents.
		// That is not easily feasible for the needs of this use-case where the user can dynamically choose the day(s) and time that they want the app to be launched.
		// It would techinically be possible pre-make and include every possible LaunchAgent plist and enable the correct one based on the users choice, but that would be hundreds of possible plists.
		// Continuing to create a "Legacy LaunchAgent" by making the LaunchAgent plist dynamically based on the user input and using the "AssociatedBundleIdentifiers" key as described above to properly associate it with the "IPSW Updater" app makes the most sense as long as this "Legacy LaunchAgent" technique continues to work and be allowed by macOS.

		const launchAgentDict = {
			Label: bundleIdentifier,
			Program: `${appPath}/Contents/Resources/Launch ${appName}`,
			AssociatedBundleIdentifiers: bundleIdentifier,
			RunAtLoad: false,
			StandardOutPath: '/dev/null',
			StandardErrorPath: '/dev/null'
		}

		// NOTE: If the following numbers for the LaunchAgent plist are left as JS ints,
		// they will be set to "real" types instead of "integer" types when the
		// dictionary is wrapped to an NSDictionary and written as a plist.
		// So, explicitly wrapping them into NSNumbers solves that.

		const newAutoLaunchHourNumber = $.NSNumber.numberWithInt(newAutoLaunchHour)
		const defaultAutoLaunchMinuteNumber = $.NSNumber.numberWithInt(defaultAutoLaunchMinute)

		if (JSON.stringify(newAutoLaunchDaysArray) == JSON.stringify(everyDayOfTheWeek))
			launchAgentDict.StartCalendarInterval = {
				Hour: newAutoLaunchHourNumber,
				Minute: defaultAutoLaunchMinuteNumber
			}
		else if (newAutoLaunchDaysArray.length == 1)
			launchAgentDict.StartCalendarInterval = {
				Hour: newAutoLaunchHourNumber,
				Minute: defaultAutoLaunchMinuteNumber,
				Weekday: $.NSNumber.numberWithInt(everyDayOfTheWeek.indexOf(newAutoLaunchDaysArray[0]) + 1)
			}
		else {
			launchAgentDict.StartCalendarInterval = []

			for (const thisNewAutoLaunchDay of newAutoLaunchDaysArray)
				launchAgentDict.StartCalendarInterval.push({
					Hour: newAutoLaunchHourNumber,
					Minute: defaultAutoLaunchMinuteNumber,
					Weekday: $.NSNumber.numberWithInt(everyDayOfTheWeek.indexOf(thisNewAutoLaunchDay) + 1)
				})
		}

		let needsToWriteLaunchAgentPlistFile = true
		if (fileManager.fileExistsAtPath(launchAgentPlistPath)) {
			try {
				const readCurrentLaunchAgentPlistFileError = $()
				const currentLaunchAgentPlistContents = $.NSString.stringWithContentsOfFileEncodingError(launchAgentPlistPath, $.NSUTF8StringEncoding, readCurrentLaunchAgentPlistFileError).js
				if (!readCurrentLaunchAgentPlistFileError.isNil()) throw new Error(readCurrentLaunchAgentPlistFileError.description.js)

				const parseNewLaunchAgentPlistContentsError = $()
				const newLaunchAgentPlistContents = $.NSString.alloc.initWithDataEncoding($.NSPropertyListSerialization.dataWithPropertyListFormatOptionsError($(launchAgentDict), $.NSPropertyListXMLFormat_v1_0, 0, parseNewLaunchAgentPlistContentsError), $.NSUTF8StringEncoding).js
				if (!parseNewLaunchAgentPlistContentsError.isNil()) throw new Error(parseNewLaunchAgentPlistContentsError.description.js)

				needsToWriteLaunchAgentPlistFile = (currentLaunchAgentPlistContents != newLaunchAgentPlistContents)
			} catch (readLaunchAgentPlistError) {
				debugLog('Read LaunchAgent Plist Error', readLaunchAgentPlistError)
			}

			if (needsToWriteLaunchAgentPlistFile) {
				try {
					app.doShellScript(`/bin/launchctl bootout ${quoteForShell(`gui/${currentUserID}/${bundleIdentifier}`)}`)
				} catch (bootoutLaunchAgentError) {
					debugLog('Bootout LaunchAgent Error', bootoutLaunchAgentError)
				}

				try { fileManager.removeItemAtPathError(launchAgentPlistPath, $()) } catch (ignoredError) { /* Ignore */ }
			}
		} else if (!fileManager.fileExistsAtPath(launchAgentsPath))
			fileManager.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(launchAgentsPath, true, {}, $())

		if (needsToWriteLaunchAgentPlistFile)
			try {
				const writeLaunchAgentToFileError = $()
				if ($(launchAgentDict).writeToURLError($.NSURL.fileURLWithPath(launchAgentPlistPath), writeLaunchAgentToFileError))
					try {
						app.doShellScript(`/bin/launchctl bootstrap ${quoteForShell(`gui/${currentUserID}`)} ${quoteForShell(launchAgentPlistPath)}`)
					} catch (bootstrapLaunchAgentError) {
						debugLog('Bootstrap LaunchAgent Error', bootstrapLaunchAgentError)
					}
				else {
					if (!writeLaunchAgentToFileError.isNil()) throw new Error(writeLaunchAgentToFileError.description.js)
					throw new Error('Write LaunchAgent Dict to PLIST Failed')
				}
			} catch (writeLaunchAgentPlistError) {
				debugLog('Write LaunchAgent PLIST Error', writeLaunchAgentPlistError)
			}
	} else {
		try { app.doShellScript(`/bin/launchctl bootout ${quoteForShell(`gui/${currentUserID}/${bundleIdentifier}`)}`) } catch (ignoredError) { /* Ignore */ }

		try { fileManager.removeItemAtPathError(launchAgentPlistPath, $()) } catch (ignoredError) { /* Ignore */ }
	}
}

function launchAgentIsDisabledOnVenturaOrNewer() {
	if (isVenturaOrNewer) {
		// Check whether our "Legacy LaunchAgent" has been manually disabled in "System Settings" on macOS 13 Ventura: https://developer.apple.com/documentation/servicemanagement/updating_helper_executables_from_earlier_versions_of_macos?language=objc#4031315
		// The "SMAppServiceStatus" constants (https://developer.apple.com/documentation/servicemanagement/smappservicestatus?language=objc) returned by "statusForLegacyURL" HAVE NOT been bridged to JXA,
		// but through testing on macOS 13 Ventura, I found that "statusForLegacyURL" returns unwrapped JS string values for each "SMAppServiceStatus" constant with the following values:
			// SMAppServiceStatusNotRegistered = "0" (This status is returned when the LaunchAgent plist does not exist.)
			// SMAppServiceStatusEnabled = "1" (This status is returned when the LaunchAgent is enabled, which it should be by default after initial creation.)
			// SMAppServiceStatusRequiresApproval = "2" (This status is returned when the LaunchAgent has been manually disabled in System Settings.)
			// SMAppServiceStatusNotFound = "3" (This status seems to sometimes be returned for a moment after the LaunchAgent is created and boostrapped. See comments below for more information.)

		let launchAgentStatus = '-1'
		for (let waitForLaunchAgentStatus = 0; waitForLaunchAgentStatus < 15; waitForLaunchAgentStatus ++) {
			// I have noticed that right after the LaunchAgent plist has been created and boostrapped, "statusForLegacyURL" may return "3" (SMAppServiceStatusNotFound) for a moment (usually less than half a second) before returning the actual LaunchAgent status.
			// So, wait for UP TO 3 seconds (in 0.2 second increments) for any status value which is not "3" (SMAppServiceStatusNotFound) since this function is only be called when we know the LaunchAgent plist file exists and should have a status of "1" (or "2" when manually disabled).

			try {
				launchAgentStatus = $.SMAppService.statusForLegacyURL($.NSURL.fileURLWithPath(launchAgentPlistPath)) // https://developer.apple.com/documentation/servicemanagement/smappservice/4024717-statusforlegacyurl?language=objc
			} catch (ignoredError) { /* Ignore */ }

			if (launchAgentStatus === '3')
				debugLog('LaunchAgent WAITING FOR STATUS')
			else
				break

			delay(0.2)
		}

		const launchAgentIsDisabled = (launchAgentStatus !== '1')
		if (launchAgentIsDisabled) debugLog('LaunchAgent DISABLED', launchAgentStatus)

		return launchAgentIsDisabled
	}

	return false
}

function parseAutoWakePowerEventPreferences() {
	const returnPowerEvents = {}

	let autoWakePrefsDict = {}
	try {
		const readAutoWakePrefsError = $()
		autoWakePrefsDict = ObjC.deepUnwrap($.NSPropertyListSerialization.propertyListWithDataOptionsFormatError($(app.doShellScript('/usr/bin/defaults export /Library/Preferences/SystemConfiguration/com.apple.AutoWake -')).dataUsingEncoding($.NSUTF8StringEncoding), $.NSPropertyListImmutable, null, readAutoWakePrefsError))
		// NOTE: For some reason trying to retrieve the "RepeatingPowerOn" or "RepeatingPowerOff" keys via ObjC with the following NSUserDefaults method does not return anything, but other keys do work.
		// $.NSUserDefaults.alloc.initWithSuiteName('/Library/Preferences/SystemConfiguration/com.apple.AutoWake').dictionaryForKey('RepeatingPowerOn')
		// So, must just shell out to "defaults export" instead and then create an "NSDictionary" from those contents so that the preferences are properly retrieved through cfprefsd-aware techniques.
		if (!readAutoWakePrefsError.isNil()) throw new Error(readAutoWakePrefsError.description.js)
	} catch (loadAutoWakePrefsError) {
		debugLog('Load AutoWake Prefs Error', loadAutoWakePrefsError)
	}

	if (autoWakePrefsDict && (autoWakePrefsDict.hasOwnProperty('RepeatingPowerOn') || autoWakePrefsDict.hasOwnProperty('RepeatingPowerOff'))) {
		const powerEventOnOrOff = ['On', 'Off']
		const reverseDays = ['Sunday', 'Saturday', 'Friday', 'Thursday', 'Wednesday', 'Tuesday', 'Monday']
		const intsForReverseDays = [64, 32, 16, 8, 4, 2, 1]

		for (const thisPowerEventOnOrOff of powerEventOnOrOff) {
			const thisRepeatingPowerOnOrOffDict = autoWakePrefsDict[`RepeatingPower${thisPowerEventOnOrOff}`]
			if (thisRepeatingPowerOnOrOffDict && thisRepeatingPowerOnOrOffDict.hasOwnProperty('time') && thisRepeatingPowerOnOrOffDict.hasOwnProperty('weekdays') && thisRepeatingPowerOnOrOffDict.hasOwnProperty('eventtype')) {
				const repeatingPowerTimeInt = thisRepeatingPowerOnOrOffDict.time
				const repeatingPowerTimeMinute = (repeatingPowerTimeInt % 60)
				const repeatingPowerTimeHour = ((repeatingPowerTimeInt - repeatingPowerTimeMinute) / 60)

				const repeatingPowerDays = []
				let repeatingPowerWeekdaysInt = thisRepeatingPowerOnOrOffDict.weekdays
				for (let dayIndex = 0; dayIndex < reverseDays.length; dayIndex ++) {
					const thisDayInt = intsForReverseDays[dayIndex]
					if (repeatingPowerWeekdaysInt >= thisDayInt) {
						repeatingPowerDays.unshift(reverseDays[dayIndex])
						repeatingPowerWeekdaysInt -= thisDayInt
					}
				}

				returnPowerEvents[thisPowerEventOnOrOff] = {}
				returnPowerEvents[thisPowerEventOnOrOff].type = thisRepeatingPowerOnOrOffDict.eventtype
				returnPowerEvents[thisPowerEventOnOrOff].hour = repeatingPowerTimeHour
				returnPowerEvents[thisPowerEventOnOrOff].minute = repeatingPowerTimeMinute
				returnPowerEvents[thisPowerEventOnOrOff].days = repeatingPowerDays
			}
		}
	}

	return returnPowerEvents
}

function macHasBattery() {
	// On Intel desktops "ioreg -arc AppleSmartBattery" will return nothing, and on all laptops it will always return an array even if no battery is currently connected/installed.
	// But, on Apple Silicon desktops, it will return the same kind of dictionary as a laptop with no battery currently connected/installed.
	// The following code checks the returned dictionary to see if a battery is installed to properly handle Apple Silicon desktops as well as laptops *with no battery installed*
	// since they will also show the Energy Saver preferences pane, like a desktop does instead of the Battery pane on macOS 11 Big Sur and newer.
	// Errors are totally ignored since it is expected for the following check to error on an Intel desktop, which will then correctly return "false" when the battery check fails for any reason.

	try {
		return (ObjC.deepUnwrap($.NSPropertyListSerialization.propertyListWithDataOptionsFormatError($(app.doShellScript('/usr/sbin/ioreg -arc AppleSmartBattery')).dataUsingEncoding($.NSUTF8StringEncoding), $.NSPropertyListImmutable, null, $()))[0].BatteryInstalled === true)
	} catch (ignoredError) { /* Ignore */ }

	return false
}

function revealPowerScheduleInSystemPreferences() {
	if (isVenturaOrNewer) { // The Power Schedule GUI has been REMOVED from the new System Settings in macOS 13 Ventura, and can now only be editing using the CLI "pmset repeat" command (see Apple documentation link that is opened below for more info).
		sharedWorkspace.openURL($.NSURL.URLWithString('https://support.apple.com/guide/mac-help/schedule-your-mac-to-turn-on-or-off-mchl40376151/13.0/mac/13.0'))
		sharedWorkspace.openURL($.NSURL.URLWithString('x-man-page://pmset'))
	} else {
		let powerSchedulePaneID = 'com.apple.preference.energysaver' // On macOS 10.15 Catalina and older, the Energy Saver preferences pane exists for both laptops and desktops and on macOS 11 Big Sur, the Energy Saver preferences pane still exists for desktops.
		let powerScheduleAnchor = 'Schedule'

		if (isBigSurOrNewer) { // On macOS 11 Big Sur and newer, separate Battery or Energy Saver preferences panes exist for laptops (with batteries) vs desktops.
			if (macHasBattery()) {
				powerSchedulePaneID = 'com.apple.preference.battery'
				powerScheduleAnchor = 'schedule'// Notice this anchor has a lowercased "s" for this new Battery pane.
			} else if (isMontereyOrNewer) {
				// In macOS 12 Monterey, the Energy Saver pane for desktops was re-designed to match the style of the Battery pane and has a new pane ID.
				powerSchedulePaneID = 'com.apple.preferences.EnergySaverPrefPane'
				powerScheduleAnchor = 'schedule'// Notice this anchor has a lowercased "s" for this new Energy Saver pane.
			}
		}

		try {
			const systemPreferencesOrSettingsApp = Application('com.apple.systempreferences')
			systemPreferencesOrSettingsApp.activate()
			systemPreferencesOrSettingsApp.panes.byId(powerSchedulePaneID).anchors.byName(powerScheduleAnchor).reveal()
			systemPreferencesOrSettingsApp.activate()
		} catch (ignoredError) {
			app.beep()
		}
	}
}

function quoteForShell(unquotedString, onlyEscape = false) {
	const escapedString = unquotedString.replace(/'/g, "'\\''")
	return (onlyEscape ? escapedString : `'${escapedString}'`)
}

function quoteForAppleScript(unquotedString, onlyEscape = false) {
	const escapedString = unquotedString.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
	return (onlyEscape ? escapedString : `"${escapedString}"`)
}

function getPreference(key, intendedType = 'string', isReattempt = false) {
	let returnPreferenceValue = undefined

	if (key !== undefined) {
		try {
			if (intendedType == 'url') {
				returnPreferenceValue = standardUserDefaults.URLForKey(key).absoluteString.js
				if (typeof returnPreferenceValue != 'string')
					throw new Error(`URL Preference Value Is "${typeof returnPreferenceValue}" Instead of "string"`)
			} else if (intendedType == 'array') {
				returnPreferenceValue = ObjC.deepUnwrap(standardUserDefaults.arrayForKey(key))
				if (!Array.isArray(returnPreferenceValue))
					throw new Error('Array Preference Value Is Not "array"')
			} else if (intendedType == 'dict') {
				returnPreferenceValue = ObjC.deepUnwrap(standardUserDefaults.dictionaryForKey(key))
				if (!(returnPreferenceValue instanceof Object))
					throw new Error(`Dict Preference Value Is "${typeof returnPreferenceValue}" Instead of "object"`)
			} else if (intendedType == 'string') {
				returnPreferenceValue = standardUserDefaults.stringForKey(key).js
				if (typeof returnPreferenceValue != 'string')
					throw new Error(`String Preference Value Is "${typeof returnPreferenceValue}" Instead of "string"`)
			} else if (intendedType == 'string array') {
				returnPreferenceValue = ObjC.deepUnwrap(standardUserDefaults.stringArrayForKey(key))
				if (!Array.isArray(returnPreferenceValue))
					throw new Error('String Array Preference Value Is Not "array"')
			} else if (intendedType == 'data')
				returnPreferenceValue = standardUserDefaults.dataForKey(key)
			else if (intendedType == 'bool') {
				returnPreferenceValue = standardUserDefaults.boolForKey(key) // DO NOT ".js" unwrap boolean since it's already unwrapped and will be undefined if ".js" is used.
				if (typeof returnPreferenceValue != 'boolean')
					throw new Error(`Bool Preference Value Is "${typeof returnPreferenceValue}" Instead of "bool"`)
			} else if (intendedType == 'int') {
				returnPreferenceValue = parseInt(standardUserDefaults.integerForKey(key)) // DO NOT ".js" unwrap integer since it's already unwrapped and will be undefined if ".js" is used.
				if (typeof returnPreferenceValue != 'number')
					throw new Error(`Int Preference Value Is "${typeof returnPreferenceValue}" Instead of "number"`)
			} else if (intendedType == 'float') {
				returnPreferenceValue = parseFloat(standardUserDefaults.floatForKey(key)) // DO NOT ".js" unwrap float since it's already unwrapped and will be undefined if ".js" is used.
				if (typeof returnPreferenceValue != 'number')
					throw new Error(`Float Preference Value Is "${typeof returnPreferenceValue}" Instead of "number"`)
			} else if (intendedType == 'double') {
				returnPreferenceValue = parseFloat(standardUserDefaults.doubleForKey(key)) // DO NOT ".js" unwrap double since it's already unwrapped and will be undefined if ".js" is used.
				if (typeof returnPreferenceValue != 'number')
					throw new Error(`Double Preference Value Is "${typeof returnPreferenceValue}" Instead of "number"`)
			} else
				returnPreferenceValue = ObjC.deepUnwrap(standardUserDefaults.objectForKey(key))
		} catch (getPreferenceError) {
			debugLog(`GET Preference Error (${key}, ${intendedType}): ${returnPreferenceValue}`, getPreferenceError)

			if (!isReattempt && (returnPreferenceValue !== undefined)) { // Do not reattempt if the the preference key already doesn't exist.
				try { standardUserDefaults.removeObjectForKey(key) } catch (ignoredError) { /* Ignore */ }

				debugLog(`DELETED Preference ${key} & Reattempting GET`)

				return getPreference(key, intendedType, true)
			}

			returnPreferenceValue = undefined
		}
	}

	if (key == 'IncludeVersions') {
		if (!returnPreferenceValue || (returnPreferenceValue <= 0)) returnPreferenceValue = 7 // Default to iOS 7 if no value or a negative (invalid) value is set.
		else if (returnPreferenceValue < 4) returnPreferenceValue = 4 // iOS 4 supports the same devices as iOS 1 through iOS 3, except for the iPhone 2G (1st Gen) and iPod touch 1 which supported iOS 3 but that's no longer signed.
		else if (returnPreferenceValue == 11) returnPreferenceValue = 12 // iOS 12 supports the same devices as iOS 11.
		else if ((returnPreferenceValue == 13) || (returnPreferenceValue == 14)) returnPreferenceValue = 15 // iOS 15 supports the same devices as iOS 13 and iOS 14.
		else if ((returnPreferenceValue > 18) && (returnPreferenceValue < 26)) returnPreferenceValue = 26 // At WWDC25, Apple announced all future OS versioning will be year-based, so iOS 26 followed right after iOS 18.
		else if (returnPreferenceValue > 26) returnPreferenceValue = 26 // iOS 26 is the latest version at this time (and the newest version listed in the "versionDescriptions" array).
	} else if ((returnPreferenceValue !== undefined) && (key == 'ExcludeProducts')) {
		const validatedExcludedProducts = []
		for (const thisProductType of everyProductType)
			if (returnPreferenceValue.includes(thisProductType))
				validatedExcludedProducts.push(thisProductType)

		returnPreferenceValue = validatedExcludedProducts
	}

	return returnPreferenceValue
}

function setPreference(key, value, type = 'string') {
	if ((key !== undefined) && (value !== undefined))
		try {
			if (type == 'url')
				standardUserDefaults.setURLForKey($.NSURL.URLWithString(value), key)
			else if (type == 'bool')
				standardUserDefaults.setBoolForKey(value, key)
			else if (type == 'int')
				standardUserDefaults.setIntegerForKey(value, key)
			else if (type == 'float')
				standardUserDefaults.setFloatForKey(value, key)
			else if (type == 'double')
				standardUserDefaults.setDoubleForKey(value, key)
			else
				standardUserDefaults.setObjectForKey(value, key)

			return true
		} catch (setPreferenceError) {
			debugLog(`SET Preference Error (${key}, ${value}, ${type})`, setPreferenceError)
			return false
		}

	return false
}

function debugLog(message, error) {
	if (message !== undefined) {
		if (message instanceof Object)
			message = JSON.stringify(message, null, 4)

		let displayError = ''
		if (error !== undefined) {
			displayError = ': '
			if (error.message) displayError += error.message
			if (error instanceof Object) displayError += ` - ${JSON.stringify(error, Object.getOwnPropertyNames(error))}`
			else displayError += error
		}

		$.NSLog(`DEBUG - ${message}${displayError}`)
	}
}

function debugDialog(message = 'UNDEFINED', title = 'DEBUG') {
	if (!title.startsWith('DEBUG')) title = `DEBUG: ${title}`
	if (message instanceof Object) message = JSON.stringify(message, (Object.getOwnPropertyNames(message).includes('stack') ? Object.getOwnPropertyNames(message) : null), 4) // Check if object properties contains "stack" to determine if it's an error object that needs its properties specified in "JSON.stringify()".

	app.activate()
	app.displayDialog(title,
		{
			defaultAnswer: message,
			buttons: ['Quit', 'Continue'],
			cancelButton: 1,
			defaultButton: 2
		}
	)
}

function cleanUpBeforeQuitting() {
	// CANNOT use the "quit()" handler (https://developer.apple.com/library/archive/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/OSX10-10.html#//apple_ref/doc/uid/TP40014508-CH109-SW15)
	// because it appears to not get run when the "quit()" function is loaded via "eval()" like it would be if it was included in this code.
	// For the "quit()" handler to work properly, it must exist in the main script when it is first loaded.
	// So, instead just call this "cleanUpBeforeQuitting()" function manually at the very end of this script to behave the same as the automatic "quit()" handler would.

	debugLog('Quitting‚Ä¶')

	if (backgroundPIDs.length > 0)
		try { app.doShellScript(`kill ${backgroundPIDs.join(' ')}`) } catch (ignoredError) { /* Ignore */ }

	if (appIsQuarantined) {
		let appPaths = []
		try { appPaths = app.doShellScript(`/usr/bin/mdfind kMDItemCFBundleIdentifier = ${bundleIdentifier}`).split(/\n|\r/) } catch (ignoredError) { /* Ignore */ }

		if (appPaths.length > 0)
			app.doShellScript(`/usr/bin/osascript -e ${quoteForShell(`
delay 0.5
repeat while (application ${quoteForAppleScript(appPath)} is running)
	delay 0.5
end repeat
try
	do shell script "/usr/bin/xattr -drs com.apple.quarantine " & ${appPaths.map(thisAppPath => `(quoted form of ${quoteForAppleScript(thisAppPath)})`).join(' & " " & ')}
end try
`)} > /dev/null 2>&1 &`)
	}

	try { fileManager.removeItemAtPathError(temporaryFilesFolder, $()) } catch (ignoredError) { /* Ignore */ }
}

function cleanUpAndQuitEarly() {
	cleanUpBeforeQuitting()
	app.quit() // Even if the JXA "quit()" handler could be used, it would NOT get called when "app.quit()" is run manually, so the handler would have to be called manually before running "app.quit()" anyways.
}

cleanUpBeforeQuitting() // Call "cleanUpBeforeQuitting()" manually at the end of the script since getting here would indicate a graceful quit, and can't use the JXA "quit()" handler (as described in the "cleanUpBeforeQuitting()" comments).
